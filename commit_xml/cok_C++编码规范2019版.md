# C++ 编码规范

## 版本及说明

- 目前cok使用的c++版本基于c++11规范，兼容IOS和android平台，需要保证x64编译通过后再进行提交；

- 提交前需要保证xcode11或xcode10下编译通过；

- 暂时禁用c++14新增语法特性；

- 客户端的c++编码部分请参考本规范进行

  


## 文件格式和文件粒度

- 文件编码用 UTF-8；
- VC中的筛选器需要与文件存放的文件夹保持相同路径和名称一致





## 代码外观和格式

### 列宽

代码列宽尽量控制在一屏可显示（120字符以内）

### 换行

当表达式超出或即将超出规定的列宽，遵循以下规则进行换行

- 在逗号后换行


- 在操作符前换行

当以上规则会导致代码混乱的时候自己采取更灵活的换行规则

### 缩进

- **4 空格**，（tab应该设置为4空格）

### 空行

空行是为了将逻辑上相关联的代码分块，以便提高代码的可阅读性，只需要留一行空行即可，留太多空行不利于同屏显示多行代码，影响阅读效率

**在以下情况下使用一个空行**

- 枚举和类的定义之间。（若出现这种情况）；
- 类与类的定义之间。（若出现这种情况）；


- 函数与函数、函数与变量之间；
- 函数中变量声明与语句之间；

### 空格

**在以下情况中要使用到空格**

- 关键字和 “(” 应该用空格隔开。如：

  ```c++
  while (true)
  {
      
  }

  if (a == 3)
  {
      
  }
  ```

  注意在方法名和左括符 “(” 之间不要使用空格，这样有助于辨认代码中的方法调用与关键字。

- 多个参数用逗号隔开，每个逗号后都应加一个空格。

- 除了 `.` 之外，所有的二元操作符都应用空格与它们的操作数隔开。一元操作符、`++` 及 `--`与操作数间不需要空格。如：

  ```c++
  a += c + d;
  a = (a + b) / (c * d);

  while (d++ == s++)
  {
      n++;
  }

  cout << "size is " << size << "\n" << endl;
  ```


- 语句中的表达式之间用空格隔开。如：

  ```c++
  for (expr1; expr2; expr3)
  ```

- 注意在源码的**行尾**不应有多余的空格。

### 括号 - ()

- 左括号 `(` 不要紧靠关键字，中间用一个空格隔开。
- 左括号 `(` 与函数名之间不要添加任何空格。
- 没有必要的话不要在`return`语句中使用括号。

### 花括号 - {}

- 左花括号 `{` 放于关键字或方法名的下一行并与之对齐。如：

```c#
if (condition)
{
}

public int Add(int x, int y)
{
    return x + y;
}
```

- 左花括号 `{` 要与相应的右花括号 `}`对齐；
- 除了应用于个位数的数组定义外，左花括号不要跟在行尾；
- 通常情况下左花括号 `{` 单独成行，不与任何语句并列一行；
- `if`、`while`、`do` 语句后一定要使用花括号，即使其中为空或只有一条语句。如：

```c#
if (somevalue == 1)
{
    somevalue = 2;
}
```

（在VC下，可以使用ctrl+k, ctrl+D来进行格式化）

### Lambda表达式

Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.

- 若用引用捕获, 在变量名和 `&` 之间不留空格.

```c++
int x = 0;
auto add_to_x = [&x](int n) { x += n; };
```

- 短 lambda 就写得和内联函数一样，如果超过一行，则需要将函数体换行写：

```c++
std::set<int> blacklist = {7, 8, 9};
std::vector<int> digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(),
	[&blacklist](int i) 
	{
        return blacklist.find(i) != blacklist.end();
    }), digits.end());
```

### 指针和引用表达式

- 句点或箭头前后不要有空格. 指针/地址操作符 (`*, &`) 之后不能有空格.

  ```c++
  CServerCha             *pCha;	// 正确写法
  CServerCha*             pCha;   // 不提倡的写法
  int abc = &Value;			   // 正确的写法
  int abc = & Value;			   // 不提倡的写法
  ```

### 预处理指令、宏定义

- 预处理指令不要缩进，从行首开始；
- 即使预处理指令位于缩进代码块中，指令也应从行首开始：

```c++
// 好 - 指令从行首开始
if (lopsided_score) 
{
#if DISASTER_PENDING      // 正确 - 从行首开始
    DropEverything();
# if NOTIFY               // 不提倡 - # 后不要跟空格
    NotifyClient();
# endif                   // 不提倡
#endif
    BackToNormal();
    #if ABC               // 错误，应该从行首开始
        ....
    #endif                // 错误
}

```

### 命名空间

- 命名空间不缩进；

- 不要在命名空间内缩进；

- 嵌套命名空间时, 每个命名空间都独立成行.

  ```c++
  namespace 
  {
  void foo() 
  {  // 正确. 命名空间内没有额外的缩进.
    ...
  }
  }  // namespace
  ```




## 程序注释

### 注释概述

- 修改代码时，要同步更新代码注释；
- 所有类的头部都要有注释，简要说明此类的作用；
- 底层公共函数最好都有注释；
- 避免杂乱和无意义的注释，如一整行星号； 
- 在编写代码时及时添加注释；
- 在编写注释时使用完整的句子；
- 用中文注释；
- 为了防止问题反复出现，对错误修复和解决方法代码总是使用注释；
- 代码修改变更记录不应在注释中标明修改日期和修改人，svn都有记录

### 类 C 注释

该类注释用于一行内前后都有代码的情况，如

```c++
for (int i = 0; i < number; /* Empty Increment */)
```

### 单行注释

该类注释用于函数内的变量声明或代码段的解释

### 多行注释

- 避免使用 /`* ... */` 方式进行多行注释，不利于gcc下编辑代码；
- 注释不需要的语句时，使用VCt提供的多行注释按钮批量添加注释，取消时同样使用VC提供的按钮进行；



## 命名约定

### 通用约定

文件命名、函数命名、变量命名都要有描述性，少用缩写，避免使用重复、冗长、无意义或者不知所云的命名，如：

- 正确的命名：  PlayerLevelUp()  
- 正确的命名：  GetItemPrice()
- 正确的命名：  ServerCha()（cha是约定俗成的character的缩写）
- 错误的命名：  void PLU()（不知所云）
- 错误的命名：  PlayerWhoCanLevelUpNowNeedToLevelUp()（冗长）
- 错误的命名：int ppppp（不允许胡乱命名）

### 文件命名

- 文件名采用 Pascal 命名风格（每个单词首字母大写，文件名首字母大写）；
- c++文件后缀名为`.cpp`，头文件后缀名为`.h`，专门插入文本的文件后缀名为`.inc`
- 中间件及基础层的文件命名可依据原有规范统一增加前缀，如`wh_`或者`pnl_`，避免与标准模板库或linux下/usr/include中的文件名出现冲突；

### 类命名

- 所有类型，包括类、结构体、类型模板参数均采用同一命名规则；
- 类型名称的每个单词首字母均大写, 不包含下划线: `MyExcitingClass`, `MyExcitingEnum`

### 全局变量命名

- 全局变量命名需要增加前缀`g_`

### 静态变量

- 静态变量命名需要增加前缀s_

### 成员变量

- 成员变量命名需要增加前缀m_

### 宏、枚举命名

- 采用全大写命名

### 大小写规则

下表汇总了大写规则，并提供了不同类型的标识符的示例。

| 标识符           | 大小写      | 示例       |
| ---------------- | ----------- | ---------- |
| 类               | Pascal      | AppDomain  |
| 枚举类型         | Pascal      | ErrorLevel |
| 枚举值           | 全大写      | FATALERROR |
| 只读的静态字段   | Pascal      | RedValue   |
| 常量             | Pascal      | PageTitle  |
| 函数             | Pascal      | ToString   |
| 命名空间         | Pascal      | Common     |
| 公共成员变量     | m_ + Pascal | m_RedValue |
| 受保护的实例字段 | m_ + Pascal | m_RedValue |
| 私有的实例字段   | m_ + Pascal | m_RedValue |
| 参数             | Camel       | typeName   |
| 局部变量         | Camel       | backColor  |
| 全局变量         | g_ +Pascal  | g_Value    |
| 静态变量         | s_+Pascal   | s_Value    |



## 头文件

除了main.cpp中外，类的定义必须写在头文件中，以便于被其他类引用

### #define保护

所有头文件都应该使用 `#define` 来防止头文件被多重包含, 命名格式当是: `#define <PROJECT>_<PATH>_<FILE>_H`

### 内联函数

只有当函数只有 **10** 行甚至更少时才将其定义为内联函数.

### include顺序

相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h，头文件包含顺序可增强可读性, 避免隐藏依赖



## 作用域

### 命名空间（namespace）

- 不要随意新建命名空间，除了中间件和可跨项目复用代码外，每个项目一般来说只需要唯一的命名空间；
- 禁止用内联命名空间；
- 禁止使用匿名命名空间，特殊情况除外



## 类

### 构造函数

- 所有类都需要提供构造函数，实体-关系模型中的实体类最好能够提供拷贝构造函数，避免成员变量在复制时被浅拷贝的情况出现；
- 不要在构造函数中调用虚函数

### 拷贝

- 任何时候都应该避免浅拷贝现象的出现；
- 必须严格检查并避免拷贝过程中可能会产生的野指针；
- *memcpy*在cpu执行级别会有优化，拷贝字节较多时，其开销远小于同功能的逐字符拷贝；
- 使用*std::move*语义时，一定要搞清楚其含义，务必要分清楚*std::move*和*memmove*的区别；
- 拷贝字符串时，使用带有长度限制的strncpy，禁止使用strcpy等非安全版本

### 结构体

- 仅当只有数据成员时使用 `struct`, 其它一概使用 `class`；
- 为了和 STL 保持一致, 对于仿函数等特性可以不用 `class` 而是使用 `struct`；

### 多重继承

- 只有当所有父类除第一个外都是纯接口类时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 `Interface` 为后缀.；
- 无论父类还是子类，虚函数务必增加`vitual`关键字

### 运算符重载

除少数特定环境外，不要重载运算符，也不要创建用户定义数值类型

### 声明次序

将`public`、`private`、`protected`类型的函数和变量声明分别放到一起，应该避免三个以上public等关键字的出现，便于代码维护和阅读

### 类型及转换

- double转float，double转int，float转int，int转short，longlong转int，longlong转double，int转char，short转char等情况时，务必要考虑到精度丢失问题；
- 所有可能用于数据存储的整数类型，尽量统一使用64位类型，所有可能用于存储的浮点类型，统一使用double类型；
- 使用 C++ 的类型转换,，如 `static_cast<>()，`不要使用`int y = (int)x`或`int y = int(x)`等转换方式;

### 

## 函数

函数内部实现不应该过长，应该避免出现*500*行以上的函数，过长的函数应拆分为多个函数，以便于代码的分块

### 参数顺序

函数的参数顺序为：输入参数在先，后跟输出参数

### 参数

- 如果函数需要修改参数的值，参数定义为引用好于将参数定义为指针，后者非常容易出现野指针问题，且很难排查；
- 如果不需要修改参数的值，函数参数列表中，所有引用参数都最好是`const`；
- 虚函数不允许使用缺省参数

### 右值引用

右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。

右值引用用于定义移动构造函数（使用类的右值引用进行构造的函数）使得移动一个值而非拷贝成为可能。例如：

~~~c++
std::vector<std::string> v1;
v1.push_back("daojian");
// 左值引用，值拷贝
std::vector<std::string> v2 = v1;
// 右值引用，指针操作，运行后v1失去指向内容，size为0
std::vector<std::string> v3 = std::move(v1);
~~~

在某些情况下这将带来大幅度的性能提升；

- 右值引用能实现可移动但不可拷贝的类型，这一特性对那些在拷贝方面没有实际需求，但有时又需要将它们作为函数参数传递或塞入容器的类型很有用；
- 使用前，需要搞清楚右值、左值、常量左值、move语义、完美转发等概念

### 返回类型的后置语法

- 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法；
- C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前，后置类型在函数名前使用 `auto` 关键字, 在参数列表之后后置返回类型.。例如：

```c++
// 传统做法，绝大部分情况下使用
int Foo(int value){ }
// c++11语法，特殊情况下使用
auto foo(int value) -> int {}
```

### Lambda表达式

Lambda 表达式又称匿名函数，是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：

```c++
std::sort(v.begin(), v.end(), [](int x, int y) 
{
    return Weight(x) < Weight(y);
});
```

- 适当使用 lambda 表达式；
- 禁用默认捕获，捕获都要显式写出来。打比方，比起 `[=](int x) {return x + n;}`,应该写成 `[n](int x) {return x + n;}` 才对，这样读者也好一眼看出 `n` 是被捕获的值；
- 如果可读性更好，就显式写出 lambda 的尾置返回类型，至少使用auto；
- lambda表达式（匿名函数）一定要简短，超过10行的匿名函数都最好能专门开一个具名函数来实现


### 一些特殊函数

- 不要使用`std::list`的`size()`，这个函数在vc下时间复杂度是O(1)，但是在gcc下会整体遍历，时间复杂度为O(n)；
- `std::vector`插入右值时，使用`emplace_back()`代替`push_back()`



## 内存管理

- 对于有数量限制的对象数组，内存池的使用要优于使用`new`。对于个别的变量或者全局变量，使用`new`进行分配；
- 保证`new`出的对象被`delete`，全局变量可以例外；
- 最好不要使用`malloc`进行内存分配操作，而是使用`new`代替；
- 使用智能指针，但一定要搞清楚几种智能指针的用途；
- 使用memcpy拷贝数组，严禁使用strcpy拷贝数组




## 其他

- 生产代码中应该避免晦涩语法，会导致他人阅读困难，不利于维护代码。例如：

  ~~~c++
  int Array[3] = { 1, 2， 3 };
  int *p = &Array[0];
  // 不宜读
  std::cout << *p+*p+++*++p << std::endl;
  ~~~

- 除了可变字符串处理等函数，我们不允许使用变长数组和 `alloca()`。变长数组和 `alloca()` 不是标准 C++ 的组成部分。更重要的是，它们根据数据大小动态分配堆栈内存，会引起难以发现的内存越界 bugs；

- 除了网络协议解析等部分代码外，不要捕获并抛出异常，直接让代码崩溃要好于抛出异常；

- 不考虑返回值的话，前置自增 (`++i`) 通常要比后置自增 (`i++`) 效率更高；

- `const`变量、数据成员、函数和参数为编译时类型检测增加了一层保障，便于尽早发现错误。因此，我们强烈建议在任何可能的情况下使用`const`；

- 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化；

- C++11 中，若变量被声明成`auto，`那它的类型就会被自动匹配成初始化表达式的类型。您可以用`auto`来复制初始化或绑定引用；

- 不要轻易尝试模板元编程，也不要使用复杂的模板编程，非常不利于调试，也不利于新手程序员来维护；

- 只使用boost中被认可的库，比如取随机数；

- 跨线程代码需要考虑线程安全问题，单一线程间交互优先使用无锁环形队列，服务器各进程的主线程代码最好不要加任何锁；

- 除了注释和日志外，代码中不得有任何中文字符；

- 所有在大小判定或数组定义中直接出现的常数值，都应该使用宏代替

  



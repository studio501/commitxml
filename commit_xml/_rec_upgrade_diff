{"Sprite::setTextureRect-Rect&-bool-Size&": ["void Sprite::setTextureRect(const Rect& rect, bool rotated, const Size& untrimmedSize)\n", "{\n", "    _rectRotated = rotated;\n", "\n", "    Node::setContentSize(untrimmedSize);\n", "    _originalContentSize = untrimmedSize;\n", "\n", "    setVertexRect(rect);\n", "    updateStretchFactor();\n", "    updatePoly();\n", "}\n"], "Sprite::setTextureCoords-Rect&": ["void Sprite::setTextureCoords(const Rect& rectInPoints)\n", "{\n", "    setTextureCoords(rectInPoints, &_quad);\n", "}\n"], "Sprite::setFlippedX-bool": ["void Sprite::setFlippedX(bool flippedX)\n", "{\n", "    if (_flippedX != flippedX)\n", "    {\n", "        _flippedX = flippedX;\n", "        flipX();\n", "    }\n", "}\n"], "Sprite::setFlippedY-bool": ["void Sprite::setFlippedY(bool flippedY)\n", "{\n", "#ifdef CC_USE_METAL\n", "    if(_texture->isRenderTarget())\n", "        flippedY = !flippedY;\n", "#endif\n", "    if (_flippedY != flippedY)\n", "    {\n", "        _flippedY = flippedY;\n", "        flipY();\n", "    }\n", "}\n"], "Sprite::setSpriteFrame-SpriteFrame*": ["void Sprite::setSpriteFrame(SpriteFrame *spriteFrame)\n", "{\n", "    // retain the sprite frame\n", "    // do not removed by SpriteFrameCache::removeUnusedSpriteFrames\n", "    if (_spriteFrame != spriteFrame)\n", "    {\n", "        CC_SAFE_RELEASE(_spriteFrame);\n", "        _spriteFrame = spriteFrame;\n", "        spriteFrame->retain();\n", "    }\n", "    _unflippedOffsetPositionFromCenter = spriteFrame->getOffset();\n", "\n", "    Texture2D *texture = spriteFrame->getTexture();\n", "    // update texture before updating texture rect\n", "    if (texture != _texture)\n", "        setTexture(texture);\n", "\n", "    // update rect\n", "    _rectRotated = spriteFrame->isRotated();\n", "    setTextureRect(spriteFrame->getRect(), _rectRotated, spriteFrame->getOriginalSize());\n", "\n", "    if (spriteFrame->hasPolygonInfo())\n", "    {\n", "        _polyInfo = spriteFrame->getPolygonInfo();\n", "        _renderMode = RenderMode::POLYGON;\n", "        if (_flippedX) flipX();\n", "        if (_flippedY) flipY();\n", "        updateColor();\n", "    }\n", "    if (spriteFrame->hasAnchorPoint())\n", "        setAnchorPoint(spriteFrame->getAnchorPoint());\n", "    if (spriteFrame->hasCenterRect())\n", "        setCenterRect(spriteFrame->getCenterRect());\n", "}\n"], "Renderer::processRenderCommand-RenderCommand*": ["void Renderer::processRenderCommand(RenderCommand* command)\n", "{\n", "    auto commandType = command->getType();\n", "    switch(commandType)\n", "    {\n", "        case RenderCommand::Type::TRIANGLES_COMMAND:\n", "        {\n", "            // flush other queues\n", "            flush3D();\n", "            \n", "            auto cmd = static_cast<TrianglesCommand*>(command);\n", "            \n", "            // flush own queue when buffer is full\n", "            if(_queuedTotalVertexCount + cmd->getVertexCount() > VBO_SIZE || _queuedTotalIndexCount + cmd->getIndexCount() > INDEX_VBO_SIZE)\n", "            {\n", "                CCASSERT(cmd->getVertexCount()>= 0 && cmd->getVertexCount() < VBO_SIZE, \"VBO for vertex is not big enough, please break the data down or use customized render command\");\n", "                CCASSERT(cmd->getIndexCount()>= 0 && cmd->getIndexCount() < INDEX_VBO_SIZE, \"VBO for index is not big enough, please break the data down or use customized render command\");\n", "                drawBatchedTriangles();\n", "\n", "                _queuedTotalIndexCount = _queuedTotalVertexCount = 0;\n", "#ifdef CC_USE_METAL\n", "                _queuedIndexCount = _queuedVertexCount = 0;\n", "                _triangleCommandBufferManager.prepareNextBuffer();\n", "                _vertexBuffer = _triangleCommandBufferManager.getVertexBuffer();\n", "                _indexBuffer = _triangleCommandBufferManager.getIndexBuffer();\n", "#endif\n", "            }\n", "            \n", "            // queue it\n", "            _queuedTriangleCommands.push_back(cmd);\n", "#ifdef CC_USE_METAL\n", "            _queuedIndexCount += cmd->getIndexCount();\n", "            _queuedVertexCount += cmd->getVertexCount();\n", "#endif\n", "            _queuedTotalVertexCount += cmd->getVertexCount();\n", "            _queuedTotalIndexCount += cmd->getIndexCount();\n", "\n", "        }\n", "            break;\n", "        case RenderCommand::Type::MESH_COMMAND:\n", "            flush2D();\n", "            drawMeshCommand(command);\n", "            break;\n", "        case RenderCommand::Type::GROUP_COMMAND:\n", "            processGroupCommand(static_cast<GroupCommand*>(command));\n", "            break;\n", "        case RenderCommand::Type::CUSTOM_COMMAND:\n", "            flush();\n", "            drawCustomCommand(command);\n", "            break;\n", "        case RenderCommand::Type::CALLBACK_COMMAND:\n", "            flush();\n", "           static_cast<CallbackCommand*>(command)->execute();\n", "            break;\n", "        case RenderCommand::Type::CAPTURE_SCREEN_COMMAND:\n", "            flush();\n", "            captureScreen(command);\n", "            break;\n", "        default:\n", "            assert(false);\n", "            break;\n", "    }\n", "}\n"], "Renderer::visitRenderQueue-RenderQueue&": ["void Renderer::visitRenderQueue(RenderQueue& queue)\n", "{\n", "    //\n", "    //Process Global-Z < 0 Objects\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_NEG));\n", "\n", "    //\n", "    //Process Opaque Object\n", "    //\n", "    pushStateBlock();\n", "    setDepthTest(true); //enable depth test in 3D queue by default\n", "    setDepthWrite(true);\n", "    setCullMode(backend::CullMode::BACK);\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::OPAQUE_3D));\n", "    \n", "    //\n", "    //Process 3D Transparent object\n", "    //\n", "    setDepthWrite(false);\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::TRANSPARENT_3D));\n", "    popStateBlock();\n", "\n", "    //\n", "    //Process Global-Z = 0 Queue\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_ZERO));\n", "        \n", "    //\n", "    //Process Global-Z > 0 Queue\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_POS));\n", "\n", "}\n"], "Renderer::setDepthTest-bool": ["void Renderer::setDepthTest(bool value)\n", "{\n", "    _depthStencilDescriptor.depthTestEnabled = value;\n", "    _renderPassDescriptor.depthTestEnabled = value;\n", "}\n"], "Renderer::drawBatchedTriangles": ["void Renderer::drawBatchedTriangles()\n", "{\n", "    if(_queuedTriangleCommands.empty())\n", "        return;\n", "    \n", "    /************** 1: Setup up vertices/indices *************/\n", "#ifdef CC_USE_METAL\n", "    unsigned int vertexBufferFillOffset = _queuedTotalVertexCount - _queuedVertexCount;\n", "    unsigned int indexBufferFillOffset = _queuedTotalIndexCount - _queuedIndexCount;\n", "#else\n", "    unsigned int vertexBufferFillOffset = 0;\n", "    unsigned int indexBufferFillOffset = 0;\n", "#endif\n", "\n", "    _triBatchesToDraw[0].offset = indexBufferFillOffset;\n", "    _triBatchesToDraw[0].indicesToDraw = 0;\n", "    _triBatchesToDraw[0].cmd = nullptr;\n", "    \n", "    int batchesTotal = 0;\n", "    int prevMaterialID = -1;\n", "    bool firstCommand = true;\n", "\n", "    _filledVertex = 0;\n", "    _filledIndex = 0;\n", "\n", "    for(const auto& cmd : _queuedTriangleCommands)\n", "    {\n", "        auto currentMaterialID = cmd->getMaterialID();\n", "        const bool batchable = !cmd->isSkipBatching();\n", "        \n", "        fillVerticesAndIndices(cmd, vertexBufferFillOffset);\n", "        \n", "        // in the same batch ?\n", "        if (batchable && (prevMaterialID == currentMaterialID || firstCommand))\n", "        {\n", "            CC_ASSERT((firstCommand || _triBatchesToDraw[batchesTotal].cmd->getMaterialID() == cmd->getMaterialID()) && \"argh... error in logic\");\n", "            _triBatchesToDraw[batchesTotal].indicesToDraw += cmd->getIndexCount();\n", "            _triBatchesToDraw[batchesTotal].cmd = cmd;\n", "        }\n", "        else\n", "        {\n", "            // is this the first one?\n", "            if (!firstCommand)\n", "            {\n", "                batchesTotal++;\n", "                _triBatchesToDraw[batchesTotal].offset =\n", "                    _triBatchesToDraw[batchesTotal-1].offset + _triBatchesToDraw[batchesTotal-1].indicesToDraw;\n", "            }\n", "            \n", "            _triBatchesToDraw[batchesTotal].cmd = cmd;\n", "            _triBatchesToDraw[batchesTotal].indicesToDraw = (int) cmd->getIndexCount();\n", "            \n", "            // is this a single batch ? Prevent creating a batch group then\n", "            if (!batchable)\n", "                currentMaterialID = -1;\n", "        }\n", "        \n", "        // capacity full ?\n", "        if (batchesTotal + 1 >= _triBatchesToDrawCapacity)\n", "        {\n", "            _triBatchesToDrawCapacity *= 1.4;\n", "            _triBatchesToDraw = (TriBatchToDraw*) realloc(_triBatchesToDraw, sizeof(_triBatchesToDraw[0]) * _triBatchesToDrawCapacity);\n", "        }\n", "        \n", "        prevMaterialID = currentMaterialID;\n", "        firstCommand = false;\n", "    }\n", "    batchesTotal++;\n", "#ifdef CC_USE_METAL\n", "    _vertexBuffer->updateSubData(_verts, vertexBufferFillOffset * sizeof(_verts[0]), _filledVertex * sizeof(_verts[0]));\n", "    _indexBuffer->updateSubData(_indices, indexBufferFillOffset * sizeof(_indices[0]), _filledIndex * sizeof(_indices[0]));\n", "#else\n", "    _vertexBuffer->updateData(_verts, _filledVertex * sizeof(_verts[0]));\n", "    _indexBuffer->updateData(_indices,  _filledIndex * sizeof(_indices[0]));\n", "#endif\n", "\n", "    /************** 2: Draw *************/\n", "    for (int i = 0; i < batchesTotal; ++i)\n", "    {\n", "        beginRenderPass(_triBatchesToDraw[i].cmd);\n", "        _commandBuffer->setVertexBuffer(_vertexBuffer);\n", "        _commandBuffer->setIndexBuffer(_indexBuffer);\n", "        auto& pipelineDescriptor = _triBatchesToDraw[i].cmd->getPipelineDescriptor();\n", "        _commandBuffer->setProgramState(pipelineDescriptor.programState);\n", "_commandBuffer->drawElements(backend::PrimitiveType::TRIANGLE,backend::IndexFormat::U_SHORT,_triBatchesToDraw[i].indicesToDraw,_triBatchesToDraw[i].offset * sizeof(_indices[0]));        _commandBuffer->endRenderPass();\n", "\n", "        _drawnBatches++;\n", "        _drawnVertices += _triBatchesToDraw[i].indicesToDraw;\n", "    }\n", "\n", "    /************** 3: Cleanup *************/\n", "    _queuedTriangleCommands.clear();\n", "\n", "#ifdef CC_USE_METAL\n", "    _queuedIndexCount = 0;\n", "    _queuedVertexCount = 0;\n", "#endif\n", "}\n"], "Texture2D::setAliasTexParameters": ["void Texture2D::setAliasTexParameters()\n", "{\n", "\n", "    if (! _antialiasEnabled)\n", "    {\n", "        return;\n", "    }\n", "\n", "    _antialiasEnabled = false;\n", "\n", "    backend::SamplerDescriptor descriptor(\n", "        backend::SamplerFilter::NEAREST, //magFilter\n", "        (_texture->hasMipmaps()) ? backend::SamplerFilter::NEAREST_MIPMAP_NEAREST : backend::SamplerFilter::NEAREST, //minFilter\n", "        backend::SamplerAddressMode::DONT_CARE, //sAddressMode\n", "        backend::SamplerAddressMode::DONT_CARE//tAddressMode\n", "    );\n", "    _texture->updateSamplerDescriptor(descriptor);\n", "}\n"], "Texture2D::setAntiAliasTexParameters": ["void Texture2D::setAntiAliasTexParameters()\n", "{\n", "\n", "    if ( _antialiasEnabled )\n", "    {\n", "        return;\n", "    }\n", "    _antialiasEnabled = true;\n", "\n", "    backend::SamplerDescriptor descriptor(\n", "        backend::SamplerFilter::LINEAR, //magFilter\n", "        (_texture->hasMipmaps()) ? backend::SamplerFilter::LINEAR_MIPMAP_NEAREST : backend::SamplerFilter::LINEAR, //minFilter\n", "        backend::SamplerAddressMode::DONT_CARE, //sAddressMode\n", "        backend::SamplerAddressMode::DONT_CARE //tAddressMode\n", "    );\n", "    _texture->updateSamplerDescriptor(descriptor);\n", "}\n"], "Texture2D::getStringForFormat-cons": ["const char* Texture2D::getStringForFormat() const\n", "{\n", "    switch (_pixelFormat) \n", "    {\n", "        case backend::PixelFormat::RGBA8888:\n", "            return  \"RGBA8888\";\n", "\n", "        case backend::PixelFormat::RGB888:\n", "            return  \"RGB888\";\n", "\n", "        case backend::PixelFormat::RGB565:\n", "            return  \"RGB565\";\n", "\n", "        case backend::PixelFormat::RGBA4444:\n", "            return  \"RGBA4444\";\n", "\n", "        case backend::PixelFormat::RGB5A1:\n", "            return  \"RGB5A1\";\n", "\n", "        case backend::PixelFormat::AI88:\n", "            return  \"AI88\";\n", "\n", "        case backend::PixelFormat::A8:\n", "            return  \"A8\";\n", "\n", "        case backend::PixelFormat::I8:\n", "            return  \"I8\";\n", "\n", "        case backend::PixelFormat::PVRTC4:\n", "            return  \"PVRTC4\";\n", "\n", "        case backend::PixelFormat::PVRTC2:\n", "            return  \"PVRTC2\";\n", "\n", "        case backend::PixelFormat::PVRTC2A:\n", "            return \"PVRTC2A\";\n", "        \n", "        case backend::PixelFormat::PVRTC4A:\n", "            return \"PVRTC4A\";\n", "            \n", "        case backend::PixelFormat::ETC:\n", "            return \"ETC\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT1:\n", "            return \"S3TC_DXT1\";\n", "            \n", "        case backend::PixelFormat::S3TC_DXT3:\n", "            return \"S3TC_DXT3\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT5:\n", "            return \"S3TC_DXT5\";\n", "            \n", "        case backend::PixelFormat::ATC_RGB:\n", "            return \"ATC_RGB\";\n", "\n", "        case backend::PixelFormat::ATC_EXPLICIT_ALPHA:\n", "            return \"ATC_EXPLICIT_ALPHA\";\n", "\n", "        case backend::PixelFormat::ATC_INTERPOLATED_ALPHA:\n", "            return \"ATC_INTERPOLATED_ALPHA\";\n", "        \n", "        case backend::PixelFormat::MTL_ABGR4:\n", "            return \"MTL_ABGR4\";\n", "        \n", "        case backend::PixelFormat::MTL_B5G6R5:\n", "            return \"MTL_RGB565\";\n", "        \n", "        case backend::PixelFormat::MTL_BGR5A1:\n", "            return \"MTL_BGR5A1\";\n", "            \n", "        default:\n", "            CCASSERT(false , \"unrecognized pixel format\");\n", "            CCLOG(\"stringForFormat: %ld, cannot give useful result\", (long)_pixelFormat);\n", "            break;\n", "    }\n", "\n", "\treturn  nullptr;\n", "}\n"], "TextureAtlas::initWithTexture-Texture2D*-ssize_t": ["bool TextureAtlas::initWithTexture(Texture2D *texture, ssize_t capacity)\n", "{\n", "    CCASSERT(capacity>=0, \"Capacity must be >= 0\");\n", "    \n", "//    CCASSERT(texture != nullptr, \"texture should not be null\");\n", "    _capacity = capacity;\n", "    _totalQuads = 0;\n", "\n", "    // retained in property\n", "    this->_texture = texture;\n", "    CC_SAFE_RETAIN(_texture);\n", "\n", "    // Re-initialization is not allowed\n", "    CCASSERT(_quads == nullptr && _indices == nullptr, \"_quads and _indices should be nullptr.\");\n", "\n", "    _quads = (V3F_C4B_T2F_Quad*)malloc( _capacity * sizeof(V3F_C4B_T2F_Quad) );\n", "    _indices = (uint16_t *)malloc( _capacity * 6 * sizeof(uint16_t) );\n", "    \n", "    if( ! ( _quads && _indices) && _capacity > 0) \n", "    {\n", "        //CCLOG(\"cocos2d: TextureAtlas: not enough memory\");\n", "        CC_SAFE_FREE(_quads);\n", "        CC_SAFE_FREE(_indices);\n", "\n", "        // release texture, should set it to null, because the destruction will\n", "        // release it too. see cocos2d-x issue #484\n", "        CC_SAFE_RELEASE_NULL(_texture);\n", "        return false;\n", "    }\n", "\n", "    memset( _quads, 0, _capacity * sizeof(V3F_C4B_T2F_Quad) );\n", "    memset( _indices, 0, _capacity * 6 * sizeof(uint16_t) );\n", "    \n", "    this->setupIndices();\n", "\n", "    _dirty = true;\n", "\n", "    return true;\n", "}\n"], "TextureCache::loadImage": ["void TextureCache::loadImage()\n", "{\n", "    AsyncStruct *asyncStruct = nullptr;\n", "    while (!_needQuit)\n", "    {\n", "        std::unique_lock<std::mutex> ul(_requestMutex);\n", "        // pop an AsyncStruct from request queue\n", "        if (_requestQueue.empty())\n", "        {\n", "            asyncStruct = nullptr;\n", "        }\n", "        else\n", "        {\n", "            asyncStruct = _requestQueue.front();\n", "            _requestQueue.pop_front();\n", "        }\n", "\n", "        if (nullptr == asyncStruct) {\n", "            if (_needQuit) {\n", "                break;\n", "            }\n", "            _sleepCondition.wait(ul);\n", "            continue;\n", "        }\n", "        ul.unlock();\n", "\n", "        // load image\n", "        asyncStruct->loadSuccess = asyncStruct->image.initWithImageFileThreadSafe(asyncStruct->filename);\n", "\n", "        // ETC1 ALPHA supports.\n", "        if (asyncStruct->loadSuccess && asyncStruct->image.getFileType() == Image::Format::ETC && !s_etc1AlphaFileSuffix.empty())\n", "        { // check whether alpha texture exists & load it\n", "            auto alphaFile = asyncStruct->filename + s_etc1AlphaFileSuffix;\n", "            if (FileUtils::getInstance()->isFileExist(alphaFile))\n", "                asyncStruct->imageAlpha.initWithImageFileThreadSafe(alphaFile);\n", "        }\n", "        // push the asyncStruct to response queue\n", "        _responseMutex.lock();\n", "        _responseQueue.push_back(asyncStruct);\n", "        _responseMutex.unlock();\n", "    }\n", "}\n"]}
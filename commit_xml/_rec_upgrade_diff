{"Sprite::setTextureRect-Rect&-bool-Size&": ["void Sprite::setTextureRect(const Rect& rect, bool rotated, const Size& untrimmedSize)\n", "{\n", "    _rectRotated = rotated;\n", "\n", "    Node::setContentSize(untrimmedSize);\n", "    _originalContentSize = untrimmedSize;\n", "\n", "    setVertexRect(rect);\n", "    updateStretchFactor();\n", "    updatePoly();\n", "}\n"], "Sprite::setTextureCoords-Rect&": ["void Sprite::setTextureCoords(const Rect& rectInPoints)\n", "{\n", "    setTextureCoords(rectInPoints, &_quad);\n", "}\n"], "Sprite::setFlippedX-bool": ["void Sprite::setFlippedX(bool flippedX)\n", "{\n", "    if (_flippedX != flippedX)\n", "    {\n", "        _flippedX = flippedX;\n", "        flipX();\n", "    }\n", "}\n"], "Sprite::setFlippedY-bool": ["void Sprite::setFlippedY(bool flippedY)\n", "{\n", "#ifdef CC_USE_METAL\n", "    if(_texture->isRenderTarget())\n", "        flippedY = !flippedY;\n", "#endif\n", "    if (_flippedY != flippedY)\n", "    {\n", "        _flippedY = flippedY;\n", "        flipY();\n", "    }\n", "}\n"], "Sprite::setSpriteFrame-SpriteFrame*": ["void Sprite::setSpriteFrame(SpriteFrame *spriteFrame)\n", "{\n", "    // retain the sprite frame\n", "    // do not removed by SpriteFrameCache::removeUnusedSpriteFrames\n", "    if (_spriteFrame != spriteFrame)\n", "    {\n", "        CC_SAFE_RELEASE(_spriteFrame);\n", "        _spriteFrame = spriteFrame;\n", "        spriteFrame->retain();\n", "    }\n", "    _unflippedOffsetPositionFromCenter = spriteFrame->getOffset();\n", "\n", "    Texture2D *texture = spriteFrame->getTexture();\n", "    // update texture before updating texture rect\n", "    if (texture != _texture)\n", "        setTexture(texture);\n", "\n", "    // update rect\n", "    _rectRotated = spriteFrame->isRotated();\n", "    setTextureRect(spriteFrame->getRect(), _rectRotated, spriteFrame->getOriginalSize());\n", "\n", "    if (spriteFrame->hasPolygonInfo())\n", "    {\n", "        _polyInfo = spriteFrame->getPolygonInfo();\n", "        _renderMode = RenderMode::POLYGON;\n", "        if (_flippedX) flipX();\n", "        if (_flippedY) flipY();\n", "        updateColor();\n", "    }\n", "    if (spriteFrame->hasAnchorPoint())\n", "        setAnchorPoint(spriteFrame->getAnchorPoint());\n", "    if (spriteFrame->hasCenterRect())\n", "        setCenterRect(spriteFrame->getCenterRect());\n", "}\n"], "Renderer::processRenderCommand-RenderCommand*": ["void Renderer::processRenderCommand(RenderCommand* command)\n", "{\n", "    auto commandType = command->getType();\n", "    switch(commandType)\n", "    {\n", "        case RenderCommand::Type::TRIANGLES_COMMAND:\n", "        {\n", "            // flush other queues\n", "            flush3D();\n", "            \n", "            auto cmd = static_cast<TrianglesCommand*>(command);\n", "            \n", "            // flush own queue when buffer is full\n", "            if(_queuedTotalVertexCount + cmd->getVertexCount() > VBO_SIZE || _queuedTotalIndexCount + cmd->getIndexCount() > INDEX_VBO_SIZE)\n", "            {\n", "                CCASSERT(cmd->getVertexCount()>= 0 && cmd->getVertexCount() < VBO_SIZE, \"VBO for vertex is not big enough, please break the data down or use customized render command\");\n", "                CCASSERT(cmd->getIndexCount()>= 0 && cmd->getIndexCount() < INDEX_VBO_SIZE, \"VBO for index is not big enough, please break the data down or use customized render command\");\n", "                drawBatchedTriangles();\n", "\n", "                _queuedTotalIndexCount = _queuedTotalVertexCount = 0;\n", "#ifdef CC_USE_METAL\n", "                _queuedIndexCount = _queuedVertexCount = 0;\n", "                _triangleCommandBufferManager.prepareNextBuffer();\n", "                _vertexBuffer = _triangleCommandBufferManager.getVertexBuffer();\n", "                _indexBuffer = _triangleCommandBufferManager.getIndexBuffer();\n", "#endif\n", "            }\n", "            \n", "            // queue it\n", "            _queuedTriangleCommands.push_back(cmd);\n", "#ifdef CC_USE_METAL\n", "            _queuedIndexCount += cmd->getIndexCount();\n", "            _queuedVertexCount += cmd->getVertexCount();\n", "#endif\n", "            _queuedTotalVertexCount += cmd->getVertexCount();\n", "            _queuedTotalIndexCount += cmd->getIndexCount();\n", "\n", "        }\n", "            break;\n", "        case RenderCommand::Type::MESH_COMMAND:\n", "            flush2D();\n", "            drawMeshCommand(command);\n", "            break;\n", "        case RenderCommand::Type::GROUP_COMMAND:\n", "            processGroupCommand(static_cast<GroupCommand*>(command));\n", "            break;\n", "        case RenderCommand::Type::CUSTOM_COMMAND:\n", "            flush();\n", "            drawCustomCommand(command);\n", "            break;\n", "        case RenderCommand::Type::CALLBACK_COMMAND:\n", "            flush();\n", "           static_cast<CallbackCommand*>(command)->execute();\n", "            break;\n", "        case RenderCommand::Type::CAPTURE_SCREEN_COMMAND:\n", "            flush();\n", "            captureScreen(command);\n", "            break;\n", "        default:\n", "            assert(false);\n", "            break;\n", "    }\n", "}\n"], "Renderer::visitRenderQueue-RenderQueue&": ["void Renderer::visitRenderQueue(RenderQueue& queue)\n", "{\n", "    //\n", "    //Process Global-Z < 0 Objects\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_NEG));\n", "\n", "    //\n", "    //Process Opaque Object\n", "    //\n", "    pushStateBlock();\n", "    setDepthTest(true); //enable depth test in 3D queue by default\n", "    setDepthWrite(true);\n", "    setCullMode(backend::CullMode::BACK);\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::OPAQUE_3D));\n", "    \n", "    //\n", "    //Process 3D Transparent object\n", "    //\n", "    setDepthWrite(false);\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::TRANSPARENT_3D));\n", "    popStateBlock();\n", "\n", "    //\n", "    //Process Global-Z = 0 Queue\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_ZERO));\n", "        \n", "    //\n", "    //Process Global-Z > 0 Queue\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_POS));\n", "\n", "}\n"], "Renderer::setDepthTest-bool": ["void Renderer::setDepthTest(bool value)\n", "{\n", "    _depthStencilDescriptor.depthTestEnabled = value;\n", "    _renderPassDescriptor.depthTestEnabled = value;\n", "}\n"], "Renderer::drawBatchedTriangles": ["void Renderer::drawBatchedTriangles()\n", "{\n", "    if(_queuedTriangleCommands.empty())\n", "        return;\n", "    \n", "    /************** 1: Setup up vertices/indices *************/\n", "#ifdef CC_USE_METAL\n", "    unsigned int vertexBufferFillOffset = _queuedTotalVertexCount - _queuedVertexCount;\n", "    unsigned int indexBufferFillOffset = _queuedTotalIndexCount - _queuedIndexCount;\n", "#else\n", "    unsigned int vertexBufferFillOffset = 0;\n", "    unsigned int indexBufferFillOffset = 0;\n", "#endif\n", "\n", "    _triBatchesToDraw[0].offset = indexBufferFillOffset;\n", "    _triBatchesToDraw[0].indicesToDraw = 0;\n", "    _triBatchesToDraw[0].cmd = nullptr;\n", "    \n", "    int batchesTotal = 0;\n", "    int prevMaterialID = -1;\n", "    bool firstCommand = true;\n", "\n", "    _filledVertex = 0;\n", "    _filledIndex = 0;\n", "\n", "    for(const auto& cmd : _queuedTriangleCommands)\n", "    {\n", "        auto currentMaterialID = cmd->getMaterialID();\n", "        const bool batchable = !cmd->isSkipBatching();\n", "        \n", "        fillVerticesAndIndices(cmd, vertexBufferFillOffset);\n", "        \n", "        // in the same batch ?\n", "        if (batchable && (prevMaterialID == currentMaterialID || firstCommand))\n", "        {\n", "            CC_ASSERT((firstCommand || _triBatchesToDraw[batchesTotal].cmd->getMaterialID() == cmd->getMaterialID()) && \"argh... error in logic\");\n", "            _triBatchesToDraw[batchesTotal].indicesToDraw += cmd->getIndexCount();\n", "            _triBatchesToDraw[batchesTotal].cmd = cmd;\n", "        }\n", "        else\n", "        {\n", "            // is this the first one?\n", "            if (!firstCommand)\n", "            {\n", "                batchesTotal++;\n", "                _triBatchesToDraw[batchesTotal].offset =\n", "                    _triBatchesToDraw[batchesTotal-1].offset + _triBatchesToDraw[batchesTotal-1].indicesToDraw;\n", "            }\n", "            \n", "            _triBatchesToDraw[batchesTotal].cmd = cmd;\n", "            _triBatchesToDraw[batchesTotal].indicesToDraw = (int) cmd->getIndexCount();\n", "            \n", "            // is this a single batch ? Prevent creating a batch group then\n", "            if (!batchable)\n", "                currentMaterialID = -1;\n", "        }\n", "        \n", "        // capacity full ?\n", "        if (batchesTotal + 1 >= _triBatchesToDrawCapacity)\n", "        {\n", "            _triBatchesToDrawCapacity *= 1.4;\n", "            _triBatchesToDraw = (TriBatchToDraw*) realloc(_triBatchesToDraw, sizeof(_triBatchesToDraw[0]) * _triBatchesToDrawCapacity);\n", "        }\n", "        \n", "        prevMaterialID = currentMaterialID;\n", "        firstCommand = false;\n", "    }\n", "    batchesTotal++;\n", "#ifdef CC_USE_METAL\n", "    _vertexBuffer->updateSubData(_verts, vertexBufferFillOffset * sizeof(_verts[0]), _filledVertex * sizeof(_verts[0]));\n", "    _indexBuffer->updateSubData(_indices, indexBufferFillOffset * sizeof(_indices[0]), _filledIndex * sizeof(_indices[0]));\n", "#else\n", "    _vertexBuffer->updateData(_verts, _filledVertex * sizeof(_verts[0]));\n", "    _indexBuffer->updateData(_indices,  _filledIndex * sizeof(_indices[0]));\n", "#endif\n", "\n", "    /************** 2: Draw *************/\n", "    for (int i = 0; i < batchesTotal; ++i)\n", "    {\n", "        beginRenderPass(_triBatchesToDraw[i].cmd);\n", "        _commandBuffer->setVertexBuffer(_vertexBuffer);\n", "        _commandBuffer->setIndexBuffer(_indexBuffer);\n", "        auto& pipelineDescriptor = _triBatchesToDraw[i].cmd->getPipelineDescriptor();\n", "        _commandBuffer->setProgramState(pipelineDescriptor.programState);\n", "_commandBuffer->drawElements(backend::PrimitiveType::TRIANGLE,backend::IndexFormat::U_SHORT,_triBatchesToDraw[i].indicesToDraw,_triBatchesToDraw[i].offset * sizeof(_indices[0]));        _commandBuffer->endRenderPass();\n", "\n", "        _drawnBatches++;\n", "        _drawnVertices += _triBatchesToDraw[i].indicesToDraw;\n", "    }\n", "\n", "    /************** 3: Cleanup *************/\n", "    _queuedTriangleCommands.clear();\n", "\n", "#ifdef CC_USE_METAL\n", "    _queuedIndexCount = 0;\n", "    _queuedVertexCount = 0;\n", "#endif\n", "}\n"], "Texture2D::setAliasTexParameters": ["void Texture2D::setAliasTexParameters()\n", "{\n", "\n", "    if (! _antialiasEnabled)\n", "    {\n", "        return;\n", "    }\n", "\n", "    _antialiasEnabled = false;\n", "\n", "    backend::SamplerDescriptor descriptor(\n", "        backend::SamplerFilter::NEAREST, //magFilter\n", "        (_texture->hasMipmaps()) ? backend::SamplerFilter::NEAREST_MIPMAP_NEAREST : backend::SamplerFilter::NEAREST, //minFilter\n", "        backend::SamplerAddressMode::DONT_CARE, //sAddressMode\n", "        backend::SamplerAddressMode::DONT_CARE//tAddressMode\n", "    );\n", "    _texture->updateSamplerDescriptor(descriptor);\n", "}\n"], "Texture2D::setAntiAliasTexParameters": ["void Texture2D::setAntiAliasTexParameters()\n", "{\n", "\n", "    if ( _antialiasEnabled )\n", "    {\n", "        return;\n", "    }\n", "    _antialiasEnabled = true;\n", "\n", "    backend::SamplerDescriptor descriptor(\n", "        backend::SamplerFilter::LINEAR, //magFilter\n", "        (_texture->hasMipmaps()) ? backend::SamplerFilter::LINEAR_MIPMAP_NEAREST : backend::SamplerFilter::LINEAR, //minFilter\n", "        backend::SamplerAddressMode::DONT_CARE, //sAddressMode\n", "        backend::SamplerAddressMode::DONT_CARE //tAddressMode\n", "    );\n", "    _texture->updateSamplerDescriptor(descriptor);\n", "}\n"], "Texture2D::getStringForFormat-cons": ["const char* Texture2D::getStringForFormat() const\n", "{\n", "    switch (_pixelFormat) \n", "    {\n", "        case backend::PixelFormat::RGBA8888:\n", "            return  \"RGBA8888\";\n", "\n", "        case backend::PixelFormat::RGB888:\n", "            return  \"RGB888\";\n", "\n", "        case backend::PixelFormat::RGB565:\n", "            return  \"RGB565\";\n", "\n", "        case backend::PixelFormat::RGBA4444:\n", "            return  \"RGBA4444\";\n", "\n", "        case backend::PixelFormat::RGB5A1:\n", "            return  \"RGB5A1\";\n", "\n", "        case backend::PixelFormat::AI88:\n", "            return  \"AI88\";\n", "\n", "        case backend::PixelFormat::A8:\n", "            return  \"A8\";\n", "\n", "        case backend::PixelFormat::I8:\n", "            return  \"I8\";\n", "\n", "        case backend::PixelFormat::PVRTC4:\n", "            return  \"PVRTC4\";\n", "\n", "        case backend::PixelFormat::PVRTC2:\n", "            return  \"PVRTC2\";\n", "\n", "        case backend::PixelFormat::PVRTC2A:\n", "            return \"PVRTC2A\";\n", "        \n", "        case backend::PixelFormat::PVRTC4A:\n", "            return \"PVRTC4A\";\n", "            \n", "        case backend::PixelFormat::ETC:\n", "            return \"ETC\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT1:\n", "            return \"S3TC_DXT1\";\n", "            \n", "        case backend::PixelFormat::S3TC_DXT3:\n", "            return \"S3TC_DXT3\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT5:\n", "            return \"S3TC_DXT5\";\n", "            \n", "        case backend::PixelFormat::ATC_RGB:\n", "            return \"ATC_RGB\";\n", "\n", "        case backend::PixelFormat::ATC_EXPLICIT_ALPHA:\n", "            return \"ATC_EXPLICIT_ALPHA\";\n", "\n", "        case backend::PixelFormat::ATC_INTERPOLATED_ALPHA:\n", "            return \"ATC_INTERPOLATED_ALPHA\";\n", "        \n", "        case backend::PixelFormat::MTL_ABGR4:\n", "            return \"MTL_ABGR4\";\n", "        \n", "        case backend::PixelFormat::MTL_B5G6R5:\n", "            return \"MTL_RGB565\";\n", "        \n", "        case backend::PixelFormat::MTL_BGR5A1:\n", "            return \"MTL_BGR5A1\";\n", "            \n", "        default:\n", "            CCASSERT(false , \"unrecognized pixel format\");\n", "            CCLOG(\"stringForFormat: %ld, cannot give useful result\", (long)_pixelFormat);\n", "            break;\n", "    }\n", "\n", "\treturn  nullptr;\n", "}\n"], "TextureAtlas::initWithTexture-Texture2D*-ssize_t": ["bool TextureAtlas::initWithTexture(Texture2D *texture, ssize_t capacity)\n", "{\n", "    CCASSERT(capacity>=0, \"Capacity must be >= 0\");\n", "    \n", "//    CCASSERT(texture != nullptr, \"texture should not be null\");\n", "    _capacity = capacity;\n", "    _totalQuads = 0;\n", "\n", "    // retained in property\n", "    this->_texture = texture;\n", "    CC_SAFE_RETAIN(_texture);\n", "\n", "    // Re-initialization is not allowed\n", "    CCASSERT(_quads == nullptr && _indices == nullptr, \"_quads and _indices should be nullptr.\");\n", "\n", "    _quads = (V3F_C4B_T2F_Quad*)malloc( _capacity * sizeof(V3F_C4B_T2F_Quad) );\n", "    _indices = (uint16_t *)malloc( _capacity * 6 * sizeof(uint16_t) );\n", "    \n", "    if( ! ( _quads && _indices) && _capacity > 0) \n", "    {\n", "        //CCLOG(\"cocos2d: TextureAtlas: not enough memory\");\n", "        CC_SAFE_FREE(_quads);\n", "        CC_SAFE_FREE(_indices);\n", "\n", "        // release texture, should set it to null, because the destruction will\n", "        // release it too. see cocos2d-x issue #484\n", "        CC_SAFE_RELEASE_NULL(_texture);\n", "        return false;\n", "    }\n", "\n", "    memset( _quads, 0, _capacity * sizeof(V3F_C4B_T2F_Quad) );\n", "    memset( _indices, 0, _capacity * 6 * sizeof(uint16_t) );\n", "    \n", "    this->setupIndices();\n", "\n", "    _dirty = true;\n", "\n", "    return true;\n", "}\n"], "TextureCache::loadImage": ["void TextureCache::loadImage()\n", "{\n", "    AsyncStruct *asyncStruct = nullptr;\n", "    while (!_needQuit)\n", "    {\n", "        std::unique_lock<std::mutex> ul(_requestMutex);\n", "        // pop an AsyncStruct from request queue\n", "        if (_requestQueue.empty())\n", "        {\n", "            asyncStruct = nullptr;\n", "        }\n", "        else\n", "        {\n", "            asyncStruct = _requestQueue.front();\n", "            _requestQueue.pop_front();\n", "        }\n", "\n", "        if (nullptr == asyncStruct) {\n", "            if (_needQuit) {\n", "                break;\n", "            }\n", "            _sleepCondition.wait(ul);\n", "            continue;\n", "        }\n", "        ul.unlock();\n", "\n", "        // load image\n", "        asyncStruct->loadSuccess = asyncStruct->image.initWithImageFileThreadSafe(asyncStruct->filename);\n", "\n", "        // ETC1 ALPHA supports.\n", "        if (asyncStruct->loadSuccess && asyncStruct->image.getFileType() == Image::Format::ETC && !s_etc1AlphaFileSuffix.empty())\n", "        { // check whether alpha texture exists & load it\n", "            auto alphaFile = asyncStruct->filename + s_etc1AlphaFileSuffix;\n", "            if (FileUtils::getInstance()->isFileExist(alphaFile))\n", "                asyncStruct->imageAlpha.initWithImageFileThreadSafe(alphaFile);\n", "        }\n", "        // push the asyncStruct to response queue\n", "        _responseMutex.lock();\n", "        _responseQueue.push_back(asyncStruct);\n", "        _responseMutex.unlock();\n", "    }\n", "}\n"], "Texture2D::initWithString-char*-FontDefinition&": ["bool Texture2D::initWithString(const char *_text, const FontDefinition& textDefinition)\n", "{\n", "    \n", "    if(!_text || 0 == strlen(_text))\n", "    {\n", "        return false;\n", "    }\n", "    \n", "    std::string text = _text;\n", "    \n", "    \n", " #if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n", "    // std::vector <unsigned short> utf16result;\n", "    // utf8::unchecked::utf8to16((char*)text, (char*)text + strlen(text), back_inserter(utf16result));\n", "    // unsigned short utf16string[] = utf16result.;\n", "    // std::vector<unsigned char> utf8result;\n", "    // utf8::unchecked::utf16to8(utf16result.begin(), utf16result.end(), back_inserter(utf8result));\n", "    /* char* pMem = new char [strlen(text) +6];\n", "     memcpy(pMem, text, strlen(text));\n", "     pMem[strlen(text)] = 0;\n", "     //CCLOG(\"beginrender:%s\",text);*/\n", "    int errIndex = 0;\n", "    \n", "    if(s_ANDROID_VER==21||s_ANDROID_VER==22)\n", "    {\n", "        if( !correctUtfBytes( text.c_str(), errIndex ) )// \u5148\u6682\u65f6\u622a\u65ad\u4e0d\u8fd4\u56de\uff0c\u627e\u5230\u597d\u65b9\u5f0f\u518d\u5904\u7406\n", "        {\n", "            int nIdx=errIndex-1;\n", "            if(nIdx>0 && nIdx <text.length())\n", "            {\n", "                text.erase(text.begin()+nIdx,text.end());\n", "            \n", "            }\n", "            else\n", "                return false;\n", "        \n", "        CCLOG(\"initWithString:%s,%d\",text.c_str(), errIndex);\n", "        \n", "            }\n", "    }\n", " #endif\n", "    \n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "    // cache the texture data\n", "    VolatileTextureMgr::addStringTexture(this, text.c_str(), textDefinition);\n", "#endif\n", "    \n", "    TextHAlignment alignment = textDefinition._alignment;\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n", "    //////////////////////////////////////////////////\n", "    // \u963f\u62c9\u4f2f\u8bed\u8a00\u81ea\u52a8\u5de6\u53f3\u5bf9\u9f50\n", "    if (textDefinition._dimensions.width > 0 && isTextFlip())\n", "    {\n", "        //CCLOG(\"initWithString(%0.2f x %0.2f) - %s\", textDefinition._dimensions.width,\n", "        //      textDefinition._dimensions.height, text);\n", "        \n", "//        if (alignment == TextHAlignment::LEFT) {\n", "//            alignment = TextHAlignment::RIGHT;\n", "//        }\n", "//        else if (alignment == TextHAlignment::RIGHT) {\n", "//            alignment = TextHAlignment::LEFT;\n", "//        }\n", "    }\n", "#endif\n", "    \n", "    bool ret = false;\n", "    Device::TextAlign align;\n", "    \n", "    if (TextVAlignment::TOP == textDefinition._vertAlignment)\n", "    {\n", "        align = (TextHAlignment::CENTER == textDefinition._alignment) ? Device::TextAlign::TOP\n", "        : (TextHAlignment::LEFT == textDefinition._alignment) ? Device::TextAlign::TOP_LEFT : Device::TextAlign::TOP_RIGHT;\n", "    }\n", "    else if (TextVAlignment::CENTER == textDefinition._vertAlignment)\n", "    {\n", "        align = (TextHAlignment::CENTER == textDefinition._alignment) ? Device::TextAlign::CENTER\n", "        : (TextHAlignment::LEFT == textDefinition._alignment) ? Device::TextAlign::LEFT : Device::TextAlign::RIGHT;\n", "    }\n", "    else if (TextVAlignment::BOTTOM == textDefinition._vertAlignment)\n", "    {\n", "        align = (TextHAlignment::CENTER == textDefinition._alignment) ? Device::TextAlign::BOTTOM\n", "        : (TextHAlignment::LEFT == textDefinition._alignment) ? Device::TextAlign::BOTTOM_LEFT : Device::TextAlign::BOTTOM_RIGHT;\n", "    }\n", "    else\n", "    {\n", "        CCASSERT(false, \"Not supported alignment format!\");\n", "        return false;\n", "    }\n", "    \n", "    \n", "#if (CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID) && (CC_TARGET_PLATFORM != CC_PLATFORM_IOS)\n", "    CCASSERT(textDefinition._stroke._strokeEnabled == false, \"Currently stroke only supported on iOS and Android!\");\n", "#endif\n", "\n", "    PixelFormat      pixelFormat = PixelFormat::RGBA8888;\n", "    unsigned char* outTempData = nullptr;\n", "    ssize_t outTempDataLen = 0;\n", "\n", "    int imageWidth;\n", "    int imageHeight;\n", "    auto textDef = textDefinition;\n", "    auto contentScaleFactor = CC_CONTENT_SCALE_FACTOR();\n", "    textDef._fontSize *= contentScaleFactor;\n", "    textDef._dimensions.width *= contentScaleFactor;\n", "    textDef._dimensions.height *= contentScaleFactor;\n", "    textDef._stroke._strokeSize *= contentScaleFactor;\n", "    textDef._shadow._shadowEnabled = false;\n", "    // textDef._fontFillColor = Color3B::RED;\n", "    \n", "    bool hasPremultipliedAlpha;\n", "    Data outData = Device::getTextureDataForText(text.c_str(), textDef, align, imageWidth, imageHeight, hasPremultipliedAlpha);\n", "    if(outData.isNull())\n", "    {\n", "        CCLOG(\"create ttf error:%s\" ,text.c_str());\n", "        return false;\n", "    }\n", "\n", "    Size  imageSize = Size((float)imageWidth, (float)imageHeight);\n", "      pixelFormat = convertDataToFormat(outData.getBytes(), imageWidth*imageHeight*4, PixelFormat::RGBA8888, pixelFormat, &outTempData, &outTempDataLen);\n", "    \n", "    \n", "    if( ms_isOnPause )\n", "    {\n", "        CCLOGCRITICAL(\"zym onpause cache initWithString:%s, [%p]\", text.c_str(), this );\n", "        m_cacheData = new CacheBuffer;\n", "        m_cacheData->nType = kString;\n", "        m_cacheData->strContent = text;\n", "        m_cacheData->textDefinitiont = textDefinition;\n", "        \n", "        _contentSize = Size((float)imageWidth, (float)imageHeight);\n", "        _pixelsWide = imageWidth;\n", "        _pixelsHigh = imageHeight;\n", "        _pixelFormat = pixelFormat;\n", "        \n", "        _hasPremultipliedAlpha = hasPremultipliedAlpha;\n", "        \n", "        if (outTempData != nullptr && outTempData != outData.getBytes())\n", "        {\n", "            free(outTempData);\n", "        }\n", "        TextureCache::getInstance()->AddCachGLData(this, EGLDataType::EGLData_Texture2D, EGLOper::EGLOper_Create );\n", "        return true;\n", "    }\n", "\n", "    \n", "    ret = initWithData(outTempData, outTempDataLen, pixelFormat, imageWidth, imageHeight, imageSize);\n", "\n", "    if (outTempData != nullptr && outTempData != outData.getBytes())\n", "    {\n", "        free(outTempData);\n", "    }\n", "    _hasPremultipliedAlpha = hasPremultipliedAlpha;\n", "\n", "    return ret;\n", "}\n"], "Texture2D::getStringForFormat": ["const char* Texture2D::getStringForFormat() const\n", "{\n", "    switch (_pixelFormat) \n", "    {\n", "        case backend::PixelFormat::RGBA8888:\n", "            return  \"RGBA8888\";\n", "\n", "        case backend::PixelFormat::RGB888:\n", "            return  \"RGB888\";\n", "\n", "        case backend::PixelFormat::RGB565:\n", "            return  \"RGB565\";\n", "\n", "        case backend::PixelFormat::RGBA4444:\n", "            return  \"RGBA4444\";\n", "\n", "        case backend::PixelFormat::RGB5A1:\n", "            return  \"RGB5A1\";\n", "\n", "        case backend::PixelFormat::AI88:\n", "            return  \"AI88\";\n", "\n", "        case backend::PixelFormat::A8:\n", "            return  \"A8\";\n", "\n", "        case backend::PixelFormat::I8:\n", "            return  \"I8\";\n", "\n", "        case backend::PixelFormat::PVRTC4:\n", "            return  \"PVRTC4\";\n", "\n", "        case backend::PixelFormat::PVRTC2:\n", "            return  \"PVRTC2\";\n", "\n", "        case backend::PixelFormat::PVRTC2A:\n", "            return \"PVRTC2A\";\n", "        \n", "        case backend::PixelFormat::PVRTC4A:\n", "            return \"PVRTC4A\";\n", "            \n", "        case backend::PixelFormat::ETC:\n", "            return \"ETC\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT1:\n", "            return \"S3TC_DXT1\";\n", "            \n", "        case backend::PixelFormat::S3TC_DXT3:\n", "            return \"S3TC_DXT3\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT5:\n", "            return \"S3TC_DXT5\";\n", "            \n", "        case backend::PixelFormat::ATC_RGB:\n", "            return \"ATC_RGB\";\n", "\n", "        case backend::PixelFormat::ATC_EXPLICIT_ALPHA:\n", "            return \"ATC_EXPLICIT_ALPHA\";\n", "\n", "        case backend::PixelFormat::ATC_INTERPOLATED_ALPHA:\n", "            return \"ATC_INTERPOLATED_ALPHA\";\n", "        \n", "        case backend::PixelFormat::MTL_ABGR4:\n", "            return \"MTL_ABGR4\";\n", "        \n", "        case backend::PixelFormat::MTL_B5G6R5:\n", "            return \"MTL_RGB565\";\n", "        \n", "        case backend::PixelFormat::MTL_BGR5A1:\n", "            return \"MTL_BGR5A1\";\n", "            \n", "        default:\n", "            CCASSERT(false , \"unrecognized pixel format\");\n", "            CCLOG(\"stringForFormat: %ld, cannot give useful result\", (long)_pixelFormat);\n", "            break;\n", "    }\n", "\n", "    return  nullptr;\n", "}\n"], "CCTexture2D.h_header": ["\n", "#include <string>\n", "#include <map>\n", "#include <unordered_map>\n", "\n", "#include \"base/CCRef.h\"\n", "#include \"math/CCGeometry.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "#define CC_SAMLL_TEXTURE_CNT 38\n", "#define CC_SMALL_GENERAL_TEXTURE_CNT 3\n", "\n", "class Image;\n", "class NinePatchInfo;\n", "class SpriteFrame;\n", "typedef struct _MipmapInfo MipmapInfo;\n", "\n", "namespace ui\n", "{\n", "    class Scale9Sprite;\n", "}\n", "\n", "namespace backend {\n", "    class Texture2DBackend;\n", "    class TextureBackend;\n", "    class ProgramState;\n", "}\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "//CONSTANTS:\n", "\n", "class GLProgram;\n", "// Added by ChenFei 2014-12-16 V3.2 support\n", "class TextureCache;\n", "//CLASS INTERFACES:\n", "\n", "/** \n", "* @brief Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data.\n", "* The created Texture2D object will always have power-of-two dimensions.\n", "* Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. \"contentSize\" != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0).\n", "* Be aware that the content of the generated textures will be upside-down!\n", "\n", " */\n", "/*xy\n", " \u4e4b\u524d\u7684\u8d44\u6e90\u91ca\u653e\u89c4\u5219\uff1a\u4e00\u5f20\u8d34\u56fe\u6ca1\u88ab\u4f7f\u7528\u65f6\uff0c\u4f1a\u653e\u5728\u7f13\u5b58\uff0c\u76f4\u81f3removeUnusedTextures \u8c03\u7528\u624d\u5220\u9664\n", " \u65b0\u8d44\u6e90\u91ca\u653e\u89c4\u5219\uff1a\u6539\u4e3a\u4e00\u5f20\u8d34\u56fe\u6ca1\u88ab\u5f15\u7528\u65f6\uff0c\u8fc7N\u79d2\u540e\u81ea\u52a8\u5220\u9664\n", " \u65b9\u6cd5\uff1aTexture2D->release()\u88ab\u8c03\u7528\u65f6\u6253\u4e0a\u65f6\u95f4\u6233\uff0c\u6ca1\u9694\u56fa\u5b9a\u79d2\u68c0\u6d4b\u4e00\u6b21\uff0c\u540c\u65f6\u6ee1\u8db3\u6ca1\u88ab\u5f15\u7528\u5e76\u4e14\u65f6\u95f4\u6233\u65f6\u5dee\u5927\u4e8eN\u65f6\u5220\u9664\n", " */\n"], "CCTexture2D.cpp_cpp": ["\n", "\n", "/*\n", "* Support for RGBA_4_4_4_4 and RGBA_5_5_5_1 was copied from:\n", "* https://devforums.apple.com/message/37855#37855 by a1studmuffin\n", "*/\n", "\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"platform/CCImage.h\"\n", "#include \"platform/CCGL.h\"\n", "#include \"platform/CCImage.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"platform/CCDevice.h\"\n", "#include \"base/ccConfig.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgramCache.h\"\n", "#include \"base/CCNinePatchImageParser.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/CCTextureUtils.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"deprecated/CCString.h\"\n", "#include \"CCFileUtils.h\"\n", "\n", "//#include \"base/unchecked.h\"\n", "//#include \"vector\"\n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "    #include \"renderer/CCTextureCache.h\"\n", "#endif\n", "\n", "extern bool isTextFlip();\n", "\n", "NS_CC_BEGIN\n"], "CCCustomCommand.cpp_cpp": ["#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"renderer/backend/Buffer.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"base/ccUtils.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCCustomCommand.h_header": ["\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"base/IFFunctional.h\"\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "namespace backend\n", "{\n", "    class Buffer;\n", "}\n", "\n", "/**\n", "Custom command is used to draw all things except triangle commands. You can use\n", "this command to draw things, just provide vertex/index data and set corret flags.\n", "*/\n"], "CCGroupCommand.cpp_cpp": ["\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"base/CCDirector.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCGroupCommand.h_header": ["\n", "#include <vector>\n", "#include <unordered_map>\n", "\n", "#include \"base/CCRef.h\"\n", "#include \"renderer/CCRenderCommand.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "//Used for internal\n", "class GroupCommandManager : public Ref\n", "{\n", "public:\n", "    int getGroupID();\n", "    void releaseGroupID(int groupID);\n", "\n", "protected:\n", "    friend class Renderer;\n", "    GroupCommandManager();\n", "    ~GroupCommandManager();\n", "    bool init();\n", "    std::unordered_map<int, bool> _groupMapping;\n", "    std::vector<int> _unusedIDs;\n", "};\n", "\n", "/**\n", " GroupCommand is used to group several command together, and more, it can be nested.\n", " So it is used to generate the hierarchy for the rendcommands. Every group command will be assigned by a group ID.\n", " */\n"], "CCMeshCommand.cpp_cpp": ["#include \"renderer/CCMeshCommand.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventCustom.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"2d/CCLight.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"xxhash.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCMeshCommand.h_header": ["\n", "#include <unordered_map>\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/backend/Types.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"math/CCMath.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class GLProgramState;\n", "class EventListenerCustom;\n", "class EventCustom;\n", "class Material;\n", "\n", "//it is a common mesh\n"], "CCTrianglesCommand.cpp_cpp": ["#include \"renderer/CCTrianglesCommand.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"xxhash.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"base//ccUtils.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCTrianglesCommand.h_header": ["\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"renderer/CCPipelineDescriptor.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "/** \n", " Command used to render one or more Triangles, which is similar to QuadCommand.\n", " Every TrianglesCommand will have generate material ID by give textureID, glProgramState, Blend function\n", " if the material id is the same, these TrianglesCommands could be batched to save draw call.\n", "*/\n", "namespace backend {\n", "    class TextureBackend;\n", "    class Program;\n", "}\n", "\n", "class Texture2D;\n", "\n"], "CCQuadCommand.cpp_cpp": ["\n", "#include \"renderer/CCQuadCommand.h\"\n", "\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"xxhash.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCQuadCommand.h_header": ["\n", "#include <vector>\n", "\n", "#include \"renderer/CCTrianglesCommand.h\"\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "/** \n", " Command used to render one or more Quads, similar to TrianglesCommand.\n", " Every QuadCommand will have generate material ID by give textureID, glProgramState, Blend function\n", " if the material id is the same, these QuadCommands could be batched to save draw call.\n", " */\n", "\n", "\n"], "CCRenderCommand.cpp_cpp": ["\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"2d/CCNode.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"xxhash.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCRenderCommand.h_header": ["\n", "#include <stdint.h>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"renderer/CCPipelineDescriptor.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "/** Base class of the `RenderCommand` hierarchy.\n", "*\n", " The `Renderer` knows how to render `RenderCommands` objects.\n", " */\n", "class CC_DLL RenderCommand\n", "{\n", "public:\n", "    /**Enum the type of render command. */\n", "    enum class Type\n", "    {\n", "        /** Reserved type.*/\n", "        UNKNOWN_COMMAND,\n", "        /** Quad command, used for draw quad.*/\n", "        QUAD_COMMAND,\n", "        /**Custom command, used for calling callback for rendering.*/\n", "        CUSTOM_COMMAND,\n", "        /**Batch command, used for draw batches in texture atlas.*/\n", "        BATCH_COMMAND,\n", "        /**Group command, which can group command in a tree hierarchy.*/\n", "        GROUP_COMMAND,\n", "        /**Mesh command, used to draw 3D meshes.*/\n", "        MESH_COMMAND,\n", "        /**Primitive command, used to draw primitives such as lines, points and triangles.*/\n", "        PRIMITIVE_COMMAND,\n", "        /**Triangles command, used to draw triangles.*/\n", "        TRIANGLES_COMMAND\n", "    };\n", "\n", "    /**\n", "     Init function, will be called by all the render commands.\n", "     @param globalZOrder The global order of command, used for rendercommand sorting.\n", "     @param modelViewTransform Modelview matrix when submitting the render command.\n", "     @param flags Flag used to indicate whether the command should be draw at 3D mode or not.\n", "     */\n", "    void init(float globalZOrder, const Mat4& modelViewTransform, uint32_t flags);\n", "    \n", "    /** Get global Z order. */\n", "    inline float getGlobalOrder() const { return _globalOrder; }\n", "\n", "    /** Returns the Command type. */\n", "    inline Type getType() const { return _type; }\n", "    \n", "    /** Retruns whether is transparent. */\n", "    inline bool isTransparent() const { return _isTransparent; }\n", "    \n", "    /** Set transparent flag. */\n", "    inline void setTransparent(bool isTransparent) { _isTransparent = isTransparent; }\n", "    /**\n", "     Get skip batching status, if a rendering is skip batching, it will be forced to be rendering separately.\n", "     */\n", "    inline bool isSkipBatching() const { return _skipBatching; }\n", "    /**Set skip batching.*/\n", "    inline void setSkipBatching(bool value) { _skipBatching = value; }\n", "    /**Whether the command should be rendered at 3D mode.*/\n", "    inline bool is3D() const { return _is3D; }\n", "    /**Set the command rendered in 3D mode or not.*/\n", "    inline void set3D(bool value) { _is3D = value; }\n", "    /**Get the depth by current model view matrix.*/\n", "    inline float getDepth() const { return _depth; }\n", "    \n", "protected:\n", "    /**Constructor.*/\n", "    RenderCommand();\n", "    /**Desctructor.*/\n", "    virtual ~RenderCommand();\n", "    //used for debug but it is not implemented.\n", "    void printID();\n", "\n", "    /**Type used in order to avoid dynamic cast, faster. */\n", "    Type _type;\n", "\n", "    /** Commands are sort by global Z order. */\n", "    float _globalOrder;\n", "    \n", "    /** Transparent flag. */\n", "    bool  _isTransparent;\n", "    \n", "    /**\n", "     QuadCommand and TrianglesCommand could be auto batched if there material ID is the same, however, if\n", "     a command is skip batching, it would be forced to draw in a separate function call, and break the batch.\n", "     */\n", "    bool _skipBatching;\n", "    \n", "    /** Is the command been rendered on 3D pass. */\n", "    bool _is3D;\n", "    \n", "    /** Depth from the model view matrix.*/\n", "    float _depth;\n", "};\n", "\n"], "CCRenderCommandPool.h_header": ["/// @cond DO_NOT_SHOW\n", "\n", "#include <list>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "template <class T>\n"], "CCRenderer.cpp_cpp": ["#include \"renderer/CCRenderer.h\"\n", "\n", "#include <algorithm>\n", "\n", "#include \"renderer/CCTrianglesCommand.h\"\n", "#include \"renderer/CCQuadCommand.h\"\n", "#include \"renderer/CCBatchCommand.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCCallbackCommand.h\"\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCPrimitiveCommand.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "#include \"renderer/CCGLProgramCache.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"2d/CCScene.h\"\n", "#include \"xxhash.h\"\n", "\n", "#include \"renderer/backend/Backend.h\"\n", "\n", "// \u5b9a\u4e49\u4e34\u65f6\u7684\u5185\u5b58\u5206\u914d\u5668\n", "#include <stdlib.h>\n", "#include <cassert>\n", "\n", "#include <memory>\n", "#include <thread>\n", "\n", "#include <vector>\n", "#include <string>\n", "#include <chrono>\n", "#include <iostream>\n", "\n", "#define TEMP_MALLOC malloc\n", "#define TEMP_FREE free\n", "#define TEMP_NEW_INPLACE(MEMORY) new(MEMORY)\n", "\n", "class LinearAllocator\n", "{\n", "public:\n", "    LinearAllocator(size_t size)\n", "    : m_Ptr{ static_cast<char*>(TEMP_MALLOC(size)) }\n", "    , m_TotalSize{ size }\n", "    , m_FreeSpace{ size }\n", "    {}\n", "    \n", "    ~LinearAllocator()\n", "    {\n", "        TEMP_FREE(m_Ptr);\n", "    }\n", "    \n", "    void* Allocate(size_t size, unsigned alignment /* power of 2 */)\n", "    {\n", "        assert((alignment & (alignment - 1)) == 0);\n", "        \n", "        auto currentPtr = static_cast<void*>(m_Ptr + (m_TotalSize - m_FreeSpace));\n", "        size_t a = (alignment - 1);\n", "        auto retPtr = (void*)(((size_t)currentPtr + a) & ~a);\n", "        \n", "        m_FreeSpace -= ((char*)retPtr - (char*)currentPtr);\n", " //       auto retPtr = std::align(alignment, size, currentPtr, m_FreeSpace);\n", "        \n", "/*        if (!retPtr)\n", "        {\n", "            assert(false && \"Linear allocator full!\");\n", "            // no space\n", "            return nullptr;\n", "        }\n", " */\n", "        \n", "        m_FreeSpace -= size;\n", "        \n", "        return retPtr;\n", "    }\n", "    \n", "    void Free()\n", "    {\n", "        // do nothing\n", "    }\n", "    \n", "    void Reset(size_t freeSpace)\n", "    {\n", "        m_FreeSpace = freeSpace;\n", "    }\n", "    \n", "    size_t CurrentFreeSpace() const { return m_FreeSpace; }\n", "    \n", "private:\n", "    char* m_Ptr;\n", "    size_t m_TotalSize;\n", "    size_t m_FreeSpace;\n", "};\n", "\n", "static LinearAllocator s_linearMemory(1024 * 1024);\n", "static LinearAllocator* tlsLinearAllocator = &s_linearMemory;\n", "\n", "template<typename T>\n", "class TempStdAllocator {\n", "public:\n", "    typedef T value_type;\n", "    typedef value_type* pointer;\n", "    typedef const value_type* const_pointer;\n", "    typedef value_type& reference;\n", "    typedef const value_type& const_reference;\n", "    typedef std::size_t size_type;\n", "    typedef std::ptrdiff_t difference_type;\n", "    \n", "public:\n", "    template<typename U>\n", "    struct rebind {\n", "        typedef TempStdAllocator<U> other;\n", "    };\n", "    \n", "public:\n", "    inline TempStdAllocator() {}\n", "    inline ~TempStdAllocator() {}\n", "    inline TempStdAllocator(const TempStdAllocator& rhs) {}\n", "    \n", "    template<typename U>\n", "    inline TempStdAllocator(const TempStdAllocator<U>& rhs) {}\n", "    \n", "    inline pointer address(reference r) { return &r; }\n", "    inline const_pointer address(const_reference r) { return &r; }\n", "    \n", "    inline pointer allocate(size_type cnt, typename std::allocator<void>::const_pointer = 0)\n", "    {\n", "        return reinterpret_cast<pointer>(tlsLinearAllocator->Allocate(unsigned(cnt * sizeof(T)), sizeof(size_t) == 4 ? 8 : 16));\n", "    }\n", "    inline void deallocate(pointer p, size_type)\n", "    {\n", "        // do nothing\n", "    }\n", "    \n", "    inline size_type max_size() const\n", "    {\n", "        return std::numeric_limits<size_type>::max() / sizeof(T);\n", "    }\n", "    \n", "    template <class U, class... Args>\n", "    inline void construct(U* p, Args&&... args)\n", "    {\n", "        TEMP_NEW_INPLACE(p) U(std::forward<Args>(args)...);\n", "    }\n", "    \n", "    inline void destroy(pointer p) { p->~T(); }\n", "    \n", "    inline bool operator==(TempStdAllocator const&) const { return true; }\n", "    inline bool operator!=(TempStdAllocator const& a) const { return !operator==(a); }\n", "    \n", "private:\n", "    template<typename U> friend class TempStdAllocator;\n", "};\n", "\n", "struct TempAllocatorScope\n", "{\n", "public:\n", "    TempAllocatorScope(int unused)\n", "    : m_Space(tlsLinearAllocator->CurrentFreeSpace())\n", "    {}\n", "    \n", "    ~TempAllocatorScope()\n", "    {\n", "        tlsLinearAllocator->Reset(m_Space);\n", "    }\n", "    \n", "    void Reset()\n", "    {\n", "        tlsLinearAllocator->Reset(m_Space);\n", "    }\n", "private:\n", "    size_t m_Space;\n", "};\n", "\n", "template<typename T>\n", "class dynamicArray\n", "{\n", "public:\n", "    \n", "    dynamicArray():m_data(nullptr),m_size(0),m_capacity(0)\n", "    {\n", "        \n", "    }\n", "    \n", "    dynamicArray(size_t inCapacity):m_size(0),m_capacity(inCapacity)\n", "    {\n", "        m_data = static_cast<T*>(tlsLinearAllocator->Allocate(unsigned(inCapacity * sizeof(T)), sizeof(size_t) == 4 ? 8 : 16));\n", "    }\n", "    \n", "    inline void reserve(size_t inCapacity)\n", "    {\n", "        if (m_capacity >= inCapacity)\n", "        {\n", "            return;\n", "        }\n", "        \n", "        T* newData = static_cast<T*>(tlsLinearAllocator->Allocate(unsigned(inCapacity * sizeof(T)), sizeof(size_t) == 4 ? 8 : 16));\n", "        memcpy((void*)newData, (void*)m_data, m_size * sizeof(T));\n", "        m_capacity = inCapacity;\n", "        m_data = newData;\n", "    }\n", "    \n", "    inline T& emplace_back()\n", "    {\n", "        size_t oldSize = m_size;\n", "        size_t newSize = oldSize + 1;\n", "        \n", "        if (newSize > m_capacity)\n", "        {\n", "            reserve(m_capacity + 10);\n", "        }\n", "        \n", "        m_size = newSize;\n", "        T& val = m_data[oldSize];\n", "        return val;\n", "    }\n", "    \n", "    inline void push_back(const T& t)\n", "    {\n", "        size_t oldSize = m_size;\n", "        size_t newSize = oldSize + 1;\n", "        \n", "        if (newSize > m_capacity)\n", "        {\n", "            reserve(m_capacity + 10);\n", "        }\n", "        \n", "        m_size = newSize;\n", "        m_data[oldSize] = t;\n", "    }\n", "    \n", "    inline size_t size()\n", "    {\n", "        return m_size;\n", "    }\n", "    \n", "    inline void clear()\n", "    {\n", "        m_size = 0;\n", "    }\n", "    \n", "    inline void reset()\n", "    {\n", "        m_data = nullptr;\n", "        m_size = 0;\n", "        m_capacity = 0;\n", "    }\n", "    \n", "    inline T& operator[] (size_t index)\n", "    {\n", "        return m_data[index];\n", "    }\n", "    \n", "private:\n", "    T* m_data;\n", "    size_t m_size;\n", "    size_t m_capacity;\n", "};\n", "\n", "template<typename T>\n", "class FixArray\n", "{\n", "public:\n", "    \n", "    FixArray(size_t size):m_size(size)\n", "    {\n", "        m_data = static_cast<T*>(tlsLinearAllocator->Allocate(unsigned(m_size * sizeof(T)), sizeof(size_t) == 4 ? 8 : 16));\n", "    }\n", "    \n", "    inline size_t size()\n", "    {\n", "        return m_size;\n", "    }\n", "    \n", "    inline T& operator[] (size_t index)\n", "    {\n", "        return m_data[index];\n", "    }\n", "    \n", "private:\n", "    T* m_data;\n", "    size_t m_size;\n", "};\n", "\n", "NS_CC_BEGIN\n"], "CCRenderer.h_header": ["\n", "#include <vector>\n", "#include <stack>\n", "#include <array>\n", "#include <deque>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"renderer/backend/Types.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"platform/CCGL.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "using CullMode = backend::CullMode;\n", "using Winding = backend::Winding;\n", "\n", "namespace backend\n", "{\n", "    class Buffer;\n", "    class CommandBuffer;\n", "    class RenderPipeline;\n", "    class RenderPass;\n", "    struct RenderPipelineDescriptor;\n", "}\n", "\n", "class EventListenerCustom;\n", "class QuadCommand;\n", "class TrianglesCommand;\n", "class MeshCommand;\n", "class GroupCommand;\n", "class CallbackCommand;\n", "struct PipelineDescriptor;\n", "class Texture2D;\n", "\n", "/** Class that knows how to sort `RenderCommand` objects.\n", " Since the commands that have `z == 0` are \"pushed back\" in\n", " the correct order, the only `RenderCommand` objects that need to be sorted,\n", " are the ones that have `z < 0` and `z > 0`.\n", "*/\n", "\n", "\n", "\n", "class RenderQueue {\n", "public:\n", "    /**\n", "    RenderCommand will be divided into Queue Groups.\n", "    */\n", "    enum QUEUE_GROUP\n", "    {\n", "        /**Objects with globalZ smaller than 0.*/\n", "        GLOBALZ_NEG = 0,\n", "        /**Opaque 3D objects with 0 globalZ.*/\n", "        OPAQUE_3D = 1,\n", "        /**Transparent 3D objects with 0 globalZ.*/\n", "        TRANSPARENT_3D = 2,\n", "        /**2D objects with 0 globalZ.*/\n", "        GLOBALZ_ZERO = 3,\n", "        /**Objects with globalZ bigger than 0.*/\n", "        GLOBALZ_POS = 4,\n", "        QUEUE_COUNT = 5,\n", "    };\n", "\n", "public:\n", "    /**Constructor.*/\n", "    RenderQueue();\n", "    /**Push a renderCommand into current renderqueue.*/\n", "    void push_back(RenderCommand* command);\n", "    /**Return the number of render commands.*/\n", "    ssize_t size() const;\n", "    /**Sort the render commands.*/\n", "    void sort();\n", "    /**Treat sorted commands as an array, access them one by one.*/\n", "    RenderCommand* operator[](ssize_t index) const;\n", "    /**Clear all rendered commands.*/\n", "    void clear();\n", "    /**Realloc command queues and reserve with given size. Note: this clears any existing commands.*/\n", "    void realloc(size_t reserveSize);\n", "    /**Get a sub group of the render queue.*/\n", "    inline std::vector<RenderCommand*>& getSubQueue(QUEUE_GROUP group) { return _commands[group]; }\n", "    /**Get the number of render commands contained in a subqueue.*/\n", "    inline ssize_t getSubQueueSize(QUEUE_GROUP group) const { return _commands[group].size();}\n", "\n", "    /**Save the current DepthState, CullState, DepthWriteState render state.*/\n", "    void saveRenderState();\n", "    /**Restore the saved DepthState, CullState, DepthWriteState render state.*/\n", "    void restoreRenderState();\n", "    \n", "protected:\n", "    /**The commands in the render queue.*/\n", "    std::vector<RenderCommand*> _commands[QUEUE_COUNT];\n", "    \n", "    /**Cull state.*/\n", "    bool _isCullEnabled;\n", "    /**Depth test enable state.*/\n", "    bool _isDepthEnabled;\n", "    /**Depth buffer write state.*/\n", "    GLboolean _isDepthWrite;\n", "};\n", "\n", "//the struct is not used outside.\n", "struct RenderStackElement\n", "{\n", "    int renderQueueID;\n", "    ssize_t currentIndex;\n", "};\n", "\n", "class GroupCommandManager;\n", "\n", "/* Class responsible for the rendering in.\n", "\n", "Whenever possible prefer to use `QuadCommand` objects since the renderer will automatically batch them.\n", " */\n"], "ccShaders.cpp_cpp": ["#include \"renderer/ccShaders.h\"\n", "\n", "#define STRINGIFY(A)  #A\n", "\n", "NS_CC_BEGIN\n"], "CCTextureAtlas.cpp_cpp": ["#include \"renderer/CCTextureAtlas.h\"\n", "\n", "#include <stdlib.h>\n", "\n", "#include \"base/ccMacros.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"platform/CCGL.h\"\n", "\n", "\n", "#include \"deprecated/CCString.h\"\n", "\n", "//According to some tests GL_TRIANGLE_STRIP is slower, MUCH slower. Probably I'm doing something very wrong\n", "\n", "// implementation TextureAtlas\n", "\n", "NS_CC_BEGIN\n"], "CCTextureAtlas.h_header": ["\n", "#include <string>\n", "\n", "#include \"base/ccTypes.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"base/ccConfig.h\"\n", "#include \"renderer/CCTrianglesCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Texture2D;\n", "class EventCustom;\n", "class EventListenerCustom;\n", "\n", "\n", "\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/** @brief A class that implements a Texture Atlas.\n", "Supported features:\n", "* The atlas file can be a PVRTC, PNG or any other format supported by Texture2D\n", "* Quads can be updated in runtime\n", "* Quads can be added in runtime\n", "* Quads can be removed in runtime\n", "* Quads can be re-ordered in runtime\n", "* The TextureAtlas capacity can be increased or decreased in runtime\n", "* OpenGL component: V3F, C4B, T2F.\n", "The quads are rendered using an OpenGL ES VBO.\n", "To render the quads using an interleaved vertex array list, you should modify the ccConfig.h file \n", "\n", "@warning If you want to use TextureAtlas, you'd better setup GL status before it's rendered.\n", "         Otherwise, the effect of TextureAtlas will be affected by the GL status of other nodes.\n", "*/\n"], "CCTextureCache.cpp_cpp": ["#include \"renderer/CCTextureCache.h\"\n", "\n", "#include <errno.h>\n", "#include <stack>\n", "#include <cctype>\n", "#include <list>\n", "\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCScheduler.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"base/ccUtils.h\"\n", "\n", "#include \"deprecated/CCString.h\"\n", "#include \"base/CCNinePatchImageParser.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"2d/CCSpriteFrameCache.h\"\n", "#ifdef EMSCRIPTEN\n", "#include <emscripten/emscripten.h>\n", "#include \"platform/emscripten/CCTextureCacheEmscripten.h\"\n", "#endif // EMSCRIPTEN\n", "#include \"2d/CCParticleSystemQuad.h\"\n", "using namespace std;\n", "\n", "bool IsExistCompressFile(const char* fileName);\n", "void ResetCompressFullFileName(const std::string& path, std::string& fullpath);\n", " \n", "NS_CC_BEGIN\n"], "VolatileTextureMgr::reloadAllTextures": ["void VolatileTextureMgr::reloadAllTextures()\n", "{\n", "    _isReloading = true;\n", "    CCLOG(\"reload all texture\");\n", "\n", "    for (auto& texture : _textures)\n", "    {\n", "        VolatileTexture *vt = texture;\n", "\n", "        switch (vt->_cashedImageType)\n", "        {\n", "        case VolatileTexture::kImageFile:\n", "        {\n", "            reloadTexture(vt->_texture, vt->_fileName, vt->_pixelFormat);\n", "\n", "            // etc1 support check whether alpha texture exists & load it\n", "            auto alphaFile = vt->_fileName + TextureCache::getETC1AlphaFileSuffix();\n", "            reloadTexture(vt->_texture->getAlphaTexture(), alphaFile, vt->_pixelFormat);\n", "        }\n", "        break;\n", "        case VolatileTexture::kImageData:\n", "        {\n", "            vt->_texture->initWithData(vt->_textureData,\n", "                vt->_dataLen,\n", "                vt->_pixelFormat,\n", "                vt->_textureSize.width,\n", "                vt->_textureSize.height,\n", "                vt->_textureSize);\n", "        }\n", "        break;\n", "        case VolatileTexture::kString:\n", "        {\n", "            vt->_texture->initWithString(vt->_text.c_str(), vt->_fontDefinition);\n", "        }\n", "        break;\n", "        case VolatileTexture::kImage:\n", "        {\n", "            vt->_texture->initWithImage(vt->_uiImage, vt->_pixelFormat);\n", "        }\n", "        break;\n", "        default:\n", "            break;\n", "        }\n", "    }\n", "\n", "    _isReloading = false;\n", "}\n"], "CCRenderState.cpp_cpp": ["#include \"renderer/CCRenderState.h\"\n", "\n", "#include <string>\n", "#include <cassert>\n", "\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "\n", "\n", "NS_CC_BEGIN\n"], "RenderState::StateBlock::setState-std::string&-std::string&": ["void RenderState::StateBlock::setState(const std::string& name, const std::string& value)\n", "{\n", "    if (name.compare(\"blend\") == 0)\n", "    {\n", "        setBlend(parseBoolean(value));\n", "    }\n", "    else if (name.compare(\"blendSrc\") == 0)\n", "    {\n", "        setBlendSrc(parseBlend(value));\n", "    }\n", "    else if (name.compare(\"blendDst\") == 0)\n", "    {\n", "        setBlendDst(parseBlend(value));\n", "    }\n", "    else if (name.compare(\"cullFace\") == 0)\n", "    {\n", "        setCullFace(parseBoolean(value));\n", "    }\n", "    else if (name.compare(\"cullFaceSide\") == 0)\n", "    {\n", "        setCullFaceSide(parseCullFaceSide(value));\n", "    }\n", "    else if (name.compare(\"frontFace\") == 0)\n", "    {\n", "        setFrontFace(parseFrontFace(value));\n", "    }\n", "    else if (name.compare(\"depthTest\") == 0)\n", "    {\n", "        setDepthTest(parseBoolean(value));\n", "    }\n", "    else if (name.compare(\"depthWrite\") == 0)\n", "    {\n", "        setDepthWrite(parseBoolean(value));\n", "    }\n", "    else if (name.compare(\"depthFunc\") == 0)\n", "    {\n", "        setDepthFunction(parseDepthFunc(value));\n", "    }\n", "    else\n", "    {\n", "        CCLOG(\"Unsupported render state string '%s'.\", name.c_str());\n", "    }\n", "}\n"], "CCRenderState.h_header": ["\n", "#include <string>\n", "#include <functional>\n", "#include <cstdint>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"base/CCVector.h\"\n", "\n", "#include \"renderer/CCPipelineDescriptor.h\"\n", "#include \"renderer/backend/Types.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Texture2D;\n", "class Pass;\n", "class MeshCommand;\n", "\n", "using CullFaceSide = backend::CullMode;\n", "using FrontFace = backend::Winding;\n", "using DepthFunction = backend::CompareFunction;\n", "\n", "/**\n", " * Defines the rendering state of the graphics device.\n", " */\n"], "CCPass.cpp_cpp": ["#include \"CCPass.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"3d/CCMeshVertexIndexData.h\"\n", "#include \"3d/CCVertexAttribBinding.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCVertexAttribBinding.h\"\n", "\n", "#include \"base/ccTypes.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"2d/CCNode.h\"\n", "\n", "#include <xxhash.h>\n", "\n", "NS_CC_BEGIN\n"], "CCPass.h_header": ["\n", "#include <stdio.h>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCCallbackCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class GLProgramState;\n", "class ProgramState;\n", "class Technique;\n", "class Node;\n", "class VertexAttribBinding;\n", "class MeshIndexData;\n", "class RenderState;\n", "\n", "namespace backend\n", "{\n", "    class ProgramState;\n", "    class Buffer;\n", "}\n", "\n"], "CCTechnique.cpp_cpp": ["#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCPass.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCTechnique.h_header": ["\n", "#include <string>\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/CCVector.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Pass;\n", "class GLProgramState;\n", "namespace  backend\n", "{\n", "    class ProgramState;\n", "}\n", "class Material;\n", "\n", "/// Technique\n"], "CCMaterial.cpp_cpp": ["#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"base/CCProperties.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"base/CCConsole.h\"\n", "\n", "#include <sstream>\n", "\n", "\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)\n", "#define strcasecmp _stricmp\n", "#endif\n", "\n", "NS_CC_BEGIN\n"], "Material::parseSampler-backend::ProgramState*-Properties*": ["bool Material::parseSampler(backend::ProgramState* programState, Properties* samplerProperties)\n", "{\n", "    CCASSERT(samplerProperties->getId(), \"Sampler must have an id. The id is the uniform name\");\n", "    \n", "    // required\n", "    auto filename = samplerProperties->getString(\"path\");\n", "\n", "    auto texture = Director::getInstance()->getTextureCache()->addImage(filename);\n", "    if (!texture) {\n", "        CCLOG(\"Invalid filepath\");\n", "        return false;\n", "    }\n", "\n", "    // optionals\n", "    {\n", "        Texture2D::TexParams texParams;\n", "\n", "        // mipmap\n", "        bool usemipmap = false;\n", "        const char* mipmap = getOptionalString(samplerProperties, \"mipmap\", \"false\");\n", "        if (mipmap && strcasecmp(mipmap, \"true\")==0) {\n", "            texture->generateMipmap();\n", "            usemipmap = true;\n", "        }\n", "\n", "        // valid options: REPEAT, CLAMP\n", "        const char* wrapS = getOptionalString(samplerProperties, \"wrapS\", \"CLAMP_TO_EDGE\");\n", "        if (strcasecmp(wrapS, \"REPEAT\")==0)\n", "            texParams.sAddressMode = backend::SamplerAddressMode::REPEAT;\n", "        else if(strcasecmp(wrapS, \"CLAMP_TO_EDGE\")==0)\n", "            texParams.sAddressMode = backend::SamplerAddressMode::CLAMP_TO_EDGE;\n", "        else\n", "            CCLOG(\"Invalid wrapS: %s\", wrapS);\n", "\n", "\n", "        // valid options: REPEAT, CLAMP\n", "        const char* wrapT = getOptionalString(samplerProperties, \"wrapT\", \"CLAMP_TO_EDGE\");\n", "        if (strcasecmp(wrapT, \"REPEAT\")==0)\n", "            texParams.tAddressMode = backend::SamplerAddressMode::REPEAT;\n", "        else if(strcasecmp(wrapT, \"CLAMP_TO_EDGE\")==0)\n", "            texParams.tAddressMode = backend::SamplerAddressMode::CLAMP_TO_EDGE;\n", "        else\n", "            CCLOG(\"Invalid wrapT: %s\", wrapT);\n", "\n", "\n", "        // valid options: NEAREST, LINEAR, NEAREST_MIPMAP_NEAREST, LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR\n", "        const char* minFilter = getOptionalString(samplerProperties, \"minFilter\", usemipmap ? \"LINEAR_MIPMAP_NEAREST\" : \"LINEAR\");\n", "        if (strcasecmp(minFilter, \"NEAREST\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::NEAREST;\n", "        else if(strcasecmp(minFilter, \"LINEAR\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "        else if(strcasecmp(minFilter, \"NEAREST_MIPMAP_NEAREST\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::NEAREST;\n", "        else if(strcasecmp(minFilter, \"LINEAR_MIPMAP_NEAREST\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "        else if(strcasecmp(minFilter, \"NEAREST_MIPMAP_LINEAR\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "        else if(strcasecmp(minFilter, \"LINEAR_MIPMAP_LINEAR\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "        else\n", "            CCLOG(\"Invalid minFilter: %s\", minFilter);\n", "\n", "        // valid options: NEAREST, LINEAR\n", "        const char* magFilter = getOptionalString(samplerProperties, \"magFilter\", \"LINEAR\");\n", "        if (strcasecmp(magFilter, \"NEAREST\")==0)\n", "            texParams.magFilter = backend::SamplerFilter::NEAREST;\n", "        else if(strcasecmp(magFilter, \"LINEAR\")==0)\n", "            texParams.magFilter = backend::SamplerFilter::LINEAR;\n", "        else\n", "            CCLOG(\"Invalid magFilter: %s\", magFilter);\n", "\n", "        texture->setTexParameters(texParams);\n", "    }\n", "\n", "    auto textureName = samplerProperties->getId();\n", "    auto location = programState->getUniformLocation(textureName);\n", "    \n", "    if (!location)\n", "    {\n", "        CCLOG(\"warning: failed to find texture uniform location %s when parsing material\", textureName);\n", "        return false;\n", "    }\n", "\n", "    if (_textureSlots.find(textureName) == _textureSlots.end())\n", "    {\n", "        _textureSlots[textureName] = _textureSlotIndex;\n", "        programState->setTexture(location, _textureSlotIndex++, texture->getBackendTexture());\n", "    }\n", "    else\n", "    {\n", "        programState->setTexture(location, _textureSlots[textureName], texture->getBackendTexture());\n", "    }\n", "\n", "    return true;\n", "}\n"], "CCMaterial.h_header": ["\n", "#include <string>\n", "#include <unordered_map>\n", "\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"base/CCVector.h\"\n", "#include \"math/Vec2.h\"\n", "#include \"math/Vec3.h\"\n", "#include \"math/Vec4.h\"\n", "#include \"math/Mat4.h\"\n", "#include \"platform/CCPlatformMacros.h\"\n", "\n", "\n", "NS_CC_BEGIN\n", "\n", "class Technique;\n", "class Pass;\n", "class GLProgramState;\n", "class Node;\n", "class Properties;\n", "class RenderState;\n", "\n", "namespace backend\n", "{\n", "    class ProgramState;\n", "}\n", "\n", "/// Material\n"], "CCMesh.h_header": ["\n", "#include <string>\n", "#include <map>\n", "\n", "#include \"3d/CCBundle3DData.h\"\n", "#include \"3d/CCAABB.h\"\n", "#include \"3d/CC3DProgramInfo.h\"\n", "\n", "#include \"base/CCRef.h\"\n", "#include \"math/CCMath.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _3d\n", " * @{\n", " */\n", "\n", "class Texture2D;\n", "class MeshSkin;\n", "class MeshIndexData;\n", "class Material;\n", "class Renderer;\n", "class Scene;\n", "class Pass;\n", "\n", "namespace backend\n", "{\n", "    class Buffer;\n", "}\n", "\n", "/** \n", " * @brief Mesh: contains ref to index buffer, GLProgramState, texture, skin, blend function, aabb and so on\n", " */\n"], "CCMesh.cpp_cpp": ["#include \"3d/CCMesh.h\"\n", "#include \"3d/CCMeshSkin.h\"\n", "#include \"3d/CCSkeleton3D.h\"\n", "#include \"3d/CCMeshVertexIndexData.h\"\n", "#include \"3d/CCVertexAttribBinding.h\"\n", "#include \"2d/CCLight.h\"\n", "#include \"2d/CCScene.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCVertexAttribBinding.h\"\n", "#include \"renderer/backend/Buffer.h\"\n", "#include \"renderer/backend/Program.h\"\n", "#include \"math/Mat4.h\"\n", "\n", "using namespace std;\n", "\n", "NS_CC_BEGIN\n"], "Mesh::setTexture-Texture2D*": ["void Mesh::setTexture(Texture2D* tex)\n", "{\n", "    setTexture(tex, NTextureData::Usage::Diffuse);\n", "}\n"], "Mesh::setMaterial-Material*": ["void Mesh::setMaterial(Material* material)\n", "{\n", "    if (_material != material) {\n", "        CC_SAFE_RELEASE(_material);\n", "        _material = material;\n", "        CC_SAFE_RETAIN(_material);\n", "    }\n", "\n", "    if (_material)\n", "    {\n", "        for (auto technique: _material->getTechniques())\n", "        {\n", "            //allocate MeshCommand vector for technique\n", "            //allocate MeshCommand for each pass\n", "            _meshCommands[technique->getName()] = std::vector<MeshCommand>(technique->getPasses().size());\n", "            auto &list = _meshCommands[technique->getName()];\n", "            \n", "            int i = 0;\n", "            for (auto pass: technique->getPasses())\n", "            {\n", "#ifdef COCOS2D_DEBUG\n", "                //make it crashed when missing attribute data\n", "                if(_material->getTechnique()->getName().compare(technique->getName()) == 0)\n", "                {\n", "                    auto program = pass->getProgramState()->getProgram();\n", "                    auto& attributes = program->getActiveAttributes();\n", "                    auto meshVertexData = _meshIndexData->getMeshVertexData();\n", "                    auto attributeCount = meshVertexData->getMeshVertexAttribCount();\n", "                    CCASSERT(attributes.size() <= attributeCount, \"missing attribute data\");\n", "                }\n", "#endif\n", "                //TODO\n", "                auto vertexAttribBinding = VertexAttribBinding::create(_meshIndexData, pass, &list[i]);\n", "                pass->setVertexAttribBinding(vertexAttribBinding);\n", "                i += 1;\n", "            }\n", "        }\n", "    }\n", "    // Was the texture set before the GLProgramState ? Set it\n", "    for(auto& tex : _textures)\n", "        setTexture(tex.second, tex.first);\n", "        \n", "    \n", "    if (_blendDirty)\n", "        setBlendFunc(_blend);\n", "    \n", "    bindMeshCommand();\n", "}\n"], "CCVertexAttribBinding.h_header": ["\n", "#include <unordered_map>\n", "\n", "#include \"base/CCRef.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/backend/Types.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"3d/CC3DProgramInfo.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class MeshIndexData;\n", "class VertexAttribValue;\n", "\n", "/**\n", " * Defines a binding between the vertex layout of a Mesh and the vertex\n", " * input attributes of a vertex shader (Effect).\n", " *\n", " * In a perfect world, this class would always be a binding directly between\n", " * a unique VertexFormat and an Effect, where the VertexFormat is simply the\n", " * definition of the layout of any anonymous vertex buffer. However, the OpenGL\n", " * mechanism for setting up these bindings is Vertex Array Objects (VAOs).\n", " * OpenGL requires a separate VAO per vertex buffer object (VBO), rather than per\n", " * vertex layout definition. Therefore, although we would like to define this\n", " * binding between a VertexFormat and Effect, we are specifying the binding\n", " * between a Mesh and Effect to satisfy the OpenGL requirement of one VAO per VBO.\n", " *\n", " * Note that this class still does provide a binding between a VertexFormat\n", " * and an Effect, however this binding is actually a client-side binding and \n", " * should only be used when writing custom code that use client-side vertex\n", " * arrays, since it is slower than the server-side VAOs used by OpenGL\n", " * (when creating a VertexAttribBinding between a Mesh and Effect).\n", " */\n", "\n"], "CCVertexAttribBinding.cpp_cpp": ["#include \"renderer/backend/Program.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"3d/CCMeshVertexIndexData.h\"\n", "#include \"3d/CC3DProgramInfo.h\"\n", "#include \"3d/CCVertexAttribBinding.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCMeshVertexIndexData.h_header": ["\n", "#include <string>\n", "#include <vector>\n", "\n", "#include \"3d/CCBundle3DData.h\"\n", "#include \"3d/CCAABB.h\"\n", "#include \"3d/CC3DProgramInfo.h\"\n", "\n", "#include \"base/CCRef.h\"\n", "#include \"base/CCVector.h\"\n", "#include \"math/CCMath.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _3d\n", " * @{\n", " */\n", "\n", "class MeshVertexData;\n", "\n", "/**\n", " * the MeshIndexData class.\n", " * @brief the MeshIndexData contain all of the indices data which mesh need.\n", " * @js NA\n", " * @lua NA\n", " */\n", "class CC_DLL MeshIndexData : public Ref\n", "{\n", "public:\n", "    /** create  */\n", "    static MeshIndexData* create(const std::string& id, MeshVertexData* vertexData, backend::Buffer* indexbuffer, const AABB& aabb);\n", "    \n", "    /**get index buffer*/\n", "    backend::Buffer* getIndexBuffer() const { return _indexBuffer; }\n", "\n", "    /**get vertex buffer*/\n", "    backend::Buffer* getVertexBuffer() const;\n", "    \n", "    /**get vertex data*/\n", "    const MeshVertexData* getMeshVertexData() const { return _vertexData; }\n", "    \n", "    /** aabb getter and setter */\n", "    void setAABB(const AABB& aabb) { _aabb = aabb; }\n", "    const AABB& getAABB() const { return _aabb; }\n", "    \n", "    /** id setter and getter */\n", "    void setId(const std::string& id) { _id = id; }\n", "    const std::string& getId() const { return _id; }\n", "    \n", "    /**primitive type setter & getter*/\n", "    MeshCommand::PrimitiveType getPrimitiveType() const { return _primitiveType; }\n", "    void   setPrimitiveType(MeshCommand::PrimitiveType primitive) { _primitiveType = primitive; }\n", "    \n", "    void setIndexData(const MeshData::IndexArray& indexdata);\n", "    \n", "CC_CONSTRUCTOR_ACCESS:\n", "    MeshIndexData();\n", "    virtual ~MeshIndexData();\n", "    \n", "protected:\n", "    backend::Buffer*    _indexBuffer = nullptr; //index buffer\n", "    MeshVertexData*     _vertexData = nullptr; //vertex buffer, weak ref\n", "    AABB                _aabb; // original aabb of the submesh\n", "    std::string         _id; //id\n", "    MeshCommand::PrimitiveType   _primitiveType = MeshCommand::PrimitiveType::TRIANGLE;\n", "    MeshData::IndexArray _indexData;\n", "\n", "    friend class MeshVertexData;\n", "    friend class Sprite3D;\n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "    EventListenerCustom* _backToForegroundListener = nullptr;\n", "#endif\n", "};\n", "\n", "/**\n", " * the MeshVertexData class.\n", " * @brief the MeshVertexData contain all of the vertices data which mesh need.\n", " */\n"], "CCMeshVertexIndexData.cpp_cpp": ["#include <list>\n", "#include <fstream>\n", "#include <iostream>\n", "#include <sstream>\n", "\n", "#include \"3d/CCMeshVertexIndexData.h\"\n", "#include \"3d/CCObjLoader.h\"\n", "#include \"3d/CCSprite3DMaterial.h\"\n", "#include \"3d/CCMesh.h\"\n", "#include \"3d/CCBundle3D.h\"\n", "\n", "#include \"base/ccMacros.h\"\n", "#include \"base/CCEventCustom.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/backend/Buffer.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "\n", "\n", "using namespace std;\n", "\n", "NS_CC_BEGIN\n"], "CCMeshSkin.h_header": ["\n", "#include \"3d/CCBundle3DData.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"base/CCVector.h\"\n", "#include \"math/CCMath.h\"\n", "#include <vector>\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _3d\n", " * @{\n", " */\n", "\n", "class Bone3D;\n", "class Skeleton3D;\n", "\n", "/**\n", " * @brief MeshSkin, A class maintain a collection of bones that affect Mesh vertex.\n", " * And it is responsible for computing matrix palettes that used by skin mesh rendering.\n", " * @js NA\n", " * @lua NA\n", " */\n"], "CCMeshSkin.cpp_cpp": ["#include \"3d/CCMeshSkin.h\"\n", "#include \"3d/CCSkeleton3D.h\"\n", "#include \"3d/CCBundle3D.h\"\n", "#include \"3d/CCSkeleton3D.h\"\n", "\n", "NS_CC_BEGIN\n"], "ccUtils.cpp_cpp": ["#include \"base/ccUtils.h\"\n", "\n", "#include <cmath>\n", "#include <stdlib.h>\n", "#include \"md5/md5.h\"\n", "\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCAsyncTaskPool.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/base64.h\"\n", "#include \"base/ccConstants.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/backend/Types.h\"\n", "\n", "#include \"platform/CCImage.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"2d/CCSprite.h\"\n", "#include \"2d/CCRenderTexture.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCSprite3D.h_header": ["\n", "#include <unordered_map>\n", "\n", "#include \"base/CCVector.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"base/CCProtocols.h\"\n", "#include \"2d/CCNode.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"3d/CCSkeleton3D.h\" // need to include for lua-binding\n", "#include \"3d/CCAABB.h\"\n", "#include \"3d/CCBundle3DData.h\"\n", "#include \"3d/CCMeshVertexIndexData.h\"\n", "\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _3d\n", " * @{\n", " */\n", "\n", "class Mesh;\n", "class Texture2D;\n", "class MeshSkin;\n", "class AttachNode;\n", "\n", "struct NodeData;\n", "//\u52a0\u8f7d\u6a21\u578b\u6570\u636e\u56de\u8c03\u51fd\u6570\uff0c\u7ed9\u5916\u90e8\u4e2a\u64cd\u4f5c\u9876\u70b9\u6570\u636e\u7684\u65f6\u673a by sxy\n", "\n", "\n", "/** @brief Sprite3D: A sprite can be loaded from 3D model files, .obj, .c3t, .c3b, then can be drawed as sprite */\n", "class CC_DLL Sprite3D : public Node, public BlendProtocol\n", "{\n", "public:\n", "    void setPosition(const Vec2 &position);\n", "    void setPosition3D(const Vec3& position);\n", "    /**\n", "     * Creates an empty sprite3D without 3D model and texture.\n", "     *\n", "     * @return An autoreleased sprite3D object.\n", "     */\n", "    static Sprite3D* create();\n", "    \n", "    /** creates a Sprite3D*/\n", "   \n", "    static Sprite3D* create(const std::string &modelPath);\n", "  \n", "    // creates a Sprite3D. It only supports one texture, and overrides the internal texture with 'texturePath'\n", "    static Sprite3D* create(const std::string &modelPath, const std::string &texturePath);\n", "    \n", "    /** create 3d sprite asynchronously\n", "     * If the 3d model was previously loaded, it will create a new 3d sprite and the callback will be called at once.\n", "     * Otherwise it will load the model file in a new thread, and when the 3d sprite is loaded, the callback will be called with the created Sprite3D and a userdefined parameter.\n", "     * The callback will be called from the main thread, so it is safe to create any cocos2d object from the callback.\n", "     * @param modelPath model to be loaded\n", "     * @param callback callback after loading\n", "     * @param callbackparam user defined parameter for the callback\n", "     */\n", "    static void createAsync(const std::string &modelPath, const std::function<void(Sprite3D*, void*)>& callback, void* callbackparam);\n", "    \n", "    static void createAsync(const std::string &modelPath, const std::string &texturePath, const std::function<void(Sprite3D*, void*)>& callback, void* callbackparam);\n", "    \n", "    /**set texture, set the first if multiple textures exist*/\n", "    void setTexture(const std::string& texFile);\n", "    void setTexture(Texture2D* texture);\n", "    \n", "    /**get Mesh by index*/\n", "    Mesh* getMeshByIndex(int index) const;\n", "    \n", "    /**get Mesh by Name, it returns the first one if there are more than one mesh with the same name */\n", "    Mesh* getMeshByName(const std::string& name) const;\n", "    \n", "    /** \n", "     * get mesh array by name, returns all meshes with the given name\n", "     *\n", "     * @lua NA\n", "     */\n", "    std::vector<Mesh*> getMeshArrayByName(const std::string& name) const;\n", "\n", "    /**get mesh*/\n", "    Mesh* getMesh() const { return _meshes.at(0); }\n", "    \n", "    /** get mesh count */\n", "    ssize_t getMeshCount() const { return _meshes.size(); }\n", "    \n", "    /**get skin*/\n", "    CC_DEPRECATED_ATTRIBUTE MeshSkin* getSkin() const;\n", "    \n", "    Skeleton3D* getSkeleton() const { return _skeleton; }\n", "    \n", "    /**get AttachNode by bone name, return nullptr if not exist*/\n", "    AttachNode* getAttachNode(const std::string& boneName);\n", "    \n", "    /**remove attach node*/\n", "    void removeAttachNode(const std::string& boneName);\n", "    \n", "    /**remove all attach nodes*/\n", "    void removeAllAttachNode();\n", "\n", "    // overrides\n", "    virtual void setBlendFunc(const BlendFunc &blendFunc) override;\n", "    virtual const BlendFunc &getBlendFunc() const override;\n", "    \n", "    // overrides\n", "    /** set GLProgramState, you should bind attributes by yourself */\n", "    virtual void setGLProgramState(backend::ProgramState *glProgramState) override;\n", "    /** just rember bind attributes */\n", "    virtual void setGLProgram(backend::Program *glprogram) override;\n", "    \n", "    /*\n", "     * Get AABB\n", "     * If the sprite has animation, it can't be calculated accuratly,\n", "     * because bone can drive the vertices, we just use the origin vertices\n", "     * to calculate the AABB.\n", "     */\n", "    const AABB& getAABB() const;\n", "    \n", "    /* \n", "     * Get AABB Recursively\n", "     * Because some times we may have an empty Sprite3D Node as parent, but\n", "     * the Sprite3D don't contain any meshes, so getAABB()\n", "     * will return a wrong value at that time.\n", "     */\n", "    AABB getAABBRecursively();\n", "    \n", "    /**\n", "     * Executes an action, and returns the action that is executed. For Sprite3D special logic are needed to take care of Fading.\n", "     *\n", "     * This node becomes the action's target. Refer to Action::getTarget()\n", "     * @warning Actions don't retain their target.\n", "     *\n", "     * @return An Action pointer\n", "     */\n", "    virtual Action* runAction(Action* action) override;\n", "    \n", "    /**\n", "     * Force to write to depth buffer, this is useful if you want to achieve effects like fading.\n", "     */\n", "    void setForceDepthWrite(bool value) ;\n", "    bool isForceDepthWrite() const { return _forceDepthWrite;};\n", "    \n", "    //\n", "    inline void setDepthAwaysPass(bool pass)\n", "    {\n", "        _depthAwaysPass = pass;\n", "    }\n", "    \n", "    inline void setAlphaTest(bool alphaTest)\n", "    {\n", "        _alphaTest = alphaTest;\n", "    }\n", "    \n", "    /**\n", "     * Returns 2d bounding-box\n", "     * Note: the bouding-box is just get from the AABB which as Z=0, so that is not very accurate.\n", "     */\n", "    virtual Rect getBoundingBox() const override;\n", "\n", "    // set which face is going to cull, GL_BACK, GL_FRONT, GL_FRONT_AND_BACK, default GL_BACK\n", "    void setCullFace(GLenum cullFace);\n", "    // set cull face enable or not\n", "    void setCullFaceEnabled(bool enable);\n", "    \n", "    /** light mask getter & setter, light works only when _lightmask & light's flag is true, default value of _lightmask is 0xffff */\n", "    void setLightMask(unsigned int mask) { _lightMask = mask; }\n", "    unsigned int getLightMask() const { return _lightMask; }\n", "    \n", "    /**draw*/\n", "    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;\n", "\n", "    /** Adds a new material to the sprite.\n", "     The Material will be applied to all the meshes that belong to the sprite.\n", "     Internally it will call `setMaterial(material,-1)`\n", "     */\n", "    void setMaterial(Material* material);\n", "\n", "    /** Adds a new material to a particular mesh of the sprite.\n", "     meshIndex is the mesh that will be applied to.\n", "     if meshIndex == -1, then it will be applied to all the meshes that belong to the sprite.\n", "     */\n", "    void setMaterial(Material* material, int meshIndex);\n", "\n", "    /** Adds a new material to a particular mesh of the sprite.\n", "     meshIndex is the mesh that will be applied to.\n", "     if meshIndex == -1, then it will be applied to all the meshes that belong to the sprite.\n", "     */\n", "    Material* getMaterial(int meshIndex) const;\n", "    \n", "    /**\n", "    * force set this Sprite3D to 2D render queue\n", "    */\n", "    void setForce2DQueue(bool force2D);\n", "\n", "CC_CONSTRUCTOR_ACCESS:\n", "    \n", "    Sprite3D();\n", "    virtual ~Sprite3D();\n", "    \n", "    virtual bool init() override;\n", "    \n", "    virtual bool initWithFile(const std::string &path);\n", "    \n", "    virtual bool initFrom(const NodeDatas& nodedatas, const MeshDatas& meshdatas, const MaterialDatas& materialdatas);\n", "    \n", "    /**load sprite3d from cache, return true if succeed, false otherwise*/\n", "    bool loadFromCache(const std::string& path);\n", "    \n", "    /** load file and set it to meshedatas, nodedatas and materialdatas, obj file .mtl file should be at the same directory if exist */\n", "    bool loadFromFile(const std::string& path, NodeDatas* nodedatas, MeshDatas* meshdatas,  MaterialDatas* materialdatas);\n", "\n", "    /**\n", "     * Visits this Sprite3D's children and draw them recursively.\n", "     * Note: all its children will rendered as 3D objects\n", "     */\n", "    virtual void visit(Renderer *renderer, const Mat4& parentTransform, uint32_t parentFlags) override;\n", "    \n", "    /**generate default backend::ProgramState*/\n", "    void genGLProgramState(bool useLight = false, bool useAlphaTest = false);\n", "\n", "    void createNode(NodeData* nodedata, Node* root, const MaterialDatas& matrialdatas, bool singleSprite);\n", "    void createAttachSprite3DNode(NodeData* nodedata,const MaterialDatas& matrialdatas);\n", "    Sprite3D* createSprite3DNode(NodeData* nodedata,ModelData* modeldata,const MaterialDatas& matrialdatas);\n", "\n", "    /**get MeshIndexData by Id*/\n", "    MeshIndexData* getMeshIndexData(const std::string& indexId) const;\n", "    \n", "    void addMesh(Mesh* mesh);\n", "    \n", "    void onAABBDirty() { _aabbDirty = true; }\n", "    \n", "    void afterAsyncLoad(void* param);\n", "    \n", "    bool  getNodeVisible();\n", "    \n", "    inline bool getOptimal()\n", "    {\n", "        return _useOptimal;\n", "    }\n", "    \n", "    inline void setOptimal(bool optimal)\n", "    {\n", "        _useOptimal = optimal;\n", "    }\n", "    \n", "    inline bool getAlwaysUpdate()\n", "    {\n", "        return _alwaysUpdate;\n", "    }\n", "    \n", "    inline void setAlwaysUpdate(bool alwaysUpdate)\n", "    {\n", "        _alwaysUpdate = alwaysUpdate;\n", "    }\n", "    \n", "    inline bool getVisibleInScene()\n", "    {\n", "        return _visibleInScene;\n", "    }\n", "    \n", "protected:\n", "\n", "    Skeleton3D*                  _skeleton; //skeleton\n", "    \n", "    Vector<MeshVertexData*>      _meshVertexDatas;\n", "    \n", "    std::unordered_map<std::string, AttachNode*> _attachments;\n", "\n", "    BlendFunc                    _blend;\n", "    \n", "    Vector<Mesh*>              _meshes;\n", "\n", "    mutable AABB                 _aabb;                 // cache current aabb\n", "    mutable Mat4                 _nodeToWorldTransform; // cache the matrix\n", "    mutable bool                 _aabbDirty;\n", "    unsigned int                 _lightMask;\n", "    bool                         _shaderUsingLight; // is current shader using light ?\n", "    bool                         _forceDepthWrite; // Always write to depth buffer\n", "    bool                         _usingAutogeneratedGLProgram;\n", "    bool                         _depthAwaysPass;\n", "    bool                         _alphaTest;\n", "    bool                         _shaderAlphaTest;\n", "    \n", "    struct AsyncLoadParam\n", "    {\n", "        std::function<void(Sprite3D*, void*)> afterLoadCallback; // callback after load\n", "        void*                           callbackParam;\n", "        bool                            result; // sprite load result\n", "        std::string                     modlePath;\n", "        std::string                     texPath; //\n", "        MeshDatas* meshdatas;\n", "        MaterialDatas* materialdatas;\n", "        NodeDatas*   nodeDatas;\n", "    };\n", "    AsyncLoadParam             _asyncLoadParam;\n", "    \n", "    bool _useOptimal;\n", "    bool _alwaysUpdate;\n", "    bool _visibleInScene;\n", "};\n", "\n", "///////////////////////////////////////////////////////\n", "/**\n", " * Sprite3DCache\n", " * @brief the cache data of Sprite3D, use to speed up Sprite3D::create\n", " */\n"], "CCSprite3D.cpp_cpp": ["#include \"3d/CCSprite3D.h\"\n", "#include \"3d/CCObjLoader.h\"\n", "#include \"3d/CCMeshSkin.h\"\n", "#include \"3d/CCBundle3D.h\"\n", "#include \"3d/CCSprite3DMaterial.h\"\n", "#include \"3d/CCAttachNode.h\"\n", "#include \"3d/CCMesh.h\"\n", "\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCAsyncTaskPool.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"2d/CCLight.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"renderer/CCGLProgramCache.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCPass.h\"\n", "\n", "#include \"deprecated/CCString.h\" // For StringUtils::format\n", "#include <algorithm>\n", "NS_CC_BEGIN\n"], "Sprite3D::createSprite3DNode-NodeData*-ModelData*-MaterialDatas&": ["Sprite3D* Sprite3D::createSprite3DNode(NodeData* nodedata,ModelData* modeldata,const MaterialDatas& materialdatas)\n", "{\n", "    auto sprite = new (std::nothrow) Sprite3D();\n", "    if (sprite)\n", "    {\n", "        sprite->setName(nodedata->id);\n", "        auto mesh = Mesh::create(nodedata->id, getMeshIndexData(modeldata->subMeshId));\n", "        \n", "        if (_skeleton && modeldata->bones.size())\n", "        {\n", "            auto skin = MeshSkin::create(_skeleton, modeldata->bones, modeldata->invBindPose);\n", "            mesh->setSkin(skin);\n", "        }\n", "        \n", "        if (modeldata->materialId == \"\" && materialdatas.materials.size())\n", "        {\n", "            const NTextureData* textureData = materialdatas.materials[0].getTextureData(NTextureData::Usage::Diffuse);\n", "            mesh->setTexture(textureData->filename);\n", "        }\n", "        else\n", "        {\n", "            const NMaterialData* materialData = materialdatas.getMaterialData(modeldata->materialId);\n", "            if(materialData)\n", "            {\n", "                const NTextureData* textureData = materialData->getTextureData(NTextureData::Usage::Diffuse);\n", "                if(textureData)\n", "                {\n", "                    mesh->setTexture(textureData->filename);\n", "                    auto tex = mesh->getTexture();\n", "                    if(tex)\n", "                    {\n", "                        Texture2D::TexParams texParams;\n", "                        texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "                        texParams.magFilter = backend::SamplerFilter::LINEAR;\n", "                        texParams.sAddressMode = textureData->wrapS;\n", "                        texParams.tAddressMode = textureData->wrapT;\n", "                        tex->setTexParameters(texParams);\n", "                        mesh->_isTransparent = (materialData->getTextureData(NTextureData::Usage::Transparency) != nullptr);\n", "                    }\n", "                }\n", "                textureData = materialData->getTextureData(NTextureData::Usage::Normal);\n", "                if (textureData)\n", "                {\n", "                    auto tex = Director::getInstance()->getTextureCache()->addImage(textureData->filename);\n", "                    if(tex)\n", "                    {\n", "                        Texture2D::TexParams texParams;\n", "                        texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "                        texParams.magFilter = backend::SamplerFilter::LINEAR;\n", "                        texParams.sAddressMode = textureData->wrapS;\n", "                        texParams.tAddressMode = textureData->wrapT;\n", "                        tex->setTexParameters(texParams);\n", "                    }\n", "                    mesh->setTexture(tex, NTextureData::Usage::Normal);\n", "                }\n", "            }\n", "        }\n", "\n", "        // set locale transform\n", "        Vec3 pos;\n", "        Quaternion qua;\n", "        Vec3 scale;\n", "        nodedata->transform.decompose(&scale, &qua, &pos);\n", "        sprite->setPosition3D(pos);\n", "        sprite->setRotationQuat(qua);\n", "        sprite->setScaleX(scale.x);\n", "        sprite->setScaleY(scale.y);\n", "        sprite->setScaleZ(scale.z);\n", "        \n", "        sprite->addMesh(mesh);\n", "        sprite->autorelease();\n", "        sprite->genMaterial();\n", "    }\n", "    return   sprite;\n", "}\n"], "Sprite3D::draw-Renderer*-Mat4&-uint32_t": ["void Sprite3D::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)\n", "{\n", "#if CC_USE_CULLING\n", "    //TODO new-renderer: interface isVisibleInFrustum removal\n", "    // camera clipping\n", "//    if(_children.size() == 0 && Camera::getVisitingCamera() && !Camera::getVisitingCamera()->isVisibleInFrustum(&getAABB()))\n", "//        return;\n", "#endif\n", "    \n", "    if (_skeleton)\n", "        _skeleton->updateBoneMatrix();\n", "    \n", "    Color4F color(getDisplayedColor());\n", "    color.a = getDisplayedOpacity() / 255.0f;\n", "    \n", "    //check light and determine the shader used\n", "    const auto& scene = Director::getInstance()->getRunningScene();\n", "\n", "    // Don't override GLProgramState if using manually set Material\n", "    if (_usingAutogeneratedGLProgram && scene)\n", "    {\n", "        const auto lights = scene->getLights();\n", "        bool usingLight = false;\n", "        for (const auto light : lights) {\n", "            usingLight = light->isEnabled() && ((static_cast<unsigned int>(light->getLightFlag()) & _lightMask) > 0);\n", "            if (usingLight)\n", "                break;\n", "        }\n", "        if (usingLight != _shaderUsingLight)\n", "        {\n", "            genMaterial(usingLight);\n", "        }\n", "    }\n", "    \n", "    for (auto mesh: _meshes)\n", "    {\n", "        mesh->draw(renderer,\n", "                   _globalZOrder,\n", "                   transform,\n", "                   flags,\n", "                   _lightMask,\n", "                   Vec4(color.r, color.g, color.b, color.a),\n", "                   _forceDepthWrite);\n", "\n", "    }\n", "}\n"], "CCSprite3DMaterial.h_header": ["\n", "#include <string>\n", "#include <unordered_map>\n", "#include \"base/ccTypes.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"3d/CCBundle3DData.h\"\n", "#include \"renderer/backend/Types.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _3d\n", " * @{\n", " */\n", "\n", "class Texture2D;\n", "\n", "namespace backend\n", "{\n", "    class ProgramState;\n", "}\n", "\n", "/**\n", " * @brief the sprite3D material is only texture for now\n", " * @js NA\n", " * @lua NA\n", " */\n"], "CCSprite3DMaterial.cpp_cpp": ["#include \"3d/CCSprite3DMaterial.h\"\n", "#include \"3d/CCMesh.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/CCPass.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCBundle3D.h_header": ["\n", "#include \"base/CCData.h\"\n", "#include \"3d/CCBundle3DData.h\"\n", "#include \"3d/CCBundleReader.h\"\n", "#include \"json/document.h\"\n", "#include \"json/document-wrapper.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _3d\n", " * @{\n", " */\n", "\n", "class Animation3D;\n", "class Data;\n", "\n", "/**\n", " * @brief Defines a bundle file that contains a collection of assets. Mesh, Material, MeshSkin, Animation\n", " * There are two types of bundle files, c3t and c3b.\n", " * c3t text file\n", " * c3b binary file\n", " * @js NA\n", " * @lua NA\n", " */\n"], "CCBundle3D.cpp_cpp": ["#include \"3d/CCBundle3D.h\"\n", "#include \"3d/CCObjLoader.h\"\n", "\n", "#include \"base/ccMacros.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"3d/CCBundleReader.h\"\n", "#include \"base/CCData.h\"\n", "#include \"json/document.h\"\n", "\n", "#define BUNDLE_TYPE_SCENE               1\n", "#define BUNDLE_TYPE_NODE                2\n", "#define BUNDLE_TYPE_ANIMATIONS          3\n", "#define BUNDLE_TYPE_ANIMATION           4\n", "#define BUNDLE_TYPE_ANIMATION_CHANNEL   5\n", "#define BUNDLE_TYPE_MODEL               10\n", "#define BUNDLE_TYPE_MATERIAL            16\n", "#define BUNDLE_TYPE_EFFECT              18\n", "#define BUNDLE_TYPE_CAMERA              32\n", "#define BUNDLE_TYPE_LIGHT               33\n", "#define BUNDLE_TYPE_MESH                34\n", "#define BUNDLE_TYPE_MESHPART            35\n", "#define BUNDLE_TYPE_MESHSKIN            36\n", "\n", "static const char* VERSION = \"version\";\n", "static const char* ID = \"id\";\n", "static const char* DEFAULTPART = \"body\";\n", "static const char* VERTEXSIZE = \"vertexsize\";\n", "static const char* VERTEX = \"vertex\";\n", "static const char* VERTICES = \"vertices\";\n", "static const char* INDEXNUM = \"indexnum\";\n", "static const char* INDICES = \"indices\";\n", "static const char* SUBMESH = \"submesh\";\n", "static const char* ATTRIBUTES = \"attributes\";\n", "static const char* ATTRIBUTESIZE = \"size\";\n", "static const char* TYPE = \"type\";\n", "static const char* ATTRIBUTE = \"attribute\";\n", "static const char* SKIN = \"skin\";\n", "static const char* BINDSHAPE = \"bindshape\";\n", "static const char* MESH = \"mesh\";\n", "static const char* MESHES = \"meshes\";\n", "static const char* MESHPARTID = \"meshpartid\";\n", "static const char* MATERIALID = \"materialid\";\n", "static const char* NODE = \"node\";\n", "static const char* NODES = \"nodes\";\n", "static const char* CHILDREN = \"children\";\n", "static const char* PARTS = \"parts\";\n", "static const char* BONES = \"bones\";\n", "static const char* SKELETON = \"skeleton\";\n", "static const char* MATERIALS = \"materials\";\n", "static const char* ANIMATIONS = \"animations\";\n", "static const char* TRANSFORM = \"transform\";\n", "static const char* OLDTRANSFORM = \"tansform\";\n", "static const char* ANIMATION = \"animation\";\n", "static const char* MATERIAL = \"material\";\n", "static const char* BASE = \"base\";\n", "static const char* FILENAME = \"filename\";\n", "static const char* TEXTURES = \"textures\";\n", "static const char* LENGTH =   \"length\";\n", "static const char* BONEID  = \"boneId\";\n", "static const char* KEYFRAMES  = \"keyframes\";\n", "static const char* TRANSLATION =  \"translation\";\n", "static const char* ROTATION =  \"rotation\";\n", "static const char* SCALE =  \"scale\";\n", "static const char* KEYTIME =  \"keytime\";\n", "static const char* AABBS = \"aabb\";\n", "\n", "\n", "bool IsExistCompressFile(const char* fileName);\n", "bool GetCompressFileData(const char* fileNameNo_Z,unsigned char*& outMemory,ssize_t& outMemoryLen);\n", "\n", "NS_CC_BEGIN\n"], "Bundle3D::loadBinary-std::string&": ["bool Bundle3D::loadBinary(const std::string& path)\n", "{\n", "    clear();\n", "    \n", "    // get file data\n", "    _binaryBuffer.clear();\n", "    _binaryBuffer = FileUtils::getInstance()->getDataFromFile(path);\n", "    if (_binaryBuffer.isNull())\n", "    {\n", "        clear();\n", "        CCLOG(\"warning: Failed to read file: %s\", path.c_str());\n", "        return false;\n", "    }\n", "    \n", "    // Initialise bundle reader\n", "    _binaryReader.init( (char*)_binaryBuffer.getBytes(),  _binaryBuffer.getSize() );\n", "    \n", "    // Read identifier info\n", "    char identifier[] = { 'C', '3', 'B', '\\0'};\n", "    char sig[4];\n", "    if (_binaryReader.read(sig, 1, 4) != 4 || memcmp(sig, identifier, 4) != 0)\n", "    {\n", "        clear();\n", "        CCLOG(\"warning: Invalid identifier: %s\", path.c_str());\n", "        return false;\n", "    }\n", "    \n", "    // Read version\n", "    unsigned char ver[2];\n", "    if (_binaryReader.read(ver, 1, 2)!= 2){\n", "        CCLOG(\"warning: Failed to read version:\");\n", "        return false;\n", "    }\n", "    \n", "    char version[20] = {0};\n", "    sprintf(version, \"%d.%d\", ver[0], ver[1]);\n", "    _version = version;\n", "    \n", "    // Read ref table size\n", "    if (_binaryReader.read(&_referenceCount, 4, 1) != 1)\n", "    {\n", "        clear();\n", "        CCLOG(\"warning: Failed to read ref table size '%s'.\", path.c_str());\n", "        return false;\n", "    }\n", "    \n", "    // Read all refs\n", "    CC_SAFE_DELETE_ARRAY(_references);\n", "    _references = new (std::nothrow) Reference[_referenceCount];\n", "    for (unsigned int i = 0; i < _referenceCount; ++i)\n", "    {\n", "        if ((_references[i].id = _binaryReader.readString()).empty() ||\n", "            _binaryReader.read(&_references[i].type, 4, 1) != 1 ||\n", "            _binaryReader.read(&_references[i].offset, 4, 1) != 1)\n", "        {\n", "            clear();\n", "            CCLOG(\"warning: Failed to read ref number %u for bundle '%s'.\", i, path.c_str());\n", "            CC_SAFE_DELETE_ARRAY(_references);\n", "            return false;\n", "        }\n", "    }\n", "    \n", "    return true;\n", "}\n"], "CCDrawNode.h_header": ["\n", "#include \"2d/CCNode.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"math/CCMath.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "static const int DEFAULT_LINE_WIDTH = 2;\n", "\n", "class PointArray;\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/** @class DrawNode\n", " * @brief Node that draws dots, segments and polygons.\n", " * Faster than the \"drawing primitives\" since they draws everything in one single batch.\n", " * @since v2.1\n", " */\n"], "CCDrawNode.cpp_cpp": [" * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n", " *\n", " * Permission is hereby granted, free of charge, to any person obtaining a copy\n", " * of this software and associated documentation files (the \"Software\"), to deal\n", " * in the Software without restriction, including without limitation the rights\n", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n", " * copies of the Software, and to permit persons to whom the Software is\n", " * furnished to do so, subject to the following conditions:\n", " *\n", " * The above copyright notice and this permission notice shall be included in\n", " * all copies or substantial portions of the Software.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n", " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n", " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n", " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n", " * SOFTWARE.\n", " */\n", "\n", "#include \"2d/CCDrawNode.h\"\n", "#include <stddef.h> // offsetof\n", "#include \"base/ccTypes.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"2d/CCActionCatmullRom.h\"\n", "#include \"platform/CCGL.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "\n", "NS_CC_BEGIN\n"], "DrawNode::init": ["bool DrawNode::init()\n", "{\n", "    _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;\n", "    updateShader();\n", "    ensureCapacity(512);\n", "    ensureCapacityGLPoint(64);\n", "    ensureCapacityGLLine(256);\n", "    \n", "    _dirty = true;\n", "    _dirtyGLLine = true;\n", "    _dirtyGLPoint = true;\n", "    return true;\n", "}\n"], "CCGrid.h_header": ["\n", "#include \"base/CCRef.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCCallbackCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Texture2D;\n", "// class Grabber;\n", "// class GLProgram;\n", "class Node;\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/** Base class for Other grid.\n", "*/\n", "class CC_DLL GridBase : public Ref\n", "{\n", "public:\n", "    /**\n", "    Destructor.\n", "     * @js NA\n", "     * @lua NA\n", "     */\n", "    virtual ~GridBase();\n", "\n", "    /**@{\n", "     Interface for custom action when before or after draw.\n", "     @js NA\n", "     */\n", "    virtual void beforeBlit() {}\n", "    virtual void afterBlit() {}\n", "    /**@}*/\n", "\n", "    /**Interface used to blit the texture with grid to screen.*/\n", "    virtual void blit() = 0;\n", "    /**Interface, Reuse the grid vertices.*/\n", "    virtual void reuse() = 0;\n", "    /**Interface, Calculate the vertices used for the blit.*/\n", "    virtual void calculateVertexPoints() = 0;\n", "\n", "    /**@{\n", "     Init the Grid base.\n", "     @param gridSize the size of the grid.\n", "     @param texture The texture used for grab.\n", "     @param flipped whether or not the grab texture should be flip by Y or not.\n", "     @param rect The effective grid rect.\n", "    */\n", "    bool initWithSize(const Size& gridSize);\n", "    bool initWithSize(const Size& gridSize, const Rect& rect);\n", "    bool initWithSize(const Size& gridSize, Texture2D *texture, bool flipped);\n", "    bool initWithSize(const Size& gridSize, Texture2D *texture, bool flipped, const Rect& rect);\n", "\n", "    /**@}*/\n", "    /** @{\n", "    Getter and setter of the active state of the grid.\n", "    */\n", "    inline bool isActive(void) const { return _active; }\n", "    void setActive(bool active);\n", "    /**@}*/\n", "\n", "    /** Get number of times that the grid will be reused. */\n", "    inline int getReuseGrid(void) const { return _reuseGrid; }\n", "    /** Set number of times that the grid will be reused. */\n", "    inline void setReuseGrid(int reuseGrid) { _reuseGrid = reuseGrid; }\n", "\n", "    /** Size of the grid. */\n", "    inline const Size& getGridSize(void) const { return _gridSize; }\n", "    /**Set the size of the grid.*/\n", "    inline void setGridSize(const Size& gridSize) { _gridSize = gridSize; }\n", "\n", "    /** Pixels between the grids. */\n", "    inline const Vec2& getStep(void) const { return _step; }\n", "    /**Get the pixels between the grids.*/\n", "    inline void setStep(const Vec2& step) { _step = step; }\n", "\n", "    /** is texture flipped. */\n", "    inline bool isTextureFlipped(void) const { return _isTextureFlipped; }\n", "    /**Set the texture flipped or not.*/\n", "    void setTextureFlipped(bool flipped);\n", "    \n", "    /**@{\n", "     Init and reset the status when render effects by using the grid.\n", "     */\n", "    void beforeDraw(void);\n", "    void afterDraw(Node *target);\n", "    /**@}*/\n", "    \n", "    /**@{\n", "     Interface for custom action when before or after draw.\n", "     @js NA\n", "     */\n", "    virtual void beforeBlit() {}\n", "    virtual void afterBlit() {}\n", "    /**@}*/\n", "    \n", "    /**Interface used to blit the texture with grid to screen.*/\n", "    virtual void blit(void);\n", "    /**Interface, Reuse the grid vertices.*/\n", "    virtual void reuse(void);\n", "    /**Interface, Calculate the vertices used for the blit.*/\n", "    virtual void calculateVertexPoints(void);\n", "    \n", "    /**Change projection to 2D for grabbing.*/\n", "    void set2DProjection(void);\n", "\n", "protected:\n", "    bool _active;\n", "    int  _reuseGrid;\n", "    Size _gridSize;\n", "    Texture2D *_texture;\n", "    Vec2 _step;\n", "    Grabber *_grabber;\n", "    bool _isTextureFlipped;\n", "    backend::Program* _shaderProgram;\n", "    Director::Projection _directorProjection;\n", "};\n", "\n", "/**\n", " Grid3D is a 3D grid implementation. Each vertex has 3 dimensions: x,y,z\n", " */\n", "class CC_DLL Grid3D : public GridBase\n", "{\n", "public:\n", "    /** create one Grid. */\n", "    static Grid3D* create(const Size& gridSize, Texture2D *texture, bool flipped);\n", "    /** create one Grid. */\n", "    static Grid3D* create(const Size& gridSize);\n", "    /**\n", "     Constructor.\n", "     * @js ctor\n", "     */\n", "    Grid3D();\n", "    /**\n", "     Destructor.\n", "     * @js NA\n", "     * @lua NA\n", "     */\n", "    ~Grid3D(void);\n", "\n", "    /** Returns the vertex at a given position.\n", "     * @js NA\n", "     * @lua NA\n", "     */\n", "    Vec3 getVertex(const Vec2& pos) const;\n", "    /** @deprecated Use getVertex() instead \n", "     * @lua NA\n", "     */\n", "    CC_DEPRECATED_ATTRIBUTE Vec3 vertex(const Vec2& pos) const { return getVertex(pos); }\n", "    /** Returns the original (non-transformed) vertex at a given position.\n", "     * @js NA\n", "     * @lua NA\n", "     */\n", "    Vec3 getOriginalVertex(const Vec2& pos) const;\n", "    /** @deprecated Use getOriginalVertex() instead \n", "     * @lua NA\n", "     */\n", "    CC_DEPRECATED_ATTRIBUTE Vec3 originalVertex(const Vec2& pos) const { return getOriginalVertex(pos); }\n", "\n", "    /** Sets a new vertex at a given position.\n", "     * @lua NA\n", "     */\n", "    void setVertex(const Vec2& pos, const Vec3& vertex);\n", "    /**@{\n", "     Implementations for interfaces in base calss.\n", "     */\n", "    virtual void beforeBlit() override;\n", "    virtual void afterBlit() override;\n", "    virtual void blit() override;\n", "    virtual void reuse() override;\n", "    virtual void calculateVertexPoints() override;\n", "    /**@}*/\n", "    \n", "    /**@{\n", "     Getter and Setter for depth test state when blit.\n", "     @js NA\n", "     */\n", "    void setNeedDepthTestForBlit( bool neededDepthTest) { _needDepthTestForBlit = neededDepthTest; }\n", "    bool getNeedDepthTestForBlit() const { return _needDepthTestForBlit; }\n", "    /**@}*/\n", "protected:\n", "    GLvoid *_texCoordinates;\n", "    GLvoid *_vertices;\n", "    GLvoid *_originalVertices;\n", "    GLushort *_indices;\n", "    bool _needDepthTestForBlit;\n", "    bool _oldDepthTestValue;\n", "    bool _oldDepthWriteValue;\n", "};\n", "\n", "/**\n", " TiledGrid3D is a 3D grid implementation. It differs from Grid3D in that\n", " the tiles can be separated from the grid.\n", "*/\n"], "CCGrid.cpp_cpp": ["\n", "#include \"base/ccMacros.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"2d/CCNode.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"2d/CCCamera.h\"\n", "\n", "\n", "NS_CC_BEGIN\n"], "GridBase::initWithSize-Size&-Texture2D*-bool": ["bool GridBase::initWithSize(const Size& gridSize, Texture2D *texture, bool flipped)\n", "{\n", "    return initWithSize(gridSize, texture, flipped, Rect::ZERO);\n", "}\n"], "GridBase::initWithSize-Size&": ["bool GridBase::initWithSize(const Size& gridSize)\n", "{\n", "    return initWithSize(gridSize, Rect::ZERO);\n", "}\n"], "CCDirector.cpp_cpp": ["// cocos2d includes\n", "#include \"base/CCDirector.h\"\n", "\n", "// standard includes\n", "#include <string>\n", "\n", "#include \"2d/CCDrawingPrimitives.h\"\n", "#include \"2d/CCSpriteFrameCache.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "\n", "#include \"2d/CCActionManager.h\"\n", "#include \"2d/CCFontFNT.h\"\n", "#include \"2d/CCFontAtlasCache.h\"\n", "#include \"2d/CCAnimationCache.h\"\n", "#include \"2d/CCTransition.h\"\n", "#include \"2d/CCFontFreeType.h\"\n", "#include \"2d/CCLabelAtlas.h\"\n", "#include \"renderer/CCGLProgramCache.h\"\n", "#include \"renderer/CCGLProgramStateCache.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/CCFrameBuffer.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"base/CCUserDefault.h\"\n", "#include \"base/ccFPSImages.h\"\n", "#include \"base/CCScheduler.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventCustom.h\"\n", "#include \"base/CCConsole.h\"\n", "#include \"base/CCAutoreleasePool.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCAsyncTaskPool.h\"\n", "#include \"platform/CCApplication.h\"\n", "#include \"IFCircularReferenceMemoryRecovery.h\"\n", "#include \"base/CCParallelUpdate.h\"\n", "\n", "//#include \"editor-support/spine/AnimationState.h\"\n", "//#include \"platform/CCGLViewImpl.h\"\n", "#include \"platform/CCPThread.h\"   //modify by elex\n", "#if CC_ENABLE_SCRIPT_BINDING\n", "#include \"CCScriptSupport.h\"\n", "#endif\n", "\n", "#if ((CC_TARGET_PLATFORM == CC_PLATFORM_WINRT) || (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32))\n", "#include <windows.h>\n", "#else\n", "#include <unistd.h>\n", "#endif\n", "extern   bool g_bQuitGame ;\n", "void IFReceiveMemoryWarning(bool isReleaseAll);\n", "extern bool IF_isLowMemory();\n", "\n", "size_t g_nodeCount=0;\n", "size_t g_allMemoryBits = 0;\n", "size_t g_allRefMemoryBits = 0;\n", "int  g_refCount=0;\n", "// \u6bcf\u79d2\u5e27\u7387FPS\n", "// \u7701\u7535\u6a21\u5f0f - \u6162FPS\n", "const double g_slowFPS = 30.0f;\n", "// \u5febFPS\n", "const double g_fastFPS = 60.0f;\n", "\n", "void MemoryRecovery(float ftime)\n", "{\n", "    IFCircularReferenceMemoryRecovery::GetInstance()->MemoryRecovery(ftime);\n", "    \n", "}\n", "// #include \"AssetsManagerEx.h\"\n", "/**\n", " Position of the FPS\n", " \n", " Default: 0,0 (bottom-left corner)\n", " */\n", "#ifndef CC_DIRECTOR_STATS_POSITION\n", "#define CC_DIRECTOR_STATS_POSITION Director::getInstance()->getVisibleOrigin()\n", "#endif // CC_DIRECTOR_STATS_POSITION\n", "void MemoryRecovery(float ftime);\n", "using namespace std;\n", "static cocos2d::NodeManager *s_SharedNodeManager = nullptr;\n", "cocos2d::NodeManager* cocos2d::NodeManager::getInstance()\n", "{\n", "    if (!s_SharedNodeManager)\n", "    {\n", "        s_SharedNodeManager = new (std::nothrow) NodeManager();\n", "        CCASSERT(s_SharedNodeManager, \"FATAL: Not enough memory\");\n", "        s_SharedNodeManager->init();\n", "    }\n", "    \n", "    return s_SharedNodeManager;\n", "}\n", "\n", "bool cocos2d::NodeManager::init(void)\n", "{\n", "    return true;\n", "}\n", "\n", "cocos2d::NodeManager::NodeManager(void)\n", "{\n", "}\n", "\n", "cocos2d::NodeManager::~NodeManager(void)\n", "{\n", "    _stringMap.clear();\n", "    _guidNodeMap.clear();\n", "}\n", "\n", "cocos2d::Node * cocos2d::NodeManager::getNodeFromName(const std::string& name)\n", "{\n", "    return nullptr;\n", "}\n", "\n", "void cocos2d::NodeManager::addNode(Node * node)\n", "{\n", "\n", "}\n", "void cocos2d::NodeManager::removeNode(Node * node)\n", "{\n", "\n", "}\n", "\n", "int cocos2d::Autolock::st_num = 0;\n", "NS_CC_BEGIN\n"], "Director::init": ["bool Director::init(void)\n", "{\n", "    int ret;\n", "    if(( ret = pthread_mutexattr_init(&g_platmMutexAttr)) != 0){\n", "        CCAssert(0, \"pthread_mutexattr_init FAIL\");\n", "    }\n", "    \n", "    pthread_mutexattr_settype(&g_platmMutexAttr, PTHREAD_MUTEX_RECURSIVE);\n", "    pthread_mutex_init(&g_platmMutex, &g_platmMutexAttr);\n", "    pthread_mutex_init(&g_user_Mutex, &g_platmMutexAttr);\n", "    \n", "    cocos2d::Autolock::st_num = 1;\n", "    setDefaultValues();\n", "    m_visitFlag = true;   //modify by elex\n", "    // scenes\n", "    _runningScene = nullptr;\n", "    _nextScene = nullptr;\n", "\n", "    _notificationNode = nullptr;\n", "\n", "    _scenesStack.reserve(15);\n", "\n", "    // FPS\n", "    _accumDt = 0.0f;\n", "    _frameRate = 0.0f;\n", "    //lixu 20160120\n", "    _textureCacheInfoLabel = nullptr;\n", "    _GLErrorLabel = nullptr;\n", "    _GameStatusLabel = nullptr;\n", "    _NetWorkStatusLabel = nullptr;\n", "    _spAniamtionLabel = nullptr;\n", "    _cityInfoLabel= nullptr;\n", "    _popupViewLabel = nullptr;\n", "    _memoryLeakLabel = nullptr;\n", "    _plistLabel = nullptr;\n", "    \n", "    _popupViewCount = 0;\n", "    _plistCount = 0;\n", "    _spAnimationCount = 0;\n", "    _infoCount = 0;\n", "    _resourceCount = 0;\n", "    _spriteCount=0;\n", "    _spriteFrameCount=0;\n", "    _labelIFTTFCount=0;\n", "    _spineScreenCount = 0;\n", "  \n", " \n", "    _FPSLabel = _drawnBatchesLabel = _drawnVerticesLabel = nullptr;\n", "    _totalFrames = 0;\n", "    _lastUpdate = new struct timeval;\n", "    _secondsPerFrame = 1.0f;\n", "\n", "    // paused ?\n", "    _paused = false;\n", "\n", "    // purge ?\n", "    _purgeDirectorInNextLoop = false;\n", "    \n", "    // restart ?\n", "    _restartDirectorInNextLoop = false;\n", "\n", "    _winSizeInPoints = Size::ZERO;\n", "\n", "    _openGLView = nullptr;\n", "    _defaultFBO = nullptr;\n", "    \n", "    _contentScaleFactor = 1.0f;\n", "    \n", "    gettimeofday(&m_lastAutoReleaseTime, nullptr);\n", "    \n", "    _console = new (std::nothrow) Console;\n", "\n", "    // scheduler\n", "    _scheduler = new (std::nothrow) Scheduler();\n", "    // action manager\n", "    _actionManager = new (std::nothrow) ActionManager();\n", "    \n", "    _scheduler->scheduleUpdate(_actionManager, Scheduler::PRIORITY_SYSTEM, false);\n", "\n", "    _eventDispatcher = new (std::nothrow) EventDispatcher();\n", "    \n", "    _beforeSetNextScene = new (std::nothrow) EventCustom(EVENT_BEFORE_SET_NEXT_SCENE);\n", "    _beforeSetNextScene->setUserData(this);\n", "    _afterSetNextScene = new (std::nothrow) EventCustom(EVENT_AFTER_SET_NEXT_SCENE);\n", "    _afterSetNextScene->setUserData(this);\n", "    _eventAfterDraw = new (std::nothrow) EventCustom(EVENT_AFTER_DRAW);\n", "    _eventAfterDraw->setUserData(this);\n", "    _eventBeforeDraw = new (std::nothrow) EventCustom(EVENT_BEFORE_DRAW);\n", "    _eventBeforeDraw->setUserData(this);\n", "    _eventAfterVisit = new (std::nothrow) EventCustom(EVENT_AFTER_VISIT);\n", "    _eventAfterVisit->setUserData(this);\n", "    _eventBeforeUpdate = new (std::nothrow) EventCustom(EVENT_BEFORE_UPDATE);\n", "    _eventBeforeUpdate->setUserData(this);\n", "    _eventAfterUpdate = new (std::nothrow) EventCustom(EVENT_AFTER_UPDATE);\n", "    _eventAfterUpdate->setUserData(this);\n", "    _eventProjectionChanged = new (std::nothrow) EventCustom(EVENT_PROJECTION_CHANGED);\n", "    _eventProjectionChanged->setUserData(this);\n", "    _eventResetDirector = new (std::nothrow) EventCustom(EVENT_RESET);\n", "    //init TextureCache\n", "    initTextureCache();\n", "    initMatrixStack();\n", "\n", "    _renderer = new (std::nothrow) Renderer;\n", "    //\u8fd9\u4e9b\u7ba1\u7406\u5668\u7c7b\u90fd\u4e0d\u5220\u9664\uff0c\u5230\u65f6\u628anode\u4e2d\u5b58\u7684\u53d8\u91cf\u53bb\u6389 by sxy\n", "    _eventDispatcher->setReferenceMax();\n", "    _actionManager->setReferenceMax();\n", "    _scheduler->setReferenceMax();\n", "    this->setReferenceMax();\n", "    \n", "    RenderState::initialize();\n", "\n", "    return true;\n", "}\n"], "Director::showStats": ["void Director::showStats()\n", "{\n", "    if (_isStatusLabelUpdated)\n", "    {\n", "        createStatsLabel();\n", "        _isStatusLabelUpdated = false;\n", "    }\n", "    \n", "    static unsigned long prevCalls = 0;\n", "    static unsigned long prevVerts = 0;\n", "    static float prevDeltaTime  = m_iMicroSecPerFrame / 1000.0f;\n", "    static const float FPS_FILTER = 0.10f;\n", "\n", "    ++_frames;\n", "    _accumDt += m_deltaTime;\n", "    \n", "    if (_displayStats && _FPSLabel && _drawnBatchesLabel && _drawnVerticesLabel&&_textureCacheInfoLabel&&_GLErrorLabel&&_GameStatusLabel&&_NetWorkStatusLabel&&_spAniamtionLabel&&_cityInfoLabel&&_popupViewLabel && _plistLabel)\n", "    {\n", "        char buffer[65535];\n", "        \n", "        float dt = m_deltaTime * FPS_FILTER + (1-FPS_FILTER) * prevDeltaTime;\n", "        prevDeltaTime = dt;\n", "        _frameRate = 1/dt;\n", "          \n", "        char xxx[512];\n", "        sprintf(xxx,\"ptc allSystem:%d showSystemCount:%d ptcCount:%d\",\n", "                ParticleSystem::allSystemCount,     // \u7279\u6548\u603b\u6570\n", "                ParticleSystem::showSystemCount,    // \u663e\u793a\u7279\u6548\u5b50\u6570\n", "                ParticleSystem::showPtcCount);      // \u7c92\u5b50\u7ed8\u5236\u603b\u6570\n", " \n", "        _GameStatusLabel->setString(xxx);\n", "\n", "        if(!_networkStatusString.empty())\n", "        {\n", "            _NetWorkStatusLabel->setString(_networkStatusString);\n", "        }\n", "        setSpAnimationString(StringUtils::format(\"CCNode:%d Safe:%d Ref:%d Mem:%.1f/%.1f\",\n", "                                                 (int)g_nodeCount,          // ccnode\u603b\u6570\n", "                                                 (int)g_safeNodeCountTemp,  // SafeObject\u603b\u6570\n", "                                                 g_refCount,                // Ref\u603b\u6570\n", "                                                 (float)g_allRefMemoryBits / 1024.0f / 1024.0f,\n", "                                                 (float)g_allMemoryBits / 1024.0f / 1024.0f ));\n", "        if(!_spAnimationString.empty())\n", "        {\n", "            _spAniamtionLabel->setString(_spAnimationString);\n", "        }\n", "        setCityInfoString(StringUtils::format(\"City count:%lu\",\n", "                                              _infoCount));       // \u5730\u56fe\u57ce\u5e02\u6570\u91cf\n", "        if(!_cityString.empty())\n", "        {\n", "            _cityInfoLabel->setString(_cityString);\n", "        }\n", "        setPopupViewString(StringUtils::format(\"PopupView count %lu\",_popupViewCount)); // popup\u754c\u9762\u6570\n", "        if(!_popupString.empty())\n", "        {\n", "            _popupViewLabel->setString(_popupString);\n", "        }\n", "        \n", "        _plistCount = SpriteFrameCache::getInstance()->getLoadedFileNameCount();\n", "        setPistString(StringUtils::format(\"plist:%lu Spine:%lu SpineScreen:%lu\",\n", "                                          _plistCount,          //\n", "                                          _spAnimationCount,    // spine\u603b\u6570\n", "                                          _spineScreenCount));  // \u9aa8\u9abc\u52a8\u753b\u7ed8\u5236\u603b\u6570\n", "        if(!_plistString.empty())\n", "        {\n", "            _plistLabel->setString(_plistString);\n", "        }\n", "\n", "        if (_accumDt > CC_DIRECTOR_STATS_INTERVAL)\n", "        {\n", "            //lixu 20160120 texutre cache status\n", "            char buftmp[4096];\n", "            \n", "            unsigned int count = 0;\n", "            unsigned int totalBytes = 0;\n", "            \n", "            // \u6750\u8d28\u7f13\u5b58\n", "            for( auto it = _textureCache->_textures.begin(); it != _textureCache->_textures.end(); ++it )\n", "            {\n", "                Texture2D* tex = it->second;\n", "                unsigned int bpp = tex->getBitsPerPixelForFormat();\n", "                // Each texture takes up width * height * bytesPerPixel bytes.\n", "                auto bytes = tex->getPixelsWide() * tex->getPixelsHigh() * bpp / 8;\n", "                totalBytes += bytes;\n", "                \n", "                if (tex->IsHasAlpha())\n", "                {\n", "                    totalBytes += tex->getMemorySizeForAlpha();\n", "                }\n", "                \n", "                count++;\n", "            }\n", "            sprintf(buftmp,\"texcache:%ld texs:%luKB Atladrawnum:%d\\n\",\n", "                    (long)count,\n", "                    (long)totalBytes / 1024,\n", "                    TextureAtlas::ms_drawnum);\n", "            \n", "            _textureCacheInfoLabel->setString(buftmp);\n", " \n", "            sprintf(buffer, \"FPS:%.1f/%.3f Node:%lu Sp:%lu SpF:%lu IFLab:%lu\",\n", "                    _frameRate,         // \u5e27\u7387\n", "                    _secondsPerFrame,   // \u6bcf\u5e27\u65f6\u95f4\n", "                    _runningScene->getVisibleNodeCount(), // \u53ef\u89c6ccnode\u6570\u91cf\n", "                    _spriteCount,       // sprite count\n", "                    _spriteFrameCount,  // \n", "                    _labelIFTTFCount);   // \u6587\u672c\u663e\u793a\u6570\u91cf\n", "            _FPSLabel->setString(buffer);\n", "            _accumDt = 0;\n", "        }\n", "        {\n", "            char szData[1024] = {0};\n", "            sprintf(szData, \"%s,%s:%d\",\n", "                    _downResString.c_str(),\n", "                    _netConnectString.c_str(),\n", "                    _bConnected);\n", "            _GLErrorLabel->setString(szData);\n", "        }\n", "        auto currentCalls = (unsigned long)_renderer->getDrawnBatches();\n", "        auto currentVerts = (unsigned long)_renderer->getDrawnVertices();\n", "        auto currentFlushs = (unsigned long)_renderer->getDrawnFlushs();\n", "        if( currentCalls != prevCalls )\n", "        {\n", "            sprintf(buffer, \"GL dc:%lu Flush:%lu vert:%lu sc:%d sp:%d\",\n", "                    currentCalls,               // \u6e32\u67d3\u6279\u6b21\n", "                    currentFlushs,              // \u6267\u884c\u6e32\u67d3\u6307\u4ee4\uff08flush\uff09\u7684\u6570\u91cf\n", "                    currentVerts,               // \u5f53\u524d\u9876\u70b9\u6691\n", "                    _scheduler->_updateCounter, // \u5b9a\u65f6\u5668\u7684\u4e2a\u6570\u6570\n", "                    _scheduler->_perFrameUpdate); // \u5b9a\u65f6\u5668\u6bcf\u5e27\u89e6\u53d1\u6570\n", "            _drawnBatchesLabel->setString(buffer);\n", "            prevCalls = currentCalls;\n", "        }\n", "        \n", "        sprintf(buffer, \"Time update:%d render:%d scnupdate:%d scnrender:%d\",\n", "                _updatetime,                // \u603b\u7ed8\u5236\u65f6\u95f4\n", "                _rendertime,                // \u603b\u6e32\u67d3\u65f6\u95f4\n", "                _runningScene->_updataTime, // \u573a\u666fupdate\u65f6\u95f4\n", "                _runningScene->_renderTime // \u573a\u666f\u6e32\u67d3\u65f6\u95f4\n", "                );\n", "        _drawnVerticesLabel->setString(buffer);\n", "        prevVerts = currentVerts;\n", "        \n", "        const Mat4& identity = Mat4::IDENTITY;\n", "        _plistLabel->visit(_renderer, identity, 0);\n", "        _popupViewLabel->visit(_renderer, identity, 0);\n", "        _cityInfoLabel->visit(_renderer,identity,0);\n", "        _spAniamtionLabel->visit(_renderer, identity, 0);\n", "        _NetWorkStatusLabel->visit(_renderer, identity, 0);\n", "        _GameStatusLabel->visit(_renderer, identity, 0);\n", "        _GLErrorLabel->visit(_renderer, identity, 0);\n", "        _textureCacheInfoLabel->visit(_renderer, identity, 0);\n", "        _drawnVerticesLabel->visit(_renderer, identity, 0);\n", "        _drawnBatchesLabel->visit(_renderer, identity, 0);\n", "        _FPSLabel->visit(_renderer, identity, 0);\n", "        \n", "    }\n", "}\n"], "Director::createStatsLabel": ["void Director::createStatsLabel()\n", "{\n", "    Texture2D *texture = nullptr;\n", "    std::string fpsString = \"00.0\";\n", "    std::string drawBatchString = \"000\";\n", "    std::string drawVerticesString = \"00000\";\n", "    std::string texturecacheString = \"\";\n", "    std::string glErrorString = \"\";\n", "    std::string gameStatusString =\"\";\n", "    std::string networkString=\"\";\n", "    std::string spAnimationString=\"\";\n", "    std::string cityString=\"\";\n", "    std::string popString=\"\";\n", "    std::string memoryString=\"\";\n", "    if (_FPSLabel)\n", "    {\n", "        fpsString = _FPSLabel->getString();\n", "        drawBatchString = _drawnBatchesLabel->getString();\n", "        drawVerticesString = _drawnVerticesLabel->getString();\n", "        texturecacheString = _textureCacheInfoLabel->getString();\n", "        glErrorString = _GLErrorLabel->getString();\n", "        gameStatusString = _GameStatusLabel->getString();\n", "        networkString = _NetWorkStatusLabel->getString();\n", "        spAnimationString = _spAniamtionLabel->getString();\n", "        cityString = _cityInfoLabel->getString();\n", "        popString = _popupViewLabel->getString();\n", "        memoryString = _memoryLeakLabel->getString();\n", "        _plistString = _plistLabel->getString();\n", "        \n", "        CC_SAFE_RELEASE_NULL(_FPSLabel);\n", "        CC_SAFE_RELEASE_NULL(_drawnBatchesLabel);\n", "        CC_SAFE_RELEASE_NULL(_drawnVerticesLabel);\n", "        CC_SAFE_RELEASE_NULL(_textureCacheInfoLabel);\n", "        CC_SAFE_RELEASE_NULL(_GLErrorLabel);\n", "        CC_SAFE_RELEASE_NULL(_GameStatusLabel);\n", "        CC_SAFE_RELEASE_NULL(_NetWorkStatusLabel);\n", "        CC_SAFE_RELEASE_NULL(_spAniamtionLabel);\n", "        CC_SAFE_RELEASE_NULL(_cityInfoLabel);\n", "        CC_SAFE_RELEASE_NULL(_popupViewLabel);\n", "        CC_SAFE_RELEASE_NULL(_memoryLeakLabel);\n", "        CC_SAFE_RELEASE_NULL(_plistLabel);\n", "        \n", "        _textureCache->removeTextureForKey(\"/cc_fps_images\");\n", "        FileUtils::getInstance()->purgeCachedEntries();\n", "    }\n", "\n", "    backend::PixelFormat currentFormat = Texture2D::getDefaultAlphaPixelFormat();\n", "    Texture2D::setDefaultAlphaPixelFormat(backend::PixelFormat::RGBA4444);\n", "    unsigned char *data = nullptr;\n", "    ssize_t dataLength = 0;\n", "    getFPSImageData(&data, &dataLength);\n", "\n", "    Image* image = new (std::nothrow) Image();\n", "    bool isOK = image ? image->initWithImageData(data, dataLength) : false;\n", "    if (! isOK) {\n", "        if(image)\n", "            delete image;\n", "        CCLOGERROR(\"%s\", \"Fails: init fps_images\");\n", "        return;\n", "    }\n", "\n", "    texture = _textureCache->addImage(image, \"/cc_fps_images\");\n", "    CC_SAFE_RELEASE(image);\n", "\n", "    /*\n", "     We want to use an image which is stored in the file named ccFPSImage.c \n", "     for any design resolutions and all resource resolutions. \n", "     \n", "     To achieve this, we need to ignore 'contentScaleFactor' in 'AtlasNode' and 'LabelAtlas'.\n", "     So I added a new method called 'setIgnoreContentScaleFactor' for 'AtlasNode',\n", "     this is not exposed to game developers, it's only used for displaying FPS now.\n", "     */\n", "    float scaleFactor = 1 / CC_CONTENT_SCALE_FACTOR();\n", "\n", "    _FPSLabel = LabelAtlas::create();\n", "    _FPSLabel->retain();\n", "    _FPSLabel->setIgnoreContentScaleFactor(true);\n", "    _FPSLabel->initWithString(fpsString, texture, 12, 32 , '.');\n", "    _FPSLabel->setScale(scaleFactor);\n", "    _FPSLabel->setColor(ccColor3B(255,242,0));\n", "\n", "    _drawnBatchesLabel = LabelAtlas::create();\n", "    _drawnBatchesLabel->retain();\n", "    _drawnBatchesLabel->setIgnoreContentScaleFactor(true);\n", "    _drawnBatchesLabel->initWithString(drawBatchString, texture, 12, 32, '.');\n", "    _drawnBatchesLabel->setScale(scaleFactor);\n", "    _drawnBatchesLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _drawnVerticesLabel = LabelAtlas::create();\n", "    _drawnVerticesLabel->retain();\n", "    _drawnVerticesLabel->setIgnoreContentScaleFactor(true);\n", "    _drawnVerticesLabel->initWithString(drawVerticesString, texture, 12, 32, '.');\n", "    _drawnVerticesLabel->setScale(scaleFactor);\n", "    _drawnVerticesLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _textureCacheInfoLabel = LabelAtlas::create();\n", "    _textureCacheInfoLabel->retain();\n", "    _textureCacheInfoLabel->setIgnoreContentScaleFactor(true);\n", "    _textureCacheInfoLabel->initWithString(texturecacheString, texture, 12, 32, '.');\n", "    _textureCacheInfoLabel->setScale(scaleFactor);\n", "    _textureCacheInfoLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _GLErrorLabel = LabelAtlas::create();\n", "    _GLErrorLabel->retain();\n", "    _GLErrorLabel->setIgnoreContentScaleFactor(true);\n", "    _GLErrorLabel->initWithString(glErrorString, texture, 12, 32, '.');\n", "    _GLErrorLabel->setScale(scaleFactor);\n", "    _GLErrorLabel->setColor(ccColor3B(255,242,0));\n", "\n", "    _GameStatusLabel = LabelAtlas::create();\n", "    _GameStatusLabel->retain();\n", "    _GameStatusLabel->setIgnoreContentScaleFactor(true);\n", "    _GameStatusLabel->initWithString(gameStatusString, texture, 12, 32, '.');\n", "    _GameStatusLabel->setScale(scaleFactor);\n", "    _GameStatusLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _NetWorkStatusLabel = LabelAtlas::create();\n", "    _NetWorkStatusLabel->retain();\n", "    _NetWorkStatusLabel->setIgnoreContentScaleFactor(true);\n", "    _NetWorkStatusLabel->initWithString(networkString, texture, 12, 32, '.');\n", "    _NetWorkStatusLabel->setScale(scaleFactor);\n", "    _NetWorkStatusLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _spAniamtionLabel = LabelAtlas::create();\n", "    _spAniamtionLabel->retain();\n", "    _spAniamtionLabel->setIgnoreContentScaleFactor(true);\n", "    _spAniamtionLabel->initWithString(spAnimationString, texture, 12, 32, '.');\n", "    _spAniamtionLabel->setScale(scaleFactor);\n", "    _spAniamtionLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _cityInfoLabel = LabelAtlas::create();\n", "    _cityInfoLabel->retain();\n", "    _cityInfoLabel->setIgnoreContentScaleFactor(true);\n", "    _cityInfoLabel->initWithString(cityString, texture, 12, 32, '.');\n", "    _cityInfoLabel->setScale(scaleFactor);\n", "    _cityInfoLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _popupViewLabel = LabelAtlas::create();\n", "    _popupViewLabel->retain();\n", "    _popupViewLabel->setIgnoreContentScaleFactor(true);\n", "    _popupViewLabel->initWithString(popString, texture, 12, 32, '.');\n", "    _popupViewLabel->setScale(scaleFactor);\n", "    _popupViewLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _memoryLeakLabel = LabelAtlas::create();\n", "    _memoryLeakLabel->retain();\n", "    _memoryLeakLabel->setIgnoreContentScaleFactor(true);\n", "    _memoryLeakLabel->initWithString(memoryString, texture, 12, 32, '.');\n", "    _memoryLeakLabel->setScale(scaleFactor);\n", "    _memoryLeakLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    _plistLabel = LabelAtlas::create();\n", "    _plistLabel->retain();\n", "    _plistLabel->setIgnoreContentScaleFactor(true);\n", "    _plistLabel->initWithString(_plistString, texture, 12, 32, '.');\n", "    _plistLabel->setScale(scaleFactor);\n", "    _plistLabel->setColor(ccColor3B(255,242,0));\n", "    \n", "    Texture2D::setDefaultAlphaPixelFormat(currentFormat);\n", "\n", "    const int height_spacing = 22 / CC_CONTENT_SCALE_FACTOR();\n", "    _plistLabel->setPosition(Vec2(0, height_spacing*11) + CC_DIRECTOR_STATS_POSITION);\n", "    _memoryLeakLabel->setPosition(Vec2(0, height_spacing*10) + CC_DIRECTOR_STATS_POSITION);\n", "    _popupViewLabel->setPosition(Vec2(0, height_spacing*9) + CC_DIRECTOR_STATS_POSITION);\n", "    _cityInfoLabel->setPosition(Vec2(0, height_spacing*8) + CC_DIRECTOR_STATS_POSITION);\n", "    _spAniamtionLabel->setPosition(Vec2(0, height_spacing*7) + CC_DIRECTOR_STATS_POSITION);\n", "    _NetWorkStatusLabel->setPosition(Vec2(0, height_spacing*6) + CC_DIRECTOR_STATS_POSITION);\n", "    _GameStatusLabel->setPosition(Vec2(0, height_spacing*5) + CC_DIRECTOR_STATS_POSITION);\n", "    _GLErrorLabel->setPosition(Vec2(0, height_spacing*4) + CC_DIRECTOR_STATS_POSITION);\n", "    _textureCacheInfoLabel->setPosition(Vec2(0, height_spacing*3) + CC_DIRECTOR_STATS_POSITION);\n", "    _drawnVerticesLabel->setPosition(Vec2(0, height_spacing*2) + CC_DIRECTOR_STATS_POSITION);\n", "    _drawnBatchesLabel->setPosition(Vec2(0, height_spacing*1) + CC_DIRECTOR_STATS_POSITION);\n", "    _FPSLabel->setPosition(Vec2(0, height_spacing*0)+CC_DIRECTOR_STATS_POSITION);\n", "}\n"], "block_one_MATRIX_STACK_TYPE": ["enum class MATRIX_STACK_TYPE\n", "{\n", "    /// Model view matrix stack\n", "    MATRIX_STACK_MODELVIEW,\n", "    \n", "    /// projection matrix stack\n", "    MATRIX_STACK_PROJECTION,\n", "    \n", "    /// texture matrix stack\n", "    MATRIX_STACK_TEXTURE\n", "};\n"], "CCDirector.h_header": ["\n", "#include <stack>\n", "#include <thread>\n", "#include <chrono>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"base/CCVector.h\"\n", "#include \"2d/CCScene.h\"\n", "#include \"math/CCMath.h\"\n", "#include \"platform/CCGL.h\"\n", "#include \"platform/CCGLView.h\"\n", "\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT )\n", "#include \"CCPThreadWinRT.h\"\n", "#elif  (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32 )\n", "#include \"windows.h\"\n", "#else\n", "#include <pthread.h>\n", "#endif\n", "#include <mutex>\n", "#include \"base/CCConsole.h\"\n", "#include \"base/Profile.h\"\n", "#include \"base/CCValue.h\"\n", "#include <map>\n", " \n", "CC_DLL extern size_t g_safeNodeCountTemp;\n", "NS_CC_BEGIN\n", "typedef void (*pFuncCallGame)(const char* key,const char * value);\n", "typedef void (*pFuncPushLogToGame)(const char* log);\n", "typedef void (*pLogPost)(const char* tag, const std::string& paramlog, ValueMap const& values);\n", "/**\n", " * @addtogroup base\n", " * @{\n", " */\n", "\n", "/* Forward declarations. */\n", "class LabelAtlas;\n", "//class GLView;\n", "class DirectorDelegate;\n", "class Node;\n", "class Scheduler;\n", "class ActionManager;\n", "class EventDispatcher;\n", "class EventCustom;\n", "class EventListenerCustom;\n", "class TextureCache;\n", "class Renderer;\n", "class Camera;\n", "\n", "class Console;\n", "class CCPThread;\n", "namespace experimental\n", "{\n", "    class FrameBuffer;\n", "}\n", "\n", "/**\n", " * @brief Matrix stack type.\n", " */\n"], "CCLabel.cpp_cpp": ["#include \"2d/CCLabel.h\"\n", "#include <algorithm>\n", "#include <stddef.h> // offsetof\n", "#include \"base/ccTypes.h\"\n", "#include \"2d/CCFont.h\"\n", "#include \"2d/CCFontAtlasCache.h\"\n", "#include \"2d/CCFontAtlas.h\"\n", "#include \"2d/CCSprite.h\"\n", "#include \"2d/CCSpriteBatchNode.h\"\n", "#include \"2d/CCDrawNode.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"2d/CCLabelTextFormatter.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"2d/CCFont.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventCustom.h\"\n", "#include \"deprecated/CCString.h\"\n", "#include \"platform/CCDevice.h\"\n", "#include \"xxhash.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"2d/CCFontFNT.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "\n", "//zym wp\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)\n", "extern bool(*MemoryMD5_ptr)(const std::vector< char>& buf, std::string& strMD5) ;\n", "extern  bool(*isTextFlipptr)() ;\n", "#else\n", "\n", "extern bool MemoryMD5(const std::vector<char >& buf, std::string& strMD5);\n", "extern bool(*MemoryMD5_ptr)(const std::vector< char>& buf, std::string& strMD5) ;\n", "\n", "extern bool(*isTextFlipptr)()  ;\n", "#endif\n", "\n", "NS_CC_BEGIN\n"], "Label::reset": ["void Label::reset()\n", "{\n", "    CC_SAFE_RELEASE_NULL(_textSprite);\n", "    CC_SAFE_RELEASE_NULL(_shadowNode);\n", "    Node::removeAllChildrenWithCleanup(true);\n", "    CC_SAFE_RELEASE_NULL(_reusedLetter);\n", "    _letters.clear();\n", "    _batchNodes.clear();\n", "    _batchCommands.clear();\n", "    _lettersInfo.clear();\n", "    if (_fontAtlas)\n", "    {\n", "        FontAtlasCache::releaseFontAtlas(_fontAtlas);\n", "        _fontAtlas = nullptr;\n", "    }\n", "\n", "    _currentLabelType = LabelType::STRING_TEXTURE;\n", "    _currLabelEffect = LabelEffect::NORMAL;\n", "    _contentDirty = false;\n", "    _numberOfLines = 0;\n", "    _lengthOfString = 0;\n", "    _utf32Text.clear();\n", "    _utf8Text.clear();\n", "\n", "    TTFConfig temp;\n", "    _fontConfig = temp;\n", "    _outlineSize = 0.f;\n", "    _bmFontPath = \"\";\n", "    _systemFontDirty = false;\n", "    _systemFont = \"Helvetica\";\n", "    _systemFontSize = CC_DEFAULT_FONT_LABEL_SIZE;\n", "\n", "    if (_horizontalKernings)\n", "    {\n", "        delete[] _horizontalKernings;\n", "        _horizontalKernings = nullptr;\n", "    }\n", "    _additionalKerning = 0.f;\n", "    _lineHeight = 0.f;\n", "    _lineSpacing = 0.f;\n", "    _maxLineWidth = 0.f;\n", "    _labelDimensions.width = 0.f;\n", "    _labelDimensions.height = 0.f;\n", "    _labelWidth = 0.f;\n", "    _labelHeight = 0.f;\n", "    _lineBreakWithoutSpaces = false;\n", "    _hAlignment = TextHAlignment::LEFT;\n", "    _vAlignment = TextVAlignment::TOP;\n", "\n", "    _effectColorF = Color4F::BLACK;\n", "    _textColor = Color4B::WHITE;\n", "    _textColorF = Color4F::WHITE;\n", "    _hash = XXH32((const void*)&(_textColorF.r), sizeof(_textColorF), 0);\n", "    setColor(Color3B::WHITE);\n", "\n", "    _shadowDirty = false;\n", "    _shadowEnabled = false;\n", "    _shadowBlurRadius = 0.f;\n", "\n", "    _uniformEffectColor = -1;\n", "    _uniformEffectType = -1;\n", "    _uniformTextColor = -1;\n", "\n", "    _useDistanceField = false;\n", "    _useA8Shader = false;\n", "    _clipEnabled = false;\n", "    _blendFuncDirty = false;\n", "    _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;\n", "    _isOpacityModifyRGB = false;\n", "    _insideBounds = true;\n", "    _enableWrap = true;\n", "    _bmFontSize = -1;\n", "    _bmfontScale = 1.0f;\n", "    _overflow = Overflow::NONE;\n", "    _originalFontSize = 0.0f;\n", "    _boldEnabled = false;\n", "    if (_underlineNode)\n", "    {\n", "        removeChild(_underlineNode);\n", "        _underlineNode = nullptr;\n", "    }\n", "    _strikethroughEnabled = false;\n", "    setRotationSkewX(0);        // reverse italics\n", "}\n"], "Label::updateShaderProgram": ["void Label::updateShaderProgram()\n", "{\n", "    auto programType = backend::ProgramType::POSITION_TEXTURE_COLOR;\n", "    if (_currentLabelType == LabelType::BMFONT || _currentLabelType == LabelType::CHARMAP)\n", "    {\n", "        auto texture = _getTexture(this);\n", "        if(texture && texture->getAlphaTextureName())\n", "        {\n", "            programType = backend::ProgramType::ETC1;\n", "        }\n", "    }\n", "    else\n", "    {\n", "        switch (_currLabelEffect)\n", "        {\n", "            case cocos2d::LabelEffect::NORMAL:\n", "                if (_useDistanceField)\n", "                {\n", "                    programType = backend::ProgramType::LABEL_DISTANCE_NORMAL;\n", "                }\n", "                else if (_useA8Shader)\n", "                {\n", "                    programType = backend::ProgramType::LABEL_NORMAL;\n", "                }\n", "                else\n", "                {\n", "                    auto texture = _getTexture(this);\n", "                    if(texture && texture->getAlphaTextureName())\n", "                    {\n", "                        programType = backend::ProgramType::ETC1;\n", "                    }\n", "                }\n", "                break;\n", "            case cocos2d::LabelEffect::OUTLINE:\n", "                {\n", "                    programType = backend::ProgramType::LABLE_OUTLINE;\n", "                }\n", "                break;\n", "            case cocos2d::LabelEffect::GLOW:\n", "                if (_useDistanceField)\n", "                {\n", "                    programType = backend::ProgramType::LABLE_DISTANCEFIELD_GLOW;\n", "                }\n", "                break;\n", "            default:\n", "                return;\n", "        }\n", "    }\n", "\n", "    CC_SAFE_RELEASE(_programState);\n", "    auto* program = backend::Program::getBuiltinProgram(programType);\n", "    _programState = new backend::ProgramState(program);\n", "\n", "    updateUniformLocations();\n", "\n", "    for (auto &batch : _batchCommands)\n", "    {\n", "        updateBatchCommand(batch);\n", "    }\n", "\n", "    auto &quadPipeline = _quadCommand.getPipelineDescriptor();\n", "    setVertexLayout(quadPipeline);\n", "    quadPipeline.programState = _programState;\n", "}\n"], "Label::setTTFConfig-TTFConfig&": ["bool Label::setTTFConfig(const TTFConfig& ttfConfig)\n", "{\n", "    _originalFontSize = ttfConfig.fontSize;\n", "    return setTTFConfigInternal(ttfConfig);\n", "}\n"], "Label::setString-std::string&": ["void Label::setString(const std::string& text)\n", "{\n", "    if (text.compare(_originalUTF8String))\n", "    {\n", "        if (_fontAtlas != nullptr\n", "            && LabelType::TTF == _currentLabelType)\n", "        {\n", "#ifdef TestTTF\n", "            _originalUTF8String = text + \"@\";\n", "#else\n", "            _originalUTF8String = text;\n", "#endif\n", "        }\n", "        else\n", "        {\n", "            _originalUTF8String = text;\n", "        }\n", "        \n", "        _contentDirty = true;\n", "\n", "        std::u16string utf16String;\n", "        if (StringUtils::UTF8ToUTF16(_originalUTF8String, utf16String))\n", "        {\n", "            if (_fontAtlas != nullptr\n", "                && LabelType::TTF == _currentLabelType)\n", "            {\n", "                //\u6839\u636e\u8bbe\u7f6e\u7684\u6587\u5b57\u6765\u9009\u62e9\u4f7f\u7528\u7684\u5b57\u4f53\n", "                std::string fontName;\n", "                bool support = FontManager::getInstance().getFontNameByText(utf16String, fontName);\n", "                TTFConfig ttConfig = getTTFConfig();\n", "                \n", "                if (support)\n", "                {\n", "                    ttConfig.fontFilePath = fontName;\n", "                    setTTFConfig(ttConfig);\n", "                }\n", "                else\n", "                {\n", "                    // \u8bbe\u7f6e\u5b57\u4f53\u4e3a\u7cfb\u7edf\u5b57\u4f53\n", "                    _currentLabelType = LabelType::STRING_TEXTURE;\n", "                    _systemFont = \"Helvetica\";\n", "                    _systemFontSize = ttConfig.fontSize;\n", "                    _systemFontDirty = true;\n", "                }\n", "            }\n", "            \n", "            _currentUTF16String  = utf16String;\n", "        }\n", "    }\n", "}\n"], "Label::updateQuads": ["bool Label::updateQuads()\n", "{\n", "    bool ret = true;\n", "    for (auto&& batchNode : _batchNodes)\n", "    {\n", "        batchNode->getTextureAtlas()->removeAllQuads();\n", "    }\n", "    \n", "    for (int ctr = 0; ctr < _lengthOfString; ++ctr)\n", "    {\n", "        if (_lettersInfo[ctr].valid)\n", "        {\n", "            auto& letterDef = _fontAtlas->_letterDefinitions[_lettersInfo[ctr].utf32Char];\n", "            \n", "            _reusedRect.size.height = letterDef.height;\n", "            _reusedRect.size.width  = letterDef.width;\n", "            _reusedRect.origin.x    = letterDef.U;\n", "            _reusedRect.origin.y    = letterDef.V;\n", "\n", "            auto py = _lettersInfo[ctr].positionY + _letterOffsetY;\n", "            if (_labelHeight > 0.f) {\n", "                if (py > _tailoredTopY)\n", "                {\n", "                    auto clipTop = py - _tailoredTopY;\n", "                    _reusedRect.origin.y += clipTop;\n", "                    _reusedRect.size.height -= clipTop;\n", "                    py -= clipTop;\n", "                }\n", "                if (py - letterDef.height * _bmfontScale < _tailoredBottomY)\n", "                {\n", "                    _reusedRect.size.height = (py < _tailoredBottomY) ? 0.f : (py - _tailoredBottomY);\n", "                }\n", "            }\n", "\n", "            auto lineIndex = _lettersInfo[ctr].lineIndex;\n", "            auto px = _lettersInfo[ctr].positionX + letterDef.width/2 * _bmfontScale + _linesOffsetX[lineIndex];\n", "\n", "            if(_labelWidth > 0.f){\n", "                if (this->isHorizontalClamped(px, lineIndex)) {\n", "                    if(_overflow == Overflow::CLAMP){\n", "                        _reusedRect.size.width = 0;\n", "                    }else if(_overflow == Overflow::SHRINK){\n", "                        if (_contentSize.width > letterDef.width) {\n", "                            ret = false;\n", "                            break;\n", "                        }else{\n", "                            _reusedRect.size.width = 0;\n", "                        }\n", "\n", "                    }\n", "                }\n", "            }\n", "\n", "\n", "            if (_reusedRect.size.height > 0.f && _reusedRect.size.width > 0.f)\n", "            {\n", "                _reusedLetter->setTextureRect(_reusedRect, false, _reusedRect.size);\n", "                float letterPositionX = _lettersInfo[ctr].positionX + _linesOffsetX[_lettersInfo[ctr].lineIndex];\n", "                _reusedLetter->setPosition(letterPositionX, py);\n", "                auto index = static_cast<int>(_batchNodes.at(letterDef.textureID)->getTextureAtlas()->getTotalQuads());\n", "                _lettersInfo[ctr].atlasIndex = index;\n", "\n", "                this->updateLetterSpriteScale(_reusedLetter);\n", "\n", "                _batchNodes.at(letterDef.textureID)->insertQuadFromSprite(_reusedLetter, index);\n", "            }\n", "        }     \n", "    }\n", "\n", "\n", "    return ret;\n", "}\n"], "Label::disableEffect-LabelEffect": ["void Label::disableEffect(LabelEffect effect)\n", "{\n", "    switch (effect)\n", "    {\n", "        case cocos2d::LabelEffect::NORMAL:\n", "            break;\n", "        case cocos2d::LabelEffect::OUTLINE:\n", "            if (_currLabelEffect == LabelEffect::OUTLINE)\n", "            {\n", "                if (_currentLabelType == LabelType::TTF)\n", "                {\n", "                    _fontConfig.outlineSize = 0;\n", "                    setTTFConfig(_fontConfig);\n", "                }\n", "                _currLabelEffect = LabelEffect::NORMAL;\n", "                _contentDirty = true;\n", "            }\n", "            break;\n", "        case cocos2d::LabelEffect::SHADOW:\n", "            if (_shadowEnabled)\n", "            {\n", "                _shadowEnabled = false;\n", "                CC_SAFE_RELEASE_NULL(_shadowNode);\n", "                updateShaderProgram();\n", "            }\n", "            break;\n", "        case cocos2d::LabelEffect::GLOW:\n", "            if (_currLabelEffect == LabelEffect::GLOW)\n", "            {\n", "                _currLabelEffect = LabelEffect::NORMAL;\n", "                updateShaderProgram();\n", "            }\n", "            break;\n", "        case cocos2d::LabelEffect::ITALICS:\n", "            setRotationSkewX(0);\n", "            break;\n", "        case cocos2d::LabelEffect::BOLD:\n", "            if (_boldEnabled) {\n", "                _boldEnabled = false;\n", "                _additionalKerning -= 1;\n", "                disableEffect(LabelEffect::SHADOW);\n", "            }\n", "            break;\n", "        case cocos2d::LabelEffect::UNDERLINE:\n", "            if (_underlineNode) {\n", "                removeChild(_underlineNode);\n", "                _underlineNode = nullptr;\n", "            }\n", "            break;\n", "        case cocos2d::LabelEffect::STRIKETHROUGH:\n", "            _strikethroughEnabled = false;\n", "            // since it is based on underline, disable it as well\n", "            disableEffect(LabelEffect::UNDERLINE);\n", "            break;\n", "        case LabelEffect::ALL:\n", "        {\n", "            disableEffect(LabelEffect::SHADOW);\n", "            disableEffect(LabelEffect::GLOW);\n", "            disableEffect(LabelEffect::OUTLINE);\n", "            disableEffect(LabelEffect::ITALICS);\n", "            disableEffect(LabelEffect::BOLD);\n", "            disableEffect(LabelEffect::UNDERLINE);\n", "            disableEffect(LabelEffect::STRIKETHROUGH);\n", "        }\n", "            break;\n", "        default:\n", "            break;\n", "    }\n", "}\n"], "Label::draw-Renderer*-Mat4&-uint32_t": ["void Label::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)\n", "{\n", "    if (_batchNodes.empty() || _lengthOfString <= 0)\n", "    {\n", "        return;\n", "    }\n", "    // Don't do calculate the culling if the transform was not updated\n", "    bool transformUpdated = flags & FLAGS_TRANSFORM_DIRTY;\n", "#if CC_USE_CULLING\n", "    auto visitingCamera = Camera::getVisitingCamera();\n", "    auto defaultCamera = Camera::getDefaultCamera();\n", "    if (visitingCamera == defaultCamera) {\n", "        _insideBounds = (transformUpdated || visitingCamera->isViewProjectionUpdated()) ? renderer->checkVisibility(transform, _contentSize) : _insideBounds;\n", "    }\n", "    else\n", "    {\n", "        _insideBounds = renderer->checkVisibility(transform, _contentSize);\n", "    }\n", "\n", "    if (_insideBounds)\n", "#endif\n", "    {\n", "        cocos2d::Mat4 matrixProjection = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);\n", "        if (!_shadowEnabled && (_currentLabelType == LabelType::BMFONT || _currentLabelType == LabelType::CHARMAP))\n", "        {\n", "            updateBlendState();\n", "            for (auto&& it : _letters)\n", "            {\n", "                it.second->updateTransform();\n", "            }\n", "            // ETC1 ALPHA supports for BMFONT & CHARMAP\n", "            auto textureAtlas = _batchNodes.at(0)->getTextureAtlas();\n", "            if(!textureAtlas->getTotalQuads())\n", "                return;\n", "            \n", "            auto texture = textureAtlas->getTexture();\n", "            auto& pipelineQuad = _quadCommand.getPipelineDescriptor();\n", "            pipelineQuad.programState->setUniform(_mvpMatrixLocation, matrixProjection.m, sizeof(matrixProjection.m));\n", "            pipelineQuad.programState->setTexture(_textureLocation, 0, texture->getBackendTexture());\n", "            auto alphaTexture = textureAtlas->getTexture()->getAlphaTexture();\n", "            if(alphaTexture && alphaTexture->getBackendTexture())\n", "            {\n", "                pipelineQuad.programState->setTexture(_alphaTextureLocation, 1, alphaTexture->getBackendTexture());\n", "            }\n", "            _quadCommand.init(_globalZOrder, texture, _blendFunc, textureAtlas->getQuads(), textureAtlas->getTotalQuads(), transform, flags);\n", "            renderer->addCommand(&_quadCommand);\n", "        }\n", "        else\n", "        {\n", "            cocos2d::Mat4 matrixMVP = matrixProjection * transform;\n", "\n", "            for (auto &&it : _letters)\n", "            {\n", "                it.second->updateTransform();\n", "            }\n", "            int i = 0;\n", "\n", "            if (_batchCommands.size() != _batchNodes.size())\n", "            {\n", "                _batchCommands.resize(_batchNodes.size());\n", "                updateShaderProgram();\n", "            }\n", "\n", "            updateBlendState();\n", "\n", "            for (auto&& batchNode : _batchNodes)\n", "            {\n", "                auto textureAtlas = batchNode->getTextureAtlas();\n", "                if (!textureAtlas->getTotalQuads())\n", "                    return;\n", "\n", "                auto &batch = _batchCommands[i++];\n", "                auto &&commands = batch.getCommandArray();\n", "                for (auto command : commands)\n", "                {\n", "                    auto *programState = command->getPipelineDescriptor().programState;\n", "                    Vec4 textColor(_textColorF.r, _textColorF.g, _textColorF.b, _textColorF.a);\n", "                    programState->setUniform(_textColorLocation, &textColor, sizeof(Vec4));\n", "                    programState->setTexture(_textureLocation, 0, textureAtlas->getTexture()->getBackendTexture());\n", "                    auto alphaTexture = textureAtlas->getTexture()->getAlphaTexture();\n", "                    if (alphaTexture && alphaTexture->getBackendTexture())\n", "                    {\n", "                        programState->setTexture(_alphaTextureLocation, 1, alphaTexture->getBackendTexture());\n", "                    }\n", "                }\n", "                batch.textCommand.getPipelineDescriptor().programState->setUniform(_mvpMatrixLocation, matrixMVP.m, sizeof(matrixMVP.m));\n", "                batch.outLineCommand.getPipelineDescriptor().programState->setUniform(_mvpMatrixLocation, matrixMVP.m, sizeof(matrixMVP.m));\n", "                updateEffectUniforms(batch, textureAtlas, renderer, transform);\n", "            }\n", "        }\n", "    }\n", "}\n"], "Label::updateContent": ["void Label::updateContent()\n", "{\n", "    if (_systemFontDirty)\n", "    {\n", "        if (_fontAtlas)\n", "        {\n", "            _batchNodes.clear();\n", "            _batchCommands.clear();\n", "            CC_SAFE_RELEASE_NULL(_reusedLetter);\n", "            FontAtlasCache::releaseFontAtlas(_fontAtlas);\n", "            _fontAtlas = nullptr;\n", "        }\n", "\n", "        _systemFontDirty = false;\n", "    }\n", "\n", "    CC_SAFE_RELEASE_NULL(_textSprite);\n", "    CC_SAFE_RELEASE_NULL(_shadowNode);\n", "    bool updateFinished = true;\n", "\n", "    if (_fontAtlas)\n", "    {\n", "        std::u16string utf16String;\n", "        if (StringUtils::UTF8ToUTF16(_originalUTF8String, utf16String))\n", "        {\n", "            _currentUTF16String = utf16String;\n", "        }\n", "\n", "        computeStringNumLines();\n", "        computeHorizontalKernings(_currentUTF16String);\n", "        alignText();\n", "    }\n", "    else\n", "    {\n", "        createSpriteForSystemFont();\n", "        if (_shadowEnabled)\n", "        {\n", "            createShadowSpriteForSystemFont();\n", "        }\n", "    }\n", "\n", "    if (_underlineNode)\n", "    {\n", "        _underlineNode->clear();\n", "\n", "        if (_numberOfLines)\n", "        {\n", "            // This is the logic for TTF fonts\n", "            const float charheight = (_textDesiredHeight / _numberOfLines);\n", "            _underlineNode->setLineWidth(charheight/6);\n", "\n", "            // atlas font\n", "            for (int i=0; i<_numberOfLines; ++i)\n", "            {\n", "                float offsety = 0;\n", "                if (_strikethroughEnabled)\n", "                    offsety += charheight / 2;\n", "                // FIXME: Might not work with different vertical alignments\n", "                float y = (_numberOfLines - i - 1) * charheight + offsety;\n", "\n", "                // Github issue #15214. Uses _displayedColor instead of _textColor for the underline.\n", "                // This is to have the same behavior of SystemFonts.\n", "                _underlineNode->drawLine(Vec2(_linesOffsetX[i],y), Vec2(_linesWidth[i] + _linesOffsetX[i],y), Color4F(_displayedColor));\n", "            }\n", "        }\n", "        else if (_textSprite)\n", "        {\n", "            // ...and is the logic for System fonts\n", "            float y = 0;\n", "            const auto spriteSize = _textSprite->getContentSize();\n", "            _underlineNode->setLineWidth(spriteSize.height/6);\n", "\n", "            if (_strikethroughEnabled)\n", "                // FIXME: system fonts don't report the height of the font correctly. only the size of the texture, which is POT\n", "                y += spriteSize.height / 2;\n", "            // FIXME: Might not work with different vertical alignments\n", "            _underlineNode->drawLine(Vec2(0.0f,y), Vec2(spriteSize.width,y), Color4F(_textSprite->getDisplayedColor()));\n", "        }\n", "    }\n", "\n", "    if(updateFinished){\n", "        _contentDirty = false;\n", "    }\n", "\n", "#if CC_LABEL_DEBUG_DRAW\n", "    _debugDrawNode->clear();\n", "    Vec2 vertices[4] =\n", "    {\n", "        Vec2::ZERO,\n", "        Vec2(_contentSize.width, 0.0f),\n", "        Vec2(_contentSize.width, _contentSize.height),\n", "        Vec2(0.0f, _contentSize.height)\n", "    };\n", "    _debugDrawNode->drawPoly(vertices, 4, true, Color4F::WHITE);\n", "#endif\n", "}\n"], "Label::getLetter-int": ["Sprite * Label::getLetter(int letterIndex)\n", "{\n", "    Sprite* letter = nullptr;\n", "    do\n", "    {\n", "        if (_systemFontDirty || _currentLabelType == LabelType::STRING_TEXTURE)\n", "        {\n", "            break;\n", "        }\n", "\n", "        auto contentDirty = _contentDirty;\n", "        if (contentDirty)\n", "        {\n", "            updateContent();\n", "        }\n", "\n", "        if (_textSprite == nullptr && letterIndex < _lengthOfString)\n", "        {\n", "            const auto &letterInfo = _lettersInfo[letterIndex];\n", "            if (!letterInfo.valid || letterInfo.atlasIndex<0)\n", "            {\n", "                break;\n", "            }\n", "\n", "            if (_letters.find(letterIndex) != _letters.end())\n", "            {\n", "                letter = _letters[letterIndex];\n", "            }\n", "\n", "            if (letter == nullptr)\n", "            {\n", "                auto& letterDef = _fontAtlas->_letterDefinitions[letterInfo.utf32Char];\n", "                auto textureID = letterDef.textureID;\n", "                Rect uvRect;\n", "                uvRect.size.height = letterDef.height;\n", "                uvRect.size.width = letterDef.width;\n", "                uvRect.origin.x = letterDef.U;\n", "                uvRect.origin.y = letterDef.V;\n", "\n", "                if (letterDef.width <= 0.f || letterDef.height <= 0.f)\n", "                {\n", "                    letter = LabelLetter::create();\n", "                }\n", "                else\n", "                {\n", "                    this->updateBMFontScale();\n", "                    letter = LabelLetter::createWithTexture(_fontAtlas->getTexture(textureID), uvRect);\n", "                    letter->setTextureAtlas(_batchNodes.at(textureID)->getTextureAtlas());\n", "                    letter->setAtlasIndex(letterInfo.atlasIndex);\n", "                    auto px = letterInfo.positionX + _bmfontScale * uvRect.size.width / 2 + _linesOffsetX[letterInfo.lineIndex];\n", "                    auto py = letterInfo.positionY - _bmfontScale * uvRect.size.height / 2 + _letterOffsetY;\n", "                    letter->setPosition(px,py);\n", "                    letter->setOpacity(_realOpacity);\n", "                    this->updateLetterSpriteScale(letter);\n", "                }\n", "                \n", "                addChild(letter);\n", "                _letters[letterIndex] = letter;\n", "            }\n", "        }\n", "    } while (false);\n", "\n", "    return letter;\n", "}\n"], "CCGLView.h_header": ["\n", "#include \"base/ccTypes.h\"\n", "#include \"base/CCEventTouch.h\"\n", "\n", "#include <vector>\n", "\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)\n", "#include <windows.h>\n", "#endif /* (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) */\n", "\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_MAC)\n", "typedef void* id;\n", "#endif /* (CC_TARGET_PLATFORM == CC_PLATFORM_MAC) */\n", "\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM == CC_PLATFORM_LINUX)\n", "#define CC_ICON_SET_SUPPORT true\n", "#endif /* (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM == CC_PLATFORM_LINUX) */\n", "\n", "/** There are some Resolution Policy for Adapt to the screen. */\n"], "block_one_ResolutionPolicy": ["enum class ResolutionPolicy\n", "{\n", "    /** The entire application is visible in the specified area without trying to preserve the original aspect ratio.\n", "     * Distortion can occur, and the application may appear stretched or compressed.\n", "     */\n", "    EXACT_FIT,\n", "    /** The entire application fills the specified area, without distortion but possibly with some cropping,\n", "     * while maintaining the original aspect ratio of the application.\n", "     */\n", "    NO_BORDER,\n", "    /** The entire application is visible in the specified area without distortion while maintaining the original\n", "     * aspect ratio of the application. Borders can appear on two sides of the application.\n", "     */\n", "    SHOW_ALL,\n", "    /** The application takes the height of the design resolution size and modifies the width of the internal\n", "     * canvas so that it fits the aspect ratio of the device.\n", "     * No distortion will occur however you must make sure your application works on different\n", "     * aspect ratios.\n", "     */\n", "    FIXED_HEIGHT,\n", "    /** The application takes the width of the design resolution size and modifies the height of the internal\n", "     * canvas so that it fits the aspect ratio of the device.\n", "     * No distortion will occur however you must make sure your application works on different\n", "     * aspect ratios.\n", "     */\n", "    FIXED_WIDTH,\n", "\n", "    UNKNOWN,\n", "};\n"], "block_one_GLContextAttrs": ["struct GLContextAttrs\n", "{\n", "    int redBits;\n", "    int greenBits;\n", "    int blueBits;\n", "    int alphaBits;\n", "    int depthBits;\n", "    int stencilBits;\n", "};\n"], "CCGLView.cpp_cpp": ["#include \"platform/CCGLView.h\"\n", "\n", "#include \"base/CCTouch.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"2d/CCCamera.h\"\n", "extern bool g_RTScreenEnabled;\n", "extern float g_RTScissorScaleX;\n", "extern float g_RTScissorScaleY;\n", "#include \"2d/CCScene.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "NS_CC_BEGIN\n"], "GLView::handleTouchesMove-int-intptr_t-float-float": ["void GLView::handleTouchesMove(int num, intptr_t ids[], float xs[], float ys[])\n", "{\n", "    handleTouchesMove(num, ids, xs, ys, nullptr, nullptr);\n", "}\n"], "CCCamera.h_header": ["\n", "#include \"2d/CCNode.h\"\n", "#include \"3d/CCFrustum.h\"\n", "#include \"renderer/CCQuadCommand.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Scene;\n", "class CameraBackgroundBrush;\n", "\n", "/**\n", " * Note: \n", " * Scene creates a default camera. And the default camera mask of Node is 1, therefore it can be seen by the default camera.\n", " * During rendering the scene, it draws the objects seen by each camera in the added order except default camera. The default camera is the last one being drawn with.\n", " * It's usually a good idea to render 3D objects in a separate camera.\n", " * And set the 3d camera flag to CameraFlag::USER1 or anything else except DEFAULT. Dedicate The DEFAULT camera for UI, because it is rendered at last.\n", " * You can change the camera order to get different result when depth test is not enabled.\n", " * For each camera, transparent 3d sprite is rendered after opaque 3d sprite and other 2d objects.\n", " */\n"], "block_one_CameraFlag": ["enum class CameraFlag\n", "{\n", "    DEFAULT = 1,\n", "    USER1 = 1 << 1,\n", "    USER2 = 1 << 2,\n", "    USER3 = 1 << 3,\n", "    USER4 = 1 << 4,\n", "    USER5 = 1 << 5,\n", "    USER6 = 1 << 6,\n", "    USER7 = 1 << 7,\n", "    USER8 = 1 << 8,\n", "};\n"], "CCCamera.cpp_cpp": ["#include \"2d/CCCameraBackgroundBrush.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"platform/CCGLView.h\"\n", "#include \"2d/CCScene.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCQuadCommand.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCLabel.h_header": ["\n", "#include \"2d/CCNode.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCQuadCommand.h\"\n", "#include \"2d/CCFontAtlas.h\"\n", "#include \"base/ccTypes.h\"\n", "#include <map>\n", "\n", "#include <iostream>\n", "#include <vector>\n", "#include <algorithm>\n", "\n", "NS_CC_BEGIN\n", "\n", "using namespace std;\n", "\n"], "block_one__ttfConfig": ["typedef struct _ttfConfig\n", "{\n", "    std::string fontFilePath;\n", "    float fontSize;\n", "\n", "    GlyphCollection glyphs;\n", "    const char *customGlyphs;\n", "\n", "    bool distanceFieldEnabled;\n", "    int outlineSize;\n", "    bool nativeF;\n", "    bool italics;\n", "    bool bold;\n", "    bool underline;\n", "    bool strikethrough;\n", "\n", "    _ttfConfig(const std::string& filePath = \"\",float size = 12, const GlyphCollection& glyphCollection = GlyphCollection::DYNAMIC,\n", "        const char *customGlyphCollection = nullptr,bool useDistanceField = false,int outline = 0,\n", "\tbool useItalics = false, bool useBold = false, bool useUnderline = false, bool useStrikethrough = false)\n", "        :fontFilePath(filePath)\n", "        ,fontSize(size)\n", "        ,glyphs(glyphCollection)\n", "        ,customGlyphs(customGlyphCollection)\n", "        ,distanceFieldEnabled(useDistanceField)\n", "        ,outlineSize(outline)\n", "        ,nativeF(false)\n", "\t, italics(useItalics)\n", "        , bold(useBold)\n", "        , underline(useUnderline)\n", "        , strikethrough(useStrikethrough)\n", "    {\n", "        if(outline > 0)\n", "        {\n", "            distanceFieldEnabled = false;\n", "        }\n", "    }\n", "    \n", "    void setNativeFont(bool nativeFont)\n", "    {\n", "        nativeF = nativeFont;\n", "    }\n", "}TTFConfig;\n"], "CCFontAtlas.h_header": ["\n", "/// @cond DO_NOT_SHOW\n", "\n", "#include <string>\n", "#include <unordered_map>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"platform/CCStdC.h\" // ssize_t on windows\n", "#include \"renderer/CCTexture2D.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Font;\n", "class Texture2D;\n", "class EventCustom;\n", "class EventListenerCustom;\n", "class FontFreeType;\n", "\n"], "block_one_FontLetterDefinition": ["struct FontLetterDefinition\n", "{\n", "    unsigned short  letteCharUTF16;\n", "    float U;\n", "    float V;\n", "    float width;\n", "    float height;\n", "    float offsetX;\n", "    float offsetY;\n", "    int textureID;\n", "    bool validDefinition;\n", "    int xAdvance;\n", "\n", "    int clipBottom;\n", "};\n"], "CCFontAtlas.cpp_cpp": ["#include \"2d/CCFontAtlas.h\"\n", "#if CC_TARGET_PLATFORM != CC_PLATFORM_WIN32 && CC_TARGET_PLATFORM != CC_PLATFORM_WINRT && CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID\n", "#include <iconv.h>\n", "#elif CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID\n", "#include \"android/jni/Java_org_cocos2dx_lib_Cocos2dxHelper.h\"\n", "#endif\n", "\n", "#include \"2d/CCFontFreeType.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventType.h\"\n", "\n", "NS_CC_BEGIN\n"], "FontAtlas-Font&": ["FontAtlas::FontAtlas(Font &theFont)\n", ": _font(&theFont)\n", "{\n", "    _font->retain();\n", "\n", "    _fontFreeType = dynamic_cast<FontFreeType*>(_font);\n", "    if (_fontFreeType)\n", "    {\n", "        _lineHeight = (float)_font->getFontMaxHeight();\n", "        _fontAscender = _fontFreeType->getFontAscender();\n", "        _letterEdgeExtend = 2;\n", "\n", "        if (_fontFreeType->isDistanceFieldEnabled())\n", "        {\n", "            _letterPadding += 2 * FontFreeType::DistanceMapSpread;    \n", "        }\n", "\n", "        auto outlineSize = _fontFreeType->getOutlineSize();\n", "        if (outlineSize > 0)\n", "        {\n", "            _lineHeight += 2 * outlineSize;\n", "        }\n", "\n", "        \n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "        auto eventDispatcher = Director::getInstance()->getEventDispatcher();\n", "\n", "        _rendererRecreatedListener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, CC_CALLBACK_1(FontAtlas::listenRendererRecreated, this));\n", "        eventDispatcher->addEventListenerWithFixedPriority(_rendererRecreatedListener, 1);\n", "#endif\n", "    }\n", "}\n"], "ccUTF8.cpp_cpp": ["#include \"base/ccUTF8.h\"\n", "#include \"platform/CCCommon.h\"\n", "#include \"base/CCConsole.h\"\n", "#include \"ConvertUTF.h\"\n", "#include <limits>\n", "\n", "NS_CC_BEGIN\n"], "UTF8ToUTF16-std::string&-std::u16string&": ["bool UTF8ToUTF16(const std::string& utf8, std::u16string& outUtf16)\n", "{\n", "    return utfConvert(utf8, outUtf16, ConvertUTF8toUTF16);\n", "}\n"], "CCFontFreeType.h_header": ["\n", "/// @cond DO_NOT_SHOW\n", "\n", "#include \"2d/CCFont.h\"\n", "\n", "#include <string>\n", "#include <ft2build.h>\n", "\n", "#include FT_FREETYPE_H\n", "#include FT_STROKER_H\n", "\n", "NS_CC_BEGIN\n", "\n"], "CCFontFreeType.cpp_cpp": ["#include \"2d/CCFontFreeType.h\"\n", "#include FT_BBOX_H\n", "#include \"edtaa3func.h\"\n", "#include \"2d/CCFontAtlas.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCFontFNT.h_header": ["\n", "/// @cond DO_NOT_SHOW\n", "\n", "#include \"CCFont.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class BMFontConfiguration;\n", "\n"], "CCFontFNT.cpp_cpp": ["#include \"2d/CCFontFNT.h\"\n", "#include \"2d/CCFontAtlas.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCMap.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "\n", "#include <cmath>\n", "#include <set>\n", "#include <unordered_map>\n", "\n", "using namespace std;\n", "NS_CC_BEGIN\n"], "CCFontCharMap.h_header": ["\n", "/// @cond DO_NOT_SHOW\n", "\n", "#include \"2d/CCFont.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Texture2D;\n"], "CCFontCharMap.cpp_cpp": ["#include \"2d/CCFontCharMap.h\"\n", "#include \"2d/CCFontAtlas.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCTextureCache.h_header": ["\n", "#include <string>\n", "#include <mutex>\n", "#include <thread>\n", "#include <condition_variable>\n", "#include <queue>\n", "#include <string>\n", "#include <unordered_map>\n", "#include <functional>\n", "#include \"2d/CCActionInstant.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"platform/CCImage.h\"\n", "#include \"base/CCRefPtr.h\"\n", "\n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "    #include \"platform/CCImage.h\"\n", "    #include <list>\n", "#endif\n", "\n", "// Added by ChenFei 2014-12-16 V3.2 support\n", "#include \"deprecated/CCDictionary.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "/*\n", "* From version 3.0, TextureCache will never be treated as a singleton, it will be owned by director.\n", "* All call by TextureCache::getInstance() should be replaced by Director::getInstance()->getTextureCache().\n", "*/\n", "\n", "/** @brief Singleton that handles the loading of textures.\n", "* Once the texture is loaded, the next time it will return.\n", "* A reference of the previously loaded texture reducing GPU & CPU memory.\n", "*/\n", "\n", "// \u8d44\u6e90\u7c7b\u578b\n"], "CCBillBoard.h_header": ["\n", "#include \"2d/CCSprite.h\"\n", "\n", "NS_CC_BEGIN\n", "/**\n", " * @addtogroup _3d\n", " * @{\n", " */\n", "\n", "/**\n", " * @brief Inherit from Sprite, achieve BillBoard.\n", " */\n"], "CCBillBoard.cpp_cpp": ["#include \"3d/CCBillBoard.h\"\n", "#include \"2d/CCSpriteFrameCache.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/backend/ProgramCache.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCSprite.h_header": ["\n", "#include <string>\n", "#include <set>\n", "\n", "#include \"2d/CCNode.h\"\n", "#include \"2d/CCDrawNode.h\"\n", "#include \"base/CCProtocols.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"renderer/CCTrianglesCommand.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"2d/CCAutoPolygon.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class SpriteBatchNode;\n", "class SpriteFrame;\n", "class Animation;\n", "class Rect;\n", "class Size;\n", "class Texture2D;\n", "struct transformValues_;\n", "\n", "#ifdef SPRITE_RENDER_IN_SUBPIXEL\n", "#undef SPRITE_RENDER_IN_SUBPIXEL\n", "#endif\n", "\n", "#if CC_SPRITEBATCHNODE_RENDER_SUBPIXEL\n", "#define SPRITE_RENDER_IN_SUBPIXEL\n", "#else\n", "#define SPRITE_RENDER_IN_SUBPIXEL(__ARGS__) (ceil(__ARGS__))\n", "#endif\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/**\n", " * Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).\n", " *\n", " * Sprite can be created with an image, or with a sub-rectangle of an image.\n", " *\n", " * To optimize the Sprite rendering, please follow the following best practices:\n", " *  - Put all your sprites in the same spritesheet (http://www.codeandweb.com/what-is-a-sprite-sheet).\n", " *  - Use the same blending function for all your sprites.\n", " *  - ...and the Renderer will automatically \"batch\" your sprites (will draw all of them in one OpenGL call).\n", " *\n", " *  Sprite has 4 types or rendering modes:\n", " *\n", " *  - `QUAD`: Renders the sprite using 2 triangles (1 rectangle): uses small memory, but renders empty pixels (slow)\n", " *  - `POLYGON`: Renders the sprite using many triangles (depending on the setting): Uses more memory, but doesn't render so much empty pixels (faster)\n", " *  - `SLICE9`: Renders the sprite using 18 triangles (9 rectangles). Useful to to scale buttons an other rectangular sprites\n", " *  - `QUAD_BATCHNODE`: Renders the sprite using 2 triangles (1 rectangle) with a static batch, which has some limitations (see below)\n", " *\n", " * By default, the sprite uses `QUAD` mode. But can be changed to `POLYGON` when calling `setPolygonInfo()`. To use `SLICE9` call `setCenterRect()` or\n", " * `serCenterRectNormalized()`. To use `QUAD_BATCHNODE` parent the sprite to a `SpriteBatchNode` object.\n", " *\n", " *\n", " *  `QUAD_BATCHNODE` is deprecated and should be avoid. It has the following limitations:\n", " *\n", " *  - The Alias/Antialias property belongs to `SpriteBatchNode`, so you can't individually set the aliased property.\n", " *  - The Blending function property belongs to `SpriteBatchNode`, so you can't individually set the blending function property.\n", " *  - `ParallaxNode` is not supported, but can be simulated with a \"proxy\" sprite.\n", " *  - Sprites can only have other Sprites (or subclasses of Sprite) as children.\n", " *\n", " * The default anchorPoint in Sprite is (0.5, 0.5).\n", " */\n"], "CCSprite.cpp_cpp": ["#include \"2d/CCSprite.h\"\n", "\n", "#include <algorithm>\n", "#include <stddef.h> // offsetof\n", "#include \"base/ccTypes.h\"\n", "#include \"2d/CCSpriteBatchNode.h\"\n", "#include \"2d/CCAnimationCache.h\"\n", "#include \"2d/CCSpriteFrame.h\"\n", "#include \"2d/CCSpriteFrameCache.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"deprecated/CCString.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/backend/Device.h\"\n", "\n", "NS_CC_BEGIN\n"], "Sprite::initWithTexture-Texture2D*-Rect&-bool": ["bool Sprite::initWithTexture(Texture2D *texture, const Rect& rect, bool rotated)\n", "{\n", "    bool result = false;\n", "    if (Node::init())\n", "    {\n", "        _batchNode = nullptr;\n", "\n", "        _recursiveDirty = false;\n", "        setDirty(false);\n", "\n", "        _flippedX = _flippedY = false;\n", "\n", "        // default transform anchor: center\n", "        setAnchorPoint(Vec2::ANCHOR_MIDDLE);\n", "\n", "        // zwoptex default values\n", "        _offsetPosition.setZero();\n", "\n", "        // clean the Quad\n", "        memset(&_quad, 0, sizeof(_quad));\n", "\n", "        // Atlas: Color\n", "        _quad.bl.colors = Color4B::WHITE;\n", "        _quad.br.colors = Color4B::WHITE;\n", "        _quad.tl.colors = Color4B::WHITE;\n", "        _quad.tr.colors = Color4B::WHITE;\n", "\n", "        // update texture (calls updateBlendFunc)\n", "        setTexture(texture);\n", "        setTextureRect(rect, rotated, rect.size);\n", "\n", "        // by default use \"Self Render\".\n", "        // if the sprite is added to a batchnode, then it will automatically switch to \"batchnode Render\"\n", "        setBatchNode(nullptr);\n", "        result = true;\n", "    }\n", "\n", "    _recursiveDirty = true;\n", "    setDirty(true);\n", "\n", "    return result;\n", "}\n"], "Sprite": ["Sprite::Sprite(void)\n", ": _batchNode(nullptr)\n", ", _shouldBeHidden(false)\n", ", _texture(nullptr)\n", ", _spriteFrame(nullptr)\n", ", _insideBounds(true)\n", ",m_fScaleTexture(1)\n", ",m_fScaleX0(1)\n", ",m_fScaleY0(1)\n", ",m_fStretchX0(1)\n", ",m_fStretchY0(1)\n", ",m_isSmallTexture(false)\n", ",m_quadIndices(nullptr)\n", ",m_quad(nullptr)\n", ",m_quadSize(0)\n", ",m_wrapRect(Rect::ZERO)\n", ",m_untrimmedSize(Size::ZERO)\n", ",m_wrapType(spriteWrapType_default)\n", ",_isFixedPS(false)\n", "{\n", "#if CC_SPRITE_DEBUG_DRAW\n", "    debugDraw(true);\n", "#endif //CC_SPRITE_DEBUG_DRAW\n", "    spriteCount++;\n", "    if (Director::getInstance()->isDisplayStats()) {\n", "        //lixu 20160217 count sprite for display\n", "        \n", "        Director::getInstance()->setSpriteCount(spriteCount);\n", "    }\n", "    \n", "    // \u52a0\u5165\u5217\u8868\n", "    m_nodeEntry.insert(this);\n", "    //InsertTailList(&m_nodeHead, &m_nodeEntry);\n", "}\n"], "Sprite::draw-Renderer*-Mat4&-uint32_t": ["void Sprite::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)\n", "{\n", "    if (_texture == nullptr || _texture->getBackendTexture() == nullptr)\n", "        return;\n", "    \n", "    //TODO: arnold: current camera can be a non-default one.\n", "    setMVPMatrixUniform();\n", "\n", "#if CC_USE_CULLING\n", "    // Don't calculate the culling if the transform was not updated\n", "    auto visitingCamera = Camera::getVisitingCamera();\n", "    auto defaultCamera = Camera::getDefaultCamera();\n", "    if (visitingCamera == nullptr)\n", "        _insideBounds = true;\n", "    else if (visitingCamera == defaultCamera)\n", "        _insideBounds = ((flags & FLAGS_TRANSFORM_DIRTY) || visitingCamera->isViewProjectionUpdated()) ? renderer->checkVisibility(transform, _contentSize) : _insideBounds;\n", "    else\n", "        // XXX: this always return true since\n", "        _insideBounds = renderer->checkVisibility(transform, _contentSize);\n", "\n", "    if(_insideBounds)\n", "#endif\n", "    {\n", "        _trianglesCommand.init(_globalZOrder,\n", "                               _texture,\n", "                               _blendFunc,\n", "                               _polyInfo.triangles,\n", "                               transform,\n", "                               flags);\n", "        renderer->addCommand(&_trianglesCommand);\n", "        \n", "#if CC_SPRITE_DEBUG_DRAW\n", "            _debugDrawNode->clear();\n", "            auto count = _polyInfo.triangles.indexCount / 3;\n", "            auto indices = _polyInfo.triangles.indices;\n", "            auto verts = _polyInfo.triangles.verts;\n", "            for(unsigned int i = 0; i < count; i++)\n", "            {\n", "                //draw 3 lines\n", "                Vec3 from =verts[indices[i*3]].vertices;\n", "                Vec3 to = verts[indices[i*3+1]].vertices;\n", "                _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x,to.y), Color4F::WHITE);\n", "                \n", "                from =verts[indices[i*3+1]].vertices;\n", "                to = verts[indices[i*3+2]].vertices;\n", "                _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x,to.y), Color4F::WHITE);\n", "                \n", "                from =verts[indices[i*3+2]].vertices;\n", "                to = verts[indices[i*3]].vertices;\n", "                _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x,to.y), Color4F::WHITE);\n", "            }\n", "#endif //CC_SPRITE_DEBUG_DRAW\n", "    }\n", "}\n"], "CCFontAtlasCache.h_header": ["\n", "/// @cond DO_NOT_SHOW\n", "\n", "#include <unordered_map>\n", "#include \"base/ccTypes.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class FontAtlas;\n", "class Texture2D;\n", "struct _ttfConfig;\n", "\n"], "CCFontAtlasCache.cpp_cpp": ["\n", "#include \"base/CCDirector.h\"\n", "#include \"2d/CCFontFNT.h\"\n", "#include \"2d/CCFontFreeType.h\"\n", "#include \"2d/CCFontAtlas.h\"\n", "#include \"2d/CCFontCharMap.h\"\n", "#include \"2d/CCLabel.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCClippingNode.h_header": ["\n", "#include \"2d/CCNode.h\"\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCCallbackCommand.h\"\n", "#include <unordered_map>\n", "NS_CC_BEGIN\n", "\n", "class StencilStateManager;\n", "/**\n", " *  @addtogroup _2d\n", " *  @{\n", " */\n", "/** ClippingNode is a subclass of Node.\n", " * It draws its content (children) clipped using a stencil.\n", " * The stencil is an other Node that will not be drawn.\n", " * The clipping is done using the alpha part of the stencil (adjusted with an alphaThreshold).\n", " */\n"], "CCClippingNode.cpp_cpp": [" * Copyright (c) 2013-2016 Chukong Technologies Inc.\n", " * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n", " *\n", " * cocos2d-x: http://www.cocos2d-x.org\n", " *\n", " * Permission is hereby granted, free of charge, to any person obtaining a copy\n", " * of this software and associated documentation files (the \"Software\"), to deal\n", " * in the Software without restriction, including without limitation the rights\n", " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n", " * copies of the Software, and to permit persons to whom the Software is\n", " * furnished to do so, subject to the following conditions:\n", " *\n", " * The above copyright notice and this permission notice shall be included in\n", " * all copies or substantial portions of the Software.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n", " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n", " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n", " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n", " * THE SOFTWARE.\n", " *\n", " */\n", "#include \"2d/CCClippingNode.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCStencilStateManager.h\"\n", "\n", "NS_CC_BEGIN\n"], "ClippingNode::init-Node*": ["bool ClippingNode::init(Node *stencil)\n", "{\n", "    setStencil(stencil);\n", "    return true;\n", "}\n"], "ClippingNode::setStencil-Node*": ["void ClippingNode::setStencil(Node *stencil)\n", "{\n", "    //early out if the stencil is already set\n", "    if (_stencil == stencil)\n", "        return;\n", "    \n", "#if CC_ENABLE_GC_FOR_NATIVE_OBJECTS\n", "    auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();\n", "    if (sEngine)\n", "    {\n", "        if (_stencil)\n", "            sEngine->releaseScriptObject(this, _stencil);\n", "        if (stencil)\n", "            sEngine->retainScriptObject(this, stencil);\n", "    }\n", "#endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS\n", "    \n", "    //cleanup current stencil\n", "    if(_stencil != nullptr && _stencil->isRunning())\n", "    {\n", "        _stencil->onExitTransitionDidStart();\n", "        _stencil->onExit();\n", "    }\n", "    CC_SAFE_RELEASE_NULL(_stencil);\n", "    \n", "    //initialise new stencil\n", "    _stencil = stencil;\n", "    CC_SAFE_RETAIN(_stencil);\n", "    if(_stencil != nullptr && this->isRunning())\n", "    {\n", "        _stencil->onEnter();\n", "        if(this->_isTransitionFinished)\n", "        {\n", "            _stencil->onEnterTransitionDidFinish();\n", "        }\n", "    }\n", "\n", "    if (_stencil != nullptr)\n", "    {\n", "        _originalStencilProgramState[_stencil] = _stencil->getProgramState();\n", "        auto& children = _stencil->getChildren();\n", "        for (const auto &child : children) {\n", "            _originalStencilProgramState[child] = child->getProgramState();\n", "        }\n", "    }\n", "}\n"], "CCProgressTimer.h_header": ["\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"2d/CCNode.h\"\n", "#include \"renderer/CCPipelineDescriptor.h\"\n", "\n", "#include <vector>\n", "\n", "NS_CC_BEGIN\n", "\n", "class Sprite;\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/**\n", "  * @brief ProgressTimer is a subclass of Node.\n", "  * It renders the inner sprite according to the percentage.\n", "  * The progress can be Radial, Horizontal or vertical.\n", "  * @since v0.99.1\n", "  */\n"], "CCProgressTimer.cpp_cpp": ["#include <algorithm>\n", "#include <stddef.h> // offsetof\n", "#include \"base/ccTypes.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"2d/CCSprite.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "\n", "NS_CC_BEGIN\n"], "ProgressTimer::initWithSprite-Sprite*": ["bool ProgressTimer::initWithSprite(Sprite* sp)\n", "{\n", "    setAnchorPoint(Vec2(0.5f,0.5f));\n", "    setMidpoint(Vec2(0.5f, 0.5f));\n", "    setBarChangeRate(Vec2(1,1));\n", "    setSprite(sp);\n", "\n", "    CC_SAFE_RELEASE(_programState);\n", "    CC_SAFE_RELEASE(_programState2);\n", "    _programState = initPipelineDescriptor(_customCommand, true, _locMVP1, _locTex1); \n", "    _programState2 = initPipelineDescriptor(_customCommand2, false, _locMVP2, _locTex2);\n", "    \n", "    return true;\n", "}\n"], "ProgressTimer::draw-Renderer*-Mat4&-uint32_t": ["void ProgressTimer::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)\n", "{\n", "    if( _vertexData.empty() || ! _sprite)\n", "        return;\n", "\n", "    const cocos2d::Mat4& projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);\n", "    Mat4 finalMat = projectionMat * transform;\n", "    _programState->setUniform(_locMVP1, finalMat.m, sizeof(finalMat.m));\n", "    _programState->setTexture(_locTex1, 0, _sprite->getTexture()->getBackendTexture());\n", "\n", "    if(_type == Type::BAR)\n", "    {\n", "        if (!_reverseDirection)\n", "        {\n", "            _customCommand.init(_globalZOrder, _sprite->getBlendFunc());\n", "            renderer->addCommand(&_customCommand);\n", "        }\n", "        else\n", "        {\n", "            _customCommand.init(_globalZOrder, _sprite->getBlendFunc());\n", "            renderer->addCommand(&_customCommand);\n", "\n", "            _customCommand2.init(_globalZOrder, _sprite->getBlendFunc());\n", "            _programState2->setUniform(_locMVP2, finalMat.m, sizeof(finalMat.m));\n", "            _programState2->setTexture(_locTex2, 0, _sprite->getTexture()->getBackendTexture());\n", "            renderer->addCommand(&_customCommand2);\n", "        }\n", "    }\n", "    else\n", "    {\n", "        _customCommand.init(_globalZOrder, _sprite->getBlendFunc());\n", "        renderer->addCommand(&_customCommand);\n", "    }\n", "}\n"], "CCRenderTexture.h_header": ["\n", "#include \"2d/CCNode.h\"\n", "#include \"2d/CCSprite.h\"\n", "#include \"platform/CCImage.h\"\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCCallbackCommand.h\"\n", "#include \"renderer/backend/Types.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "namespace backend\n", "{\n", "    class TextureBackend;\n", "}\n", "\n", "class EventCustom;\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/**\n", " * @brief RenderTexture is a generic rendering target. To render things into it,\n", " * simply construct a render target, call begin on it, call visit on any cocos\n", " * scenes or objects to render them, and call end. For convenience, render texture\n", " * adds a sprite as it's display child with the results, so you can simply add\n", " * the render texture to your scene and treat it like any other CocosNode.\n", " * There are also functions for saving the render texture to disk in PNG or JPG format.\n", " * @since v0.8.1\n", " */\n"], "CCRenderTexture.cpp_cpp": ["\n", "#include \"base/ccUtils.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"renderer/backend/Texture.h\"\n", "\n", "bool g_RTScreenEnabled = false;//\u5168\u5c40\u6e32\u67d3\u6807\u8bc6\n", "float g_RTScissorScaleX = 1.0f;\n", "float g_RTScissorScaleY = 1.0f;\n", "NS_CC_BEGIN\n"], "RenderTexture": ["RenderTexture::RenderTexture()\n", ": _keepMatrix(false)\n", ", _rtTextureRect(Rect::ZERO)\n", ", _fullRect(Rect::ZERO)\n", ", _fullviewPort(Rect::ZERO)\n", ", _FBO(0)\n", ", _depthRenderBufffer(0)\n", ", _oldFBO(0)\n", ", _texture(0)\n", ", _textureCopy(0)\n", ", _UITextureImage(nullptr)\n", ", _pixelFormat(Texture2D::PixelFormat::RGBA8888)\n", ", _clearFlags(0)\n", ", _clearColor(Color4F(0,0,0,0))\n", ", _clearDepth(0.0f)\n", ", _clearStencil(0)\n", ", _autoDraw(false)\n", ", _sprite(nullptr)\n", ", _saveFileCallback(nullptr)\n", "{\n", " \n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "    // Listen this event to save render texture before come to background.\n", "    // Then it can be restored after coming to foreground on Android.\n", "    auto toBackgroundListener = EventListenerCustom::create(EVENT_COME_TO_BACKGROUND, CC_CALLBACK_1(RenderTexture::listenToBackground, this));\n", "    getEventDispatcher()->addEventListenerWithSceneGraphPriority(toBackgroundListener, this);\n", "\n", "    auto toForegroundListener = EventListenerCustom::create(EVENT_COME_TO_FOREGROUND, CC_CALLBACK_1(RenderTexture::listenToForeground, this));\n", "    getEventDispatcher()->addEventListenerWithSceneGraphPriority(toForegroundListener, this);\n", "#endif\n", "}\n"], "CCAutoPolygon.h_header": ["\n", "#include <string>\n", "#include <vector>\n", "#include \"platform/CCImage.h\"\n", "#include \"renderer/CCTrianglesCommand.h\"\n", "\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/**\n", " * PolygonInfo is an object holding the required data to display Sprites.\n", " * It can be a simple as a triangle, or as complex as a whole 3D mesh\n", " */\n"], "CCAutoPolygon.cpp_cpp": ["#include \"CCAutoPolygon.h\"\n", "#include \"poly2tri/poly2tri.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "//#include \"clipper/clipper.hpp\"\n", "#include <algorithm>\n", "#include <math.h>\n", "\n", "\n", "\n", "USING_NS_CC;\n"], "CCSpriteBatchNode.h_header": ["\n", "#include <vector>\n", "\n", "#include \"2d/CCNode.h\"\n", "#include \"base/CCProtocols.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"renderer/CCQuadCommand.h\"\n", "\n", "#define UseSpDynBatch\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "\n", "class Sprite;\n", "\n", "/** SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call\n", " * (often known as \"batch draw\").\n", " *\n", " * A SpriteBatchNode can reference one and only one texture (one image file, one texture atlas).\n", " * Only the Sprites that are contained in that texture can be added to the SpriteBatchNode.\n", " * All Sprites added to a SpriteBatchNode are drawn in one OpenGL ES draw call.\n", " * If the Sprites are not added to a SpriteBatchNode then an OpenGL ES draw call will be needed for each one, which is less efficient.\n", " *\n", " *\n", " * Limitations:\n", " *  - The only object that is accepted as child (or grandchild, grand-grandchild, etc...) is Sprite or any subclass of Sprite. eg: particles, labels and layer can't be added to a SpriteBatchNode.\n", " *  - Either all its children are Aliased or Antialiased. It can't be a mix. This is because \"alias\" is a property of the texture, and all the sprites share the same texture.\n", " *\n", " * @since v0.7.1\n", " */\n", "\n", "//\u4fee\u6539\u652f\u6301\u4e0d\u540c\u7eb9\u7406\u7684\u8d34\u56fe   zOrder<0 \u5728\u5f53\u524dspriteBatchNode \u4e4b\u4e0b\uff0c >=0 \u5728\u4e0a\u8fb9\uff0c\u65e0\u6cd5\u63d2\u5165SpriteBatchNode\u5b50\u8282\u70b9\u4e4b\u95f4\n", "//\u5c06SpriteBatchNode \u53d8\u6362\u94fe\u63a5\u81f3m_pMulTextureNode \u5b9e\u73b0\u652f\u6301  by sxy\n"], "CCSpriteBatchNode.cpp_cpp": ["#include <stddef.h> // offsetof\n", "#include \"base/ccTypes.h\"\n", "#include \"2d/CCSprite.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCProfiling.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCQuadCommand.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/backend/Device.h\"\n", "\n", "\n", "\n", "NS_CC_BEGIN\n"], "CCImage.h_header": ["/// @cond DO_NOT_SHOW\n", "\n", "#include \"base/CCRef.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "\n", "#if defined(CC_USE_WIC)\n", "#include \"WICImageLoader-winrt.h\"\n", "#endif\n", "\n", "// premultiply alpha, or the effect will wrong when want to use other pixel format in Texture2D,\n", "// such as RGB888, RGB5A1\n", "#define CC_RGB_PREMULTIPLY_ALPHA(vr, vg, vb, va) \\\n", "    (unsigned)(((unsigned)((unsigned char)(vr) * ((unsigned char)(va) + 1)) >> 8) | \\\n", "    ((unsigned)((unsigned char)(vg) * ((unsigned char)(va) + 1) >> 8) << 8) | \\\n", "    ((unsigned)((unsigned char)(vb) * ((unsigned char)(va) + 1) >> 8) << 16) | \\\n", "    ((unsigned)(unsigned char)(va) << 24))\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup platform\n", " * @{\n", " */\n", "\n", "/**\n", " @brief Structure which can tell where mipmap begins and how long is it\n", " */\n"], "block_one__MipmapInfo": ["typedef struct _MipmapInfo\n", "{\n", "    unsigned char* address;\n", "    int len;\n", "    _MipmapInfo():address(NULL),len(0){}\n", "}MipmapInfo;\n"], "CCImage.cpp_cpp": ["\n", "#include \"platform/CCImage.h\"\n", "\n", "#include <string>\n", "#include <ctype.h>\n", "\n", "#include \"base/CCData.h\"\n", "#include \"base/ccConfig.h\" // CC_USE_JPEG, CC_USE_TIFF, CC_USE_WEBP\n", "#include \"platform/CCGL.h\"\n", "extern bool g_isSoftPreAlphaMul;\n", "bool GetCompressFileData(const char* fileNameNo_Z,unsigned char*& outMemory,ssize_t& outMemoryLen);\n", "extern \"C\"\n", "{\n", "    // To resolve link error when building 32bits with Xcode 6.\n", "    // More information please refer to the discussion in https://github.com/cocos2d/cocos2d-x/pull/6986\n", "#if defined (__unix) || (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n", "#ifndef __ENABLE_COMPATIBILITY_WITH_UNIX_2003__\n", "#define __ENABLE_COMPATIBILITY_WITH_UNIX_2003__\n", "#include <stdio.h>\n", "#include <dirent.h>\n", "    FILE *fopen$UNIX2003( const char *filename, const char *mode )\n", "    {\n", "        return fopen(filename, mode);\n", "    }\n", "    size_t fwrite$UNIX2003( const void *a, size_t b, size_t c, FILE *d )\n", "    {\n", "        return fwrite(a, b, c, d);\n", "    }\n", "    int fputs$UNIX2003(const char *res1, FILE *res2){\n", "        return fputs(res1,res2);\n", "    }\n", "    char *strerror$UNIX2003( int errnum )\n", "    {\n", "        return strerror(errnum);\n", "    }\n", "    DIR * opendir$INODE64$UNIX2003( char * dirName )\n", "    {\n", "        return opendir( dirName );\n", "    }\n", "    DIR * opendir$INODE64( char * dirName )\n", "    {\n", "        return opendir( dirName );\n", "    }\n", "\n", "    int closedir$UNIX2003(DIR * dir)\n", "    {\n", "        return closedir(dir);\n", "    }\n", "\n", "    struct dirent * readdir$INODE64( DIR * dir )\n", "    {\n", "        return readdir( dir );\n", "    }\n", "#endif\n", "#endif\n", "\n", "#if CC_USE_PNG\n", "#include \"png.h\"\n", "#endif //CC_USE_PNG\n", "\n", "#if CC_USE_TIFF\n", "#include \"tiffio.h\"\n", "#endif //CC_USE_TIFF\n", "\n", "#include \"base/etc1.h\"\n", "    \n", "#if CC_USE_JPEG\n", "#include \"jpeglib.h\"\n", "#endif // CC_USE_JPEG\n", "}\n", "#include \"base/s3tc.h\"\n", "#include \"base/atitc.h\"\n", "#include \"base/pvr.h\"\n", "#include \"base/TGAlib.h\"\n", "\n", "#if CC_USE_WEBP\n", "#include \"decode.h\"\n", "#endif // CC_USE_WEBP\n", "\n", "#include \"base/ccMacros.h\"\n", "#include \"CCCommon.h\"\n", "#include \"CCStdC.h\"\n", "#include \"CCFileUtils.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"base/ZipUtils.h\"\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n", "#include \"android/CCFileUtils-android.h\"\n", "#endif\n", "\n", "#define CC_GL_ATC_RGB_AMD                                          0x8C92\n", "#define CC_GL_ATC_RGBA_EXPLICIT_ALPHA_AMD                          0x8C93\n", "#define CC_GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD                      0x87EE\n", "\n", "NS_CC_BEGIN\n"], "Image::initWithImageFile-std::string&": ["bool Image::initWithImageFile(const std::string& path)\n", "{\n", "    bool ret = false;\n", "    _filePath = FileUtils::getInstance()->fullPathForFilename(path);\n", "\n", "#ifdef EMSCRIPTEN\n", "    // Emscripten includes a re-implementation of SDL that uses HTML5 canvas\n", "    // operations underneath. Consequently, loading images via IMG_Load (an SDL\n", "    // API) will be a lot faster than running libpng et al as compiled with\n", "    // Emscripten.\n", "    SDL_Surface *iSurf = IMG_Load(fullPath.c_str());\n", "\n", "    int size = 4 * (iSurf->w * iSurf->h);\n", "    ret = initWithRawData((const unsigned char*)iSurf->pixels, size, iSurf->w, iSurf->h, 8, true);\n", "\n", "    unsigned int *tmp = (unsigned int *)_data;\n", "    int nrPixels = iSurf->w * iSurf->h;\n", "    for(int i = 0; i < nrPixels; i++)\n", "    {\n", "        unsigned char *p = _data + i * 4;\n", "        tmp[i] = CC_RGB_PREMULTIPLY_ALPHA( p[0], p[1], p[2], p[3] );\n", "    }\n", "\n", "    SDL_FreeSurface(iSurf);\n", "#else\n", "    \n", "    Data data ;\n", "    unsigned char* outMemory=NULL;\n", "    ssize_t memLen=0;\n", "    //for zip  pvr\n", "    if(_filePath.length()==0)\n", "        _filePath =path;\n", "    if( GetCompressFileData(_filePath.c_str(),outMemory,memLen) )\n", "        data.fastSet(outMemory, memLen);\n", "    else\n", "    {\n", "       // timeval nowTime = GetCurTime();\n", "        data= FileUtils::getInstance()->getDataFromFile(_filePath);\n", "       // int nCost =GetDiffTime(nowTime);\n", "        //CCLOG(\"io:cost: %d %s \\n\",nCost, _filePath.c_str());\n", "    }\n", "    \n", "       \n", "    if (!data.isNull())\n", "    {\n", "        ret = initWithImageData(data.getBytes(), data.getSize());\n", "    }\n", "#endif // EMSCRIPTEN\n", "\n", "    return ret;\n", "}\n"], "Image::initWithImageData-unsigned-ssize_t": ["bool Image::initWithImageData(const unsigned char * data, ssize_t dataLen)\n", "{\n", "    bool ret = false;\n", "    \n", "    do\n", "    {\n", "        CC_BREAK_IF(! data || dataLen <= 0);\n", "        \n", "        unsigned char* unpackedData = nullptr;\n", "        ssize_t unpackedLen = 0;\n", "        \n", "        //detecgt and unzip the compress file\n", "        if (ZipUtils::isCCZBuffer(data, dataLen))\n", "        {\n", "            timeval nowTime = GetCurTime();\n", "            unpackedLen = ZipUtils::inflateCCZBuffer(data, dataLen, &unpackedData);\n", "            int nCost =GetDiffTime(nowTime);\n", "            // CCLOG(\"io:uzipccz:cost: %d %s \\n\",nCost, _filePath.c_str());\n", "        }\n", "        else if (ZipUtils::isLZ4Buffer(data, dataLen))\n", "        {\n", "            timeval nowTime = GetCurTime();\n", "            unpackedLen = ZipUtils::inflateLZ4Buffer(data, dataLen, &unpackedData);\n", "            int nCost =GetDiffTime(nowTime);\n", "            CCLOG(\"io:uziplz4:cost: %d %s \\n\",nCost, _filePath.c_str());\n", "        }\n", "        else if (ZipUtils::isGZipBuffer(data, dataLen))\n", "        {\n", "            timeval nowTime = GetCurTime();\n", "            unpackedLen = ZipUtils::inflateMemory(const_cast<unsigned char*>(data), dataLen, &unpackedData);\n", "            int nCost =GetDiffTime(nowTime);\n", "            CCLOG(\"io:uzipgzip:cost: %d %s \\n\",nCost, _filePath.c_str());\n", "        }\n", "        else\n", "        {\n", "            unpackedData = const_cast<unsigned char*>(data);\n", "            unpackedLen = dataLen;\n", "        }\n", "        if( unpackedLen == -1 )\n", "            return false;\n", "        \n", "        _fileType = detectFormat(unpackedData, unpackedLen);\n", "\n", "        switch (_fileType)\n", "        {\n", "        case Format::PNG:\n", "            ret = initWithPngData(unpackedData, unpackedLen);\n", "            break;\n", "        case Format::JPG:\n", "            ret = initWithJpgData(unpackedData, unpackedLen);\n", "            break;\n", "        case Format::WEBP:\n", "            ret = initWithWebpData(unpackedData, unpackedLen);\n", "            break;\n", "        case Format::PVR:\n", "            ret = initWithPVRData(unpackedData, unpackedLen);\n", "            break;\n", "        case Format::ETC:\n", "            ret = initWithETCData(unpackedData, unpackedLen);\n", "            break;\n", "        case Format::S3TC:\n", "            ret = initWithS3TCData(unpackedData, unpackedLen);\n", "            break;\n", "        case Format::ATITC:\n", "            ret = initWithATITCData(unpackedData, unpackedLen);\n", "            break;\n", "        default:\n", "            {\n", "                CCAssert(false, \"unsupport image format!\");\n", "//                // load and detect image format\n", "//                tImageTGA* tgaData = tgaLoadBuffer(unpackedData, unpackedLen);\n", "//                \n", "//                if (tgaData != nullptr && tgaData->status == TGA_OK)\n", "//                {\n", "//                    ret = initWithTGAData(tgaData);\n", "//                }\n", "//                else\n", "//                {\n", "//                    CCAssert(false, \"unsupport image format!\");\n", "//                }\n", "//                \n", "//                free(tgaData);\n", "                break;\n", "            }\n", "        }\n", "        \n", "        if(unpackedData != data)\n", "        {\n", "            free(unpackedData);\n", "        }\n", "    } while (0);\n", "    \n", "    return ret;\n", "}\n"], "Image::saveToFile-std::string&-bool": ["bool Image::saveToFile(const std::string& filename, bool isToRGB)\n", "{\n", "    //only support for backend::PixelFormat::RGB888 or backend::PixelFormat::RGBA8888 uncompressed data\n", "    if (isCompressed() || (_pixelFormat != backend::PixelFormat::RGB888 && _pixelFormat != backend::PixelFormat::RGBA8888))\n", "    {\n", "        CCLOG(\"cocos2d: Image: saveToFile is only support for backend::PixelFormat::RGB888 or backend::PixelFormat::RGBA8888 uncompressed data for now\");\n", "        return false;\n", "    }\n", "\n", "    bool ret = false;\n", "\n", "    do \n", "    {\n", "\n", "        CC_BREAK_IF(filename.size() <= 4);\n", "\n", "        std::string strLowerCasePath(filename);\n", "        for (unsigned int i = 0; i < strLowerCasePath.length(); ++i)\n", "        {\n", "            strLowerCasePath[i] = tolower(filename[i]);\n", "        }\n", "        \n", "        CCLOG(\"try saveScreenShot 5+++, file type:%d,file name:%s\",static_cast<int>(_fileType),filename.c_str());\n", "        switch (_fileType)\n", "        {\n", "            case Format::PNG:\n", "                \n", "                CCLOG(\"try saveScreenShot 6 png+++\");\n", "                return saveImageToPNG(filename, isToRGB) ;\n", "                break;\n", "            case Format::JPG:\n", "                CCLOG(\"try saveScreenShot 7 jpg+++\");\n", "                return saveImageToJPG(filename) ;\n", "                break;\n", "            default:\n", "            {\n", "                if (std::string::npos != strLowerCasePath.find(\".png\"))\n", "                {\n", "                    CCLOG(\"try saveScreenShot 8 png+++\");\n", "                    return saveImageToPNGEx(filename, isToRGB) ;\n", "                }\n", "                else if (std::string::npos != strLowerCasePath.find(\".jpg\"))\n", "                {\n", "                    CCLOG(\"try saveScreenShot 9 jpg+++\");\n", "                    return saveImageToJPG(filename) ;\n", "                }\n", "                else\n", "                {\n", "                    CCLOG(\"try saveScreenShot 10 fail+++\");\n", "                    return 0;\n", "                }\n", "            }\n", "        }\n", "        ret = true;\n", "    } while (0);\n", "\n", "    return ret;\n", "}\n"], "CCParticleSystemQuad.h_header": ["\n", "#include \"2d/CCParticleSystem.h\"\n", "#include \"renderer/CCQuadCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class SpriteFrame;\n", "class EventCustom;\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/** @class ParticleSystemQuad\n", " * @brief ParticleSystemQuad is a subclass of ParticleSystem.\n", " It includes all the features of ParticleSystem.\n", " Special features and Limitations:\n", " - Particle size can be any float number.\n", " - The system can be scaled.\n", " - The particles can be rotated.\n", " - It supports subrects.\n", " - It supports batched rendering since 1.1.\n", " @since v0.8\n", " @js NA\n", " */\n"], "CCParticleSystemQuad.cpp_cpp": ["\n", "#include \"2d/CCParticleSystemQuad.h\"\n", "\n", "#include <algorithm>\n", "#include <stddef.h> // offsetof\n", "#include \"base/ccTypes.h\"\n", "#include \"2d/CCSpriteFrame.h\"\n", "#include \"2d/CCParticleBatchNode.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"renderer/CCTexturecache.h\"\n", "#include \"deprecated/CCString.h\"\n", "#include \"math/CCMathBase.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "\n", "\n", "NS_CC_BEGIN\n"], "ParticleSystemQuad": ["ParticleSystemQuad::ParticleSystemQuad()\n", ":_quads(nullptr)\n", ",_indices(nullptr)\n", ",_VAOname(0)\n", "{\n", "    auto& pipelieDescriptor = _quadCommand.getPipelineDescriptor();\n", "    auto* program = backend::Program::getBuiltinProgram(backend::ProgramType::POSITION_TEXTURE_COLOR);\n", "    _programState = new (std::nothrow) backend::ProgramState(program);\n", "    pipelieDescriptor.programState = _programState;\n", "    _mvpMatrixLocaiton = pipelieDescriptor.programState->getUniformLocation(\"u_MVPMatrix\");\n", "    _textureLocation = pipelieDescriptor.programState->getUniformLocation(\"u_texture\");\n", "    \n", "    auto vertexLayout = _programState->getVertexLayout();\n", "    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();\n", "    auto iter = attributeInfo.find(\"a_position\");\n", "    if(iter != attributeInfo.end())\n", "    {\n", "        vertexLayout->setAttribute(\"a_position\", iter->second.location, backend::VertexFormat::FLOAT3, 0, false);\n", "    }\n", "    iter = attributeInfo.find(\"a_texCoord\");\n", "    if(iter != attributeInfo.end())\n", "    {\n", "        vertexLayout->setAttribute(\"a_texCoord\", iter->second.location, backend::VertexFormat::FLOAT2, offsetof(V3F_C4B_T2F, texCoords), false);\n", "    }\n", "    iter = attributeInfo.find(\"a_color\");\n", "    if(iter != attributeInfo.end())\n", "    {\n", "        vertexLayout->setAttribute(\"a_color\", iter->second.location, backend::VertexFormat::UBYTE4, offsetof(V3F_C4B_T2F, colors), true);\n", "    }\n", "    vertexLayout->setLayout(sizeof(V3F_C4B_T2F));\n", "}\n"], "ParticleSystemQuad::initWithTotalParticles-int": ["bool ParticleSystemQuad::initWithTotalParticles(int numberOfParticles)\n", "{\n", "    // base initialization\n", "    if( ParticleSystem::initWithTotalParticles(numberOfParticles) )\n", "    {\n", "        // allocating data space\n", "        if( ! this->allocMemory() ) {\n", "            this->release();\n", "            return false;\n", "        }\n", "        \n", "        initIndices();\n", "        \n", "        if( Texture2D::ms_isOnPause )\n", "        {\n", "            CCLOGCRITICAL(\"zym onpause cache ParticleSystemQuad::initWithTotalParticles [%p]\", this );\n", "            TextureCache::getInstance()->AddCachGLData(this, EGLDataType::EGLData_Particle, EGLOper::EGLOper_Create );\n", "\n", "            return true;\n", "        }\n", "        \n", "//        setupVBO();\n", "\n", "        \n", "        \n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "        // Need to listen the event only when not use batchnode, because it will use VBO\n", "        auto listener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, CC_CALLBACK_1(ParticleSystemQuad::listenRendererRecreated, this));\n", "        getEventDispatcher()->addEventListenerWithSceneGraphPriority(listener, this);\n", "#endif\n", "        \n", "        return true;\n", "    }\n", "    return false;\n", "}\n"], "updatePosWithParticle-V3F_C4B_T2F_Quad*-Vec2&-float-float": ["inline void updatePosWithParticle(V3F_C4B_T2F_Quad *quad, const Vec2& newPosition,float size,float rotation)\n", "{\n", "    // vertices\n", "    float size_2 = size/2;\n", "    float x1 = -size_2;\n", "    float y1 = -size_2;\n", "    \n", "    float x2 = size_2;\n", "    float y2 = size_2;\n", "    float x = newPosition.x;\n", "    float y = newPosition.y;\n", "    \n", "    float r = (float)-CC_DEGREES_TO_RADIANS(rotation);\n", "    float cr = cosf(r);\n", "    float sr = sinf(r);\n", "    float ax = x1 * cr - y1 * sr + x;\n", "    float ay = x1 * sr + y1 * cr + y;\n", "    float bx = x2 * cr - y1 * sr + x;\n", "    float by = x2 * sr + y1 * cr + y;\n", "    float cx = x2 * cr - y2 * sr + x;\n", "    float cy = x2 * sr + y2 * cr + y;\n", "    float dx = x1 * cr - y2 * sr + x;\n", "    float dy = x1 * sr + y2 * cr + y;\n", "    \n", "    // bottom-left\n", "    quad->bl.vertices.x = ax;\n", "    quad->bl.vertices.y = ay;\n", "    \n", "    // bottom-right vertex:\n", "    quad->br.vertices.x = bx;\n", "    quad->br.vertices.y = by;\n", "    \n", "    // top-left vertex:\n", "    quad->tl.vertices.x = dx;\n", "    quad->tl.vertices.y = dy;\n", "    \n", "    // top-right vertex:\n", "    quad->tr.vertices.x = cx;\n", "    quad->tr.vertices.y = cy;\n", "}\n"], "ParticleSystemQuad::updateParticleQuads": ["void ParticleSystemQuad::updateParticleQuads()\n", "{\n", "    if (_particleCount <= 0) {\n", "        return;\n", "    }\n", " \n", "    Vec2 currentPosition;\n", "    if (_positionType == PositionType::FREE)\n", "    {\n", "        currentPosition = this->convertToWorldSpace(Vec2::ZERO);\n", "    }\n", "    else if (_positionType == PositionType::RELATIVE)\n", "    {\n", "        currentPosition = _position;\n", "    }\n", "    \n", "    V3F_C4B_T2F_Quad *startQuad;\n", "    Vec2 pos = Vec2::ZERO;\n", "    if (_batchNode)\n", "    {\n", "        V3F_C4B_T2F_Quad *batchQuads = _batchNode->getTextureAtlas()->getQuads();\n", "        startQuad = &(batchQuads[_atlasIndex]);\n", "        pos = _position;\n", "    }\n", "    else\n", "    {\n", "        startQuad = &(_quads[0]);\n", "    }\n", "    \n", "    if( _positionType == PositionType::FREE )\n", "    {\n", "        Vec3 p1(currentPosition.x, currentPosition.y, 0);\n", "        Mat4 worldToNodeTM = getWorldToNodeTransform();\n", "        worldToNodeTM.transformPoint(&p1);\n", "        Vec3 p2;\n", "        Vec2 newPos;\n", "        float* startX = _particleData.startPosX;\n", "        float* startY = _particleData.startPosY;\n", "        float* x = _particleData.posx;\n", "        float* y = _particleData.posy;\n", "        float* s = _particleData.size;\n", "        float* r = _particleData.rotation;\n", "        V3F_C4B_T2F_Quad* quadStart = startQuad;\n", "        for (int i = 0 ; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)\n", "        {\n", "            p2.set(*startX, *startY, 0);\n", "            worldToNodeTM.transformPoint(&p2);\n", "            newPos.set(*x,*y);\n", "            p2 = p1 - p2;\n", "            newPos.x -= p2.x - pos.x;\n", "            newPos.y -= p2.y - pos.y;\n", "            updatePosWithParticle(quadStart, newPos, *s, *r);\n", "        }\n", "    }\n", "    else if( _positionType == PositionType::RELATIVE )\n", "    {\n", "        Vec2 newPos;\n", "        float* startX = _particleData.startPosX;\n", "        float* startY = _particleData.startPosY;\n", "        float* x = _particleData.posx;\n", "        float* y = _particleData.posy;\n", "        float* s = _particleData.size;\n", "        float* r = _particleData.rotation;\n", "        V3F_C4B_T2F_Quad* quadStart = startQuad;\n", "        for (int i = 0 ; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)\n", "        {\n", "            newPos.set(*x, *y);\n", "            newPos.x = *x - (currentPosition.x - *startX);\n", "            newPos.y = *y - (currentPosition.y - *startY);\n", "            newPos += pos;\n", "            updatePosWithParticle(quadStart, newPos, *s, *r);\n", "        }\n", "    }\n", "    else\n", "    {\n", "        Vec2 newPos;\n", "        float* startX = _particleData.startPosX;\n", "        float* startY = _particleData.startPosY;\n", "        float* x = _particleData.posx;\n", "        float* y = _particleData.posy;\n", "        float* s = _particleData.size;\n", "        float* r = _particleData.rotation;\n", "        V3F_C4B_T2F_Quad* quadStart = startQuad;\n", "        for (int i = 0 ; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)\n", "        {\n", "            newPos.set(*x + pos.x, *y + pos.y);\n", "            updatePosWithParticle(quadStart, newPos, *s, *r);\n", "        }\n", "    }\n", "    \n", "    //set color\n", "    if(_opacityModifyRGB)\n", "    {\n", "        V3F_C4B_T2F_Quad* quad = startQuad;\n", "        float* r = _particleData.colorR;\n", "        float* g = _particleData.colorG;\n", "        float* b = _particleData.colorB;\n", "        float* a = _particleData.colorA;\n", "        \n", "        for (int i = 0; i < _particleCount; ++i,++quad,++r,++g,++b,++a)\n", "        {\n", "            uint8_t colorR = *r * *a * 255;\n", "            uint8_t colorG = *g * *a * 255;\n", "            uint8_t colorB = *b * *a * 255;\n", "            uint8_t colorA = *a * 255;\n", "            quad->bl.colors.set(colorR, colorG, colorB, colorA);\n", "            quad->br.colors.set(colorR, colorG, colorB, colorA);\n", "            quad->tl.colors.set(colorR, colorG, colorB, colorA);\n", "            quad->tr.colors.set(colorR, colorG, colorB, colorA);\n", "        }\n", "    }\n", "    else\n", "    {\n", "        V3F_C4B_T2F_Quad* quad = startQuad;\n", "        float* r = _particleData.colorR;\n", "        float* g = _particleData.colorG;\n", "        float* b = _particleData.colorB;\n", "        float* a = _particleData.colorA;\n", "        \n", "        for (int i = 0; i < _particleCount; ++i,++quad,++r,++g,++b,++a)\n", "        {\n", "            uint8_t colorR = *r * 255;\n", "            uint8_t colorG = *g * 255;\n", "            uint8_t colorB = *b * 255;\n", "            uint8_t colorA = *a * 255;\n", "            quad->bl.colors.set(colorR, colorG, colorB, colorA);\n", "            quad->br.colors.set(colorR, colorG, colorB, colorA);\n", "            quad->tl.colors.set(colorR, colorG, colorB, colorA);\n", "            quad->tr.colors.set(colorR, colorG, colorB, colorA);\n", "        }\n", "    }\n", "}\n"], "ParticleSystemQuad::setBatchNode-ParticleBatchNode*": ["void ParticleSystemQuad::setBatchNode(ParticleBatchNode * batchNode)\n", "{\n", "    if( _batchNode != batchNode )\n", "    {\n", "        ParticleBatchNode* oldBatch = _batchNode;\n", "        \n", "        ParticleSystem::setBatchNode(batchNode);\n", "        \n", "        // NEW: is self render ?\n", "        if( ! batchNode )\n", "        {\n", "            allocMemory();\n", "            initIndices();\n", "            setTexture(oldBatch->getTexture());\n", "            if( Texture2D::ms_isOnPause )\n", "            {\n", "                CCLOGCRITICAL(\"zym onpause cache ParticleSystemQuad::setBatchNode [%p]\", this );\n", "                TextureCache::getInstance()->AddCachGLData(this, EGLDataType::EGLData_ParticleSetup, EGLOper::EGLOper_Create );\n", "                \n", "                return  ;\n", "            }\n", "            \n", "//            setupVBO();\n", "        }\n", "        // OLD: was it self render ? cleanup\n", "        else if( !oldBatch )\n", "        {\n", "            // copy current state to batch\n", "            V3F_C4B_T2F_Quad *batchQuads = _batchNode->getTextureAtlas()->getQuads();\n", "            V3F_C4B_T2F_Quad *quad = &(batchQuads[_atlasIndex] );\n", "            //memcpy \u4f1a\u8bbf\u95ee\u7a7a\u6307\u9488 by sxy\n", "            if(!batchQuads ||!quad)\n", "            {\n", "                ApplicationPreCrash(\"ParticleSystemQuad::setBatchNode _batchNode=null by sxy\");\n", "                return;\n", "            }\n", "            memcpy( quad, _quads, _totalParticles * sizeof(_quads[0]) );\n", "            \n", "            CC_SAFE_FREE(_quads);\n", "            CC_SAFE_FREE(_indices);\n", "            \n", "            if( Texture2D::ms_isOnPause )\n", "            {\n", "                CCLOGCRITICAL(\"zym onpause cache ParticleSystemQuad::setBatchNode [%p]\", this );\n", "                TextureCache::getInstance()->AddCachGLData(this, EGLDataType::EGLData_ParticleDelBuffer, EGLOper::EGLOper_Create );\n", "                \n", "                return  ;\n", "            }\n", "            \n", "        }\n", "    }\n", "}\n"], "CCParticleSystem.h_header": ["\n", "#include \"base/CCProtocols.h\"\n", "#include \"2d/CCNode.h\"\n", "#include \"base/CCValue.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "class ParticleBatchNode;\n", "\n", "/** @struct sParticle\n", " Structure that contains the values of each particle.\n", " */\n", "\n"], "block_one_particle_point": ["struct particle_point\n", "{\n", "    float x;\n", "    float y;\n", "};\n"], "CCParticleSystem.cpp_cpp": ["// ideas taken from:\n", "//     . The ocean spray in your face [Jeff Lander]\n", "//        http://www.double.co.nz/dust/col0798.pdf\n", "//     . Building an Advanced Particle System [John van der Burg]\n", "//        http://www.gamasutra.com/features/20000623/vanderburg_01.htm\n", "//   . LOVE game engine\n", "//        http://love2d.org/\n", "//\n", "//\n", "// Radius mode support, from 71 squared\n", "//        http://particledesigner.71squared.com/\n", "//\n", "// IMPORTANT: Particle Designer is supported by cocos2d, but\n", "// 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guaranteed in cocos2d,\n", "//  cocos2d uses a another approach, but the results are almost identical.\n", "//\n", "\n", "#include \"2d/CCParticleSystem.h\"\n", "\n", "#include <string>\n", "\n", "#include \"2d/CCParticleBatchNode.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"base/base64.h\"\n", "#include \"base/ZipUtils.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCProfiling.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"deprecated/CCString.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "\n", "#include \"platform/CCGL.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"base/CCDirector.h\"\n", "\n", "#include \"math/CCMathBase.h\"\n", "#include \"base/CCParallelUpdate.h\"\n", "\n", "using namespace std;\n", "bool GetCompressFileData(const char* fileNameNo_Z,unsigned char*& outMemory,ssize_t& outMemoryLen);\n", "NS_CC_BEGIN\n"], "RANDOM_M11-unsigned": ["inline static float RANDOM_M11(unsigned int *seed) {\n", "    *seed = *seed * 134775813 + 1;\n", "    union {\n", "        uint32_t d;\n", "        float f;\n", "    } u;\n", "    u.d = (((uint32_t)(*seed) & 0x7fff) << 8) | 0x40000000;\n", "    return u.f - 3.0f;\n", "}\n"], "ParticleData": ["ParticleData::ParticleData()\n", "{\n", "    memset(this, 0, sizeof(ParticleData));\n", "}\n"], "ParticleData::init-int": ["bool ParticleData::init(int count)\n", "{\n", "    maxCount = count;\n", "    \n", "    pos = (particle_pos*)malloc(count * sizeof(particle_pos));\n", "    startPos = (particle_pos*)malloc(count * sizeof(particle_pos));\n", "    color = (particle_color*)malloc(count * sizeof(particle_color));\n", "    deltaColor = (particle_color*)malloc(count * sizeof(particle_color));\n", "    size = (particle_size*)malloc(count * sizeof(particle_size));\n", "    \n", "    rotation = (particle_rotation*)malloc(count * sizeof(particle_rotation));\n", "    timeToLive= (float*)malloc(count * sizeof(float));\n", "    atlasIndex= (unsigned int*)malloc(count * sizeof(unsigned int));\n", "    \n", "    modeA = (particle_modelA*)malloc(count * sizeof(particle_modelA));\n", "    modeB = (particle_modelB*)malloc(count * sizeof(particle_modelB));\n", "    \n", "    return pos && startPos && color && deltaColor && size&&\n", "                rotation && timeToLive && atlasIndex && modeA && modeB;\n", "}\n"], "ParticleData::release": ["void ParticleData::release()\n", "{\n", "    CC_SAFE_FREE(posx);\n", "    CC_SAFE_FREE(posy);\n", "    CC_SAFE_FREE(startPosX);\n", "    CC_SAFE_FREE(startPosY);\n", "    CC_SAFE_FREE(colorR);\n", "    CC_SAFE_FREE(colorG);\n", "    CC_SAFE_FREE(colorB);\n", "    CC_SAFE_FREE(colorA);\n", "    CC_SAFE_FREE(deltaColorR);\n", "    CC_SAFE_FREE(deltaColorG);\n", "    CC_SAFE_FREE(deltaColorB);\n", "    CC_SAFE_FREE(deltaColorA);\n", "    CC_SAFE_FREE(size);\n", "    CC_SAFE_FREE(deltaSize);\n", "    CC_SAFE_FREE(rotation);\n", "    CC_SAFE_FREE(deltaRotation);\n", "    CC_SAFE_FREE(timeToLive);\n", "    CC_SAFE_FREE(atlasIndex);\n", "    \n", "    CC_SAFE_FREE(modeA.dirX);\n", "    CC_SAFE_FREE(modeA.dirY);\n", "    CC_SAFE_FREE(modeA.radialAccel);\n", "    CC_SAFE_FREE(modeA.tangentialAccel);\n", "    \n", "    CC_SAFE_FREE(modeB.angle);\n", "    CC_SAFE_FREE(modeB.degreesPerSecond);\n", "    CC_SAFE_FREE(modeB.deltaRadius);\n", "    CC_SAFE_FREE(modeB.radius);\n", "}\n"], "ParticleSystem": ["ParticleSystem::ParticleSystem()\n", ": _isBlendAdditive(false)\n", ", _isAutoRemoveOnFinish(false)\n", ", _plistFile(\"\")\n", ", _elapsed(0)\n", ", _configName(\"\")\n", ", _emitCounter(0)\n", ", _batchNode(nullptr)\n", ", _atlasIndex(0)\n", ", _transformSystemDirty(false)\n", ", _allocatedParticles(0)\n", ", _isActive(true)\n", ", _particleCount(0)\n", ", _duration(0)\n", ", _life(0)\n", ", _lifeVar(0)\n", ", _angle(0)\n", ", _angleVar(0)\n", ", _emitterMode(Mode::GRAVITY)\n", ", _startSize(0)\n", ", _startSizeVar(0)\n", ", _endSize(0)\n", ", _endSizeVar(0)\n", ", _startSpin(0)\n", ", _startSpinVar(0)\n", ", _endSpin(0)\n", ", _endSpinVar(0)\n", ", _emissionRate(0)\n", ", _totalParticles(0)\n", ", _texture(nullptr)\n", ", _blendFunc(BlendFunc::ALPHA_PREMULTIPLIED)\n", ", _opacityModifyRGB(false)\n", ", _yCoordFlipped(1)\n", ", _positionType(PositionType::FREE)\n", ", m_initTextureByPlist(true)\n", ", _bDelayCleanForBatch(false)\n", "#if MULTITHREADED_PARTICLE\n", ", _bUpdate(false)\n", "#else\n", ", _bUpdate(true)\n", "#endif\n", "{\n", "    modeA.gravity.setZero();\n", "    modeA.speed = 0;\n", "    modeA.speedVar = 0;\n", "    modeA.tangentialAccel = 0;\n", "    modeA.tangentialAccelVar = 0;\n", "    modeA.radialAccel = 0;\n", "    modeA.radialAccelVar = 0;\n", "    modeA.rotationIsDir = false;\n", "    modeB.startRadius = 0;\n", "    modeB.startRadiusVar = 0;\n", "    modeB.endRadius = 0;\n", "    modeB.endRadiusVar = 0;\n", "    modeB.rotatePerSecond = 0;\n", "    modeB.rotatePerSecondVar = 0;\n", "    \n", "    ParticleSystem::allSystemCount++;\n", "    m_visibleDirty = true;\n", "}\n"], "ParticleSystem::create-std::string&": ["ParticleSystem * ParticleSystem::create(const std::string& plistFile)\n", "{\n", "    ParticleSystem *ret = new (std::nothrow) ParticleSystem();\n", "    if (ret && ret->initWithFile(plistFile))\n", "    {\n", "\n", "        \n", "        ret->autorelease();\n", "        return ret;\n", "    }\n", "    CC_SAFE_DELETE(ret);\n", "    return ret;\n", "}\n"], "ParticleSystem::createWithTotalParticles-int": ["ParticleSystem* ParticleSystem::createWithTotalParticles(int numberOfParticles)\n", "{\n", "    ParticleSystem *ret = new (std::nothrow) ParticleSystem();\n", "    if (ret && ret->initWithTotalParticles(numberOfParticles))\n", "    {\n", "        ret->autorelease();\n", "        return ret;\n", "    }\n", "    CC_SAFE_DELETE(ret);\n", "    return ret;\n", "}\n"], "ParticleSystem::init": ["bool ParticleSystem::init()\n", "{\n", "    return initWithTotalParticles(150);\n", "}\n"], "ParticleSystem::initWithFile-std::string&": ["bool ParticleSystem::initWithFile(const std::string& plistFile)\n", "{\n", "    bool ret = false;\n", "    ssize_t __size = 0;\n", "    unsigned char* buffer = nullptr;\n", "    \n", "//    __size = ZipUtils::inflateCCZFile(plistFile.c_str(), &buffer);\n", "//    if (__size > 0)\n", "//    {\n", "//        string textureName(\"\");\n", "//        string listFilePath = plistFile;\n", "//        if (listFilePath.find('/') != string::npos)\n", "//        {\n", "//            listFilePath = listFilePath.substr(0, listFilePath.rfind('/') + 1);\n", "//            textureName = this->initWithData(buffer, listFilePath.c_str());\n", "//        }\n", "//        else\n", "//        {\n", "//            textureName = this->initWithData(buffer, \"\");\n", "//        }\n", "//        \n", "//        if (!textureName.empty())\n", "//        {\n", "//            ret = true;\n", "//        }\n", "//    }\n", "//    else\n", "//    {\n", "    \n", "    \n", "        ValueMap dict ;\n", "    \n", "    /*    std::string _newFile = plistFile + \"b\";\n", "        _newFile = FileUtils::getInstance()->fullPathForFilename(_newFile.c_str());\n", "        if (FileUtils::sharedFileUtils()->isFileExist(_newFile))\n", "        {\n", "            unsigned char* buffer = nullptr;\n", "            ssize_t __size = ZipUtils::ccInflateCCZFile(_newFile.c_str(), &buffer);\n", "            dict = FileUtils::getInstance()->getValueMapFromData((char*)buffer, (int)__size);\n", "            \n", "            free(buffer);\n", "        }\n", "        else*/\n", "        unsigned char* membuffer = NULL;\n", "        ssize_t _size=0;\n", "        //for zip plist\n", "        if (GetCompressFileData(plistFile.c_str(),membuffer,_size)  )\n", "        {\n", "            dict = FileUtils::getInstance()->getValueMapFromData((const char*)membuffer, (int)_size);\n", "            _plistFile =plistFile;\n", "            delete membuffer;\n", "            buffer=NULL;\n", "        }\n", "        else\n", "        {\n", "            _plistFile = FileUtils::getInstance()->fullPathForFilename(plistFile);\n", "            dict = FileUtils::getInstance()->getValueMapFromFile(_plistFile);\n", "        }\n", "    \n", "        CCASSERT( !dict.empty(), \"Particles: file not found\");\n", "        \n", "        // FIXME: compute path from a path, should define a function somewhere to do it\n", "        string listFilePath = plistFile;\n", "        if (listFilePath.find('/') != string::npos)\n", "        {\n", "            listFilePath = listFilePath.substr(0, listFilePath.rfind('/') + 1);\n", "            ret = this->initWithDictionary(dict, listFilePath.c_str());\n", "        }\n", "        else\n", "        {\n", "            ret = this->initWithDictionary(dict, \"\");\n", "        }\n", "        \n", "//    }\n", "    \n", "    \n", "    \n", "    return ret;\n", "}\n"], "ParticleSystem::initWithDictionary-ValueMap&": ["bool ParticleSystem::initWithDictionary(ValueMap& dictionary)\n", "{\n", "    return initWithDictionary(dictionary, \"\");\n", "}\n"], "ParticleSystem::initWithDictionary-ValueMap&-std::string&": ["bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string& dirname)\n", "{\n", "    bool ret = false;\n", "    unsigned char *buffer = nullptr;\n", "    unsigned char *deflated = nullptr;\n", "    Image *image = nullptr;\n", "    do\n", "    {\n", "        int maxParticles = dictionary[\"maxParticles\"].asInt();\n", "       // assert(maxParticles>0);\n", "        \n", "        // self, not super\n", "        if(maxParticles>0 && this->initWithTotalParticles(maxParticles))\n", "        {\n", "            // Emitter name in particle designer 2.0\n", "            _configName = dictionary[\"configName\"].asString();\n", "            \n", "            // angle\n", "            _angle = dictionary[\"angle\"].asFloat();\n", "            _angleVar = dictionary[\"angleVariance\"].asFloat();\n", "            \n", "            // duration\n", "            _duration = dictionary[\"duration\"].asFloat();\n", "            \n", "            // blend function\n", "            if (!_configName.empty())\n", "            {\n", "                _blendFunc.src = static_cast<backend::BlendFactor>(dictionary[\"blendFuncSource\"].asFloat());\n", "            }\n", "            else\n", "            {\n", "                _blendFunc.src = static_cast<backend::BlendFactor>(dictionary[\"blendFuncSource\"].asInt());\n", "            }\n", "            _blendFunc.dst = static_cast<backend::BlendFactor>(dictionary[\"blendFuncDestination\"].asInt());\n", "            \n", "            // color\n", "            _startColor.r = dictionary[\"startColorRed\"].asFloat();\n", "            _startColor.g = dictionary[\"startColorGreen\"].asFloat();\n", "            _startColor.b = dictionary[\"startColorBlue\"].asFloat();\n", "            _startColor.a = dictionary[\"startColorAlpha\"].asFloat();\n", "            \n", "            _startColorVar.r = dictionary[\"startColorVarianceRed\"].asFloat();\n", "            _startColorVar.g = dictionary[\"startColorVarianceGreen\"].asFloat();\n", "            _startColorVar.b = dictionary[\"startColorVarianceBlue\"].asFloat();\n", "            _startColorVar.a = dictionary[\"startColorVarianceAlpha\"].asFloat();\n", "            \n", "            _endColor.r = dictionary[\"finishColorRed\"].asFloat();\n", "            _endColor.g = dictionary[\"finishColorGreen\"].asFloat();\n", "            _endColor.b = dictionary[\"finishColorBlue\"].asFloat();\n", "            _endColor.a = dictionary[\"finishColorAlpha\"].asFloat();\n", "            \n", "            _endColorVar.r = dictionary[\"finishColorVarianceRed\"].asFloat();\n", "            _endColorVar.g = dictionary[\"finishColorVarianceGreen\"].asFloat();\n", "            _endColorVar.b = dictionary[\"finishColorVarianceBlue\"].asFloat();\n", "            _endColorVar.a = dictionary[\"finishColorVarianceAlpha\"].asFloat();\n", "            \n", "            // particle size\n", "            _startSize = dictionary[\"startParticleSize\"].asFloat();\n", "            _startSizeVar = dictionary[\"startParticleSizeVariance\"].asFloat();\n", "            _endSize = dictionary[\"finishParticleSize\"].asFloat();\n", "            _endSizeVar = dictionary[\"finishParticleSizeVariance\"].asFloat();\n", "            \n", "            // position\n", "            float x = dictionary[\"sourcePositionx\"].asFloat();\n", "            float y = dictionary[\"sourcePositiony\"].asFloat();\n", "            this->setPosition(x,y);\n", "            _posVar.x = dictionary[\"sourcePositionVariancex\"].asFloat();\n", "            _posVar.y = dictionary[\"sourcePositionVariancey\"].asFloat();\n", "            \n", "            // Spinning\n", "            _startSpin = dictionary[\"rotationStart\"].asFloat();\n", "            _startSpinVar = dictionary[\"rotationStartVariance\"].asFloat();\n", "            _endSpin= dictionary[\"rotationEnd\"].asFloat();\n", "            _endSpinVar= dictionary[\"rotationEndVariance\"].asFloat();\n", "            \n", "            _emitterMode = (Mode) dictionary[\"emitterType\"].asInt();\n", "            \n", "            // Mode A: Gravity + tangential accel + radial accel\n", "            if (_emitterMode == Mode::GRAVITY)\n", "            {\n", "                // gravity\n", "                modeA.gravity.x = dictionary[\"gravityx\"].asFloat();\n", "                modeA.gravity.y = dictionary[\"gravityy\"].asFloat();\n", "                \n", "                // speed\n", "                modeA.speed = dictionary[\"speed\"].asFloat();\n", "                modeA.speedVar = dictionary[\"speedVariance\"].asFloat();\n", "                \n", "                // radial acceleration\n", "                modeA.radialAccel = dictionary[\"radialAcceleration\"].asFloat();\n", "                modeA.radialAccelVar = dictionary[\"radialAccelVariance\"].asFloat();\n", "                \n", "                // tangential acceleration\n", "                modeA.tangentialAccel = dictionary[\"tangentialAcceleration\"].asFloat();\n", "                modeA.tangentialAccelVar = dictionary[\"tangentialAccelVariance\"].asFloat();\n", "                \n", "                // rotation is dir\n", "                modeA.rotationIsDir = dictionary[\"rotationIsDir\"].asBool();\n", "            }\n", "            \n", "            // or Mode B: radius movement\n", "            else if (_emitterMode == Mode::RADIUS)\n", "            {\n", "                if (!_configName.empty())\n", "                {\n", "                    modeB.startRadius = dictionary[\"maxRadius\"].asInt();\n", "                }\n", "                else\n", "                {\n", "                    modeB.startRadius = dictionary[\"maxRadius\"].asFloat();\n", "                }\n", "                modeB.startRadiusVar = dictionary[\"maxRadiusVariance\"].asFloat();\n", "                if (!_configName.empty())\n", "                {\n", "                    modeB.endRadius = dictionary[\"minRadius\"].asInt();\n", "                }\n", "                else\n", "                {\n", "                    modeB.endRadius = dictionary[\"minRadius\"].asFloat();\n", "                }\n", "                \n", "                if (dictionary.find(\"minRadiusVariance\") != dictionary.end())\n", "                {\n", "                    modeB.endRadiusVar = dictionary[\"minRadiusVariance\"].asFloat();\n", "                }\n", "                else\n", "                {\n", "                    modeB.endRadiusVar = 0.0f;\n", "                }\n", "                \n", "                if (!_configName.empty())\n", "                {\n", "                    modeB.rotatePerSecond = dictionary[\"rotatePerSecond\"].asInt();\n", "                }\n", "                else\n", "                {\n", "                    modeB.rotatePerSecond = dictionary[\"rotatePerSecond\"].asFloat();\n", "                }\n", "                modeB.rotatePerSecondVar = dictionary[\"rotatePerSecondVariance\"].asFloat();\n", "                \n", "            } else {\n", "                CCASSERT( false, \"Invalid emitterType in config file\");\n", "                CC_BREAK_IF(true);\n", "            }\n", "            \n", "            // life span\n", "            _life = dictionary[\"particleLifespan\"].asFloat();\n", "            _lifeVar = dictionary[\"particleLifespanVariance\"].asFloat();\n", "            \n", "            // emission Rate\n", "            _emissionRate = _totalParticles / _life;\n", "            \n", "            //don't get the internal texture if a batchNode is used\n", "            if (!_batchNode&&m_initTextureByPlist)\n", "            {\n", "                // Set a compatible default for the alpha transfer\n", "                _opacityModifyRGB = false;\n", "                \n", "                // texture\n", "                // Try to get the texture from the cache\n", "                std::string textureName = dictionary[\"textureFileName\"].asString();\n", "                \n", "                size_t rPos = textureName.rfind('/');\n", "                \n", "                if (rPos != string::npos)\n", "                {\n", "                    string textureDir = textureName.substr(0, rPos + 1);\n", "                    \n", "                    if (!dirname.empty() && textureDir != dirname)\n", "                    {\n", "                        textureName = textureName.substr(rPos+1);\n", "                        // Added by ChenFei 2014-12-26 V3.2 supports\n", "                        _texturefileName = textureName;\n", "                        textureName = dirname + textureName;\n", "                    }\n", "                }\n", "                else if (!dirname.empty() && !textureName.empty())\n", "                {\n", "                    // Added by ChenFei 2014-12-26 V3.2 supports\n", "                    _texturefileName = textureName;\n", "                    textureName = dirname + textureName;\n", "                }\n", "                \n", "                Texture2D *tex = nullptr;\n", "                \n", "                if (!textureName.empty())\n", "                {\n", "                    // set not pop-up message box when load image failed\n", "                    bool notify = FileUtils::getInstance()->isPopupNotify();\n", "                    FileUtils::getInstance()->setPopupNotify(false);\n", "                    tex = Director::getInstance()->getTextureCache()->addImage(textureName);\n", "                    // reset the value of UIImage notify\n", "                    FileUtils::getInstance()->setPopupNotify(notify);\n", "                }\n", "                \n", "                if (tex)\n", "                {\n", "                    setTexture(tex);\n", "                }\n", "                else if( dictionary.find(\"textureImageData\") != dictionary.end() )\n", "                {\n", "                    std::string textureData = dictionary.at(\"textureImageData\").asString();\n", "                    CCASSERT(!textureData.empty(), \"textureData can't be empty!\");\n", "                    \n", "                    auto dataLen = textureData.size();\n", "                    if (dataLen != 0)\n", "                    {\n", "                        // if it fails, try to get it from the base64-gzipped data\n", "                        int decodeLen = base64Decode((unsigned char*)textureData.c_str(), (unsigned int)dataLen, &buffer);\n", "                        CCASSERT( buffer != nullptr, \"CCParticleSystem: error decoding textureImageData\");\n", "                        CC_BREAK_IF(!buffer);\n", "                        \n", "                        ssize_t deflatedLen = ZipUtils::inflateMemory(buffer, decodeLen, &deflated);\n", "                        CCASSERT( deflated != nullptr, \"CCParticleSystem: error ungzipping textureImageData\");\n", "                        CC_BREAK_IF(!deflated);\n", "                        \n", "                        // For android, we should retain it in VolatileTexture::addImage which invoked in Director::getInstance()->getTextureCache()->addUIImage()\n", "                        image = new (std::nothrow) Image();\n", "                        bool isOK = image->initWithImageData(deflated, deflatedLen);\n", "                        CCASSERT(isOK, \"CCParticleSystem: error init image with Data\");\n", "                        CC_BREAK_IF(!isOK);\n", "                        \n", "                        //\u4e3a\u4f55\u7528base64\u5b58\u56fe\u50cf\u6587\u4ef6\uff0c\u540c\u65f6\u8fd8\u5b9e\u7528textureFileName\u78c1\u76d8\u6587\u4ef6\uff1f\uff1f\uff1f by xy\n", "                        //\u7528\"\"\u505atexture key\u4f1a\u51fa\u95ee\u9898,\u6682\u65f6\u7528plist name\n", "                        if(textureName.empty())\n", "                            textureName = _plistFile;\n", "                        setTexture(Director::getInstance()->getTextureCache()->addImage(image, textureName.c_str()));\n", "                        \n", "                        image->release();\n", "                    }\n", "                }\n", "                \n", "                _yCoordFlipped = dictionary.find(\"yCoordFlipped\") == dictionary.end() ? 1 : dictionary.at(\"yCoordFlipped\").asInt();\n", "                \n", "                if( !this->_texture)\n", "                    CCLOGWARN(\"cocos2d: Warning: ParticleSystemQuad system without a texture\");\n", "            }\n", "            ret = true;\n", "        }\n", "    } while (0);\n", "    free(buffer);\n", "    free(deflated);\n", "    return ret;\n", "}\n"], "ParticleSystem::initWithTotalParticles-int": ["bool ParticleSystem::initWithTotalParticles(int numberOfParticles)\n", "{\n", "    _totalParticles = numberOfParticles;\n", "    \n", "    _particleData.release();\n", "    \n", "    if( !_particleData.init(_totalParticles) )\n", "    {\n", "        CCLOG(\"Particle system: not enough memory\");\n", "        this->release();\n", "        return false;\n", "    }\n", "    _allocatedParticles = numberOfParticles;\n", "    \n", "    if (_batchNode)\n", "    {\n", "        for (int i = 0; i < _totalParticles; i++)\n", "        {\n", "            _particleData.atlasIndex[i] = i;\n", "        }\n", "    }\n", "    // default, active\n", "    _isActive = true;\n", "    \n", "    // default blend function\n", "    _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;\n", "    \n", "    // default movement type;\n", "    _positionType = PositionType::FREE;\n", "    \n", "    // by default be in mode A:\n", "    _emitterMode = Mode::GRAVITY;\n", "    \n", "    // default: modulate\n", "    // FIXME:: not used\n", "    //    colorModulate = YES;\n", "    \n", "    _isAutoRemoveOnFinish = false;\n", "    \n", "    // Optimization: compile updateParticle method\n", "    //updateParticleSel = @selector(updateQuadWithParticle:newPosition:);\n", "    //updateParticleImp = (CC_UPDATE_PARTICLE_IMP) [self methodForSelector:updateParticleSel];\n", "    //for batchNode\n", "    _transformSystemDirty = false;\n", "    \n", "    _updateVersion = -1;\n", "    return true;\n", "}\n"], "~ParticleSystem": ["ParticleSystem::~ParticleSystem()\n", "{\n", "    \n", "    // Since the scheduler retains the \"target (in this case the ParticleSystem)\n", "    // it is not needed to call \"unscheduleUpdate\" here. In fact, it will be called in \"cleanup\"\n", "    //unscheduleUpdate();\n", "    _particleData.release();\n", "    CC_SAFE_RELEASE(_texture);\n", "    ParticleSystem::allSystemCount--;\n", "\n", "  }\n"], "ParticleSystem::addParticles-int": ["void ParticleSystem::addParticles(int count)\n", "{\n", "    if (_paused)\n", "        return;\n", "    uint32_t RANDSEED = rand();\n", "\n", "    int start = _particleCount;\n", "    _particleCount += count;\n", "    \n", "    //life\n", "    for (int i = start; i < _particleCount ; ++i)\n", "    {\n", "        float theLife = _life + _lifeVar * RANDOM_M11(&RANDSEED);\n", "        _particleData.timeToLive[i] = MAX(0, theLife);\n", "    }\n", "    \n", "    //position\n", "    for (int i = start; i < _particleCount; ++i)\n", "    {\n", "        _particleData.posx[i] = _sourcePosition.x + _posVar.x * RANDOM_M11(&RANDSEED);\n", "    }\n", "    \n", "    for (int i = start; i < _particleCount; ++i)\n", "    {\n", "        _particleData.posy[i] = _sourcePosition.y + _posVar.y * RANDOM_M11(&RANDSEED);\n", "    }\n", "    \n", "    //color\n", "#define SET_COLOR(c, b, v)\\\n", "for (int i = start; i < _particleCount; ++i)\\\n", "{\\\n", "c[i] = clampf( b + v * RANDOM_M11(&RANDSEED) , 0 , 1 );\\\n", "}\n", "    \n", "    SET_COLOR(_particleData.colorR, _startColor.r, _startColorVar.r);\n", "    SET_COLOR(_particleData.colorG, _startColor.g, _startColorVar.g);\n", "    SET_COLOR(_particleData.colorB, _startColor.b, _startColorVar.b);\n", "    SET_COLOR(_particleData.colorA, _startColor.a, _startColorVar.a);\n", "    \n", "    SET_COLOR(_particleData.deltaColorR, _endColor.r, _endColorVar.r);\n", "    SET_COLOR(_particleData.deltaColorG, _endColor.g, _endColorVar.g);\n", "    SET_COLOR(_particleData.deltaColorB, _endColor.b, _endColorVar.b);\n", "    SET_COLOR(_particleData.deltaColorA, _endColor.a, _endColorVar.a);\n", "    \n", "#define SET_DELTA_COLOR(c, dc)\\\n", "for (int i = start; i < _particleCount; ++i)\\\n", "{\\\n", "dc[i] = (dc[i] - c[i]) / _particleData.timeToLive[i];\\\n", "}\n", "    \n", "    SET_DELTA_COLOR(_particleData.colorR, _particleData.deltaColorR);\n", "    SET_DELTA_COLOR(_particleData.colorG, _particleData.deltaColorG);\n", "    SET_DELTA_COLOR(_particleData.colorB, _particleData.deltaColorB);\n", "    SET_DELTA_COLOR(_particleData.colorA, _particleData.deltaColorA);\n", "    \n", "    //size\n", "    for (int i = start; i < _particleCount; ++i)\n", "    {\n", "        _particleData.size[i] = _startSize + _startSizeVar * RANDOM_M11(&RANDSEED);\n", "        _particleData.size[i] = MAX(0, _particleData.size[i]);\n", "    }\n", "    \n", "    if (_endSize != START_SIZE_EQUAL_TO_END_SIZE)\n", "    {\n", "        for (int i = start; i < _particleCount; ++i)\n", "        {\n", "            float endSize = _endSize + _endSizeVar * RANDOM_M11(&RANDSEED);\n", "            endSize = MAX(0, endSize);\n", "            _particleData.deltaSize[i] = (endSize - _particleData.size[i]) / _particleData.timeToLive[i];\n", "        }\n", "    }\n", "    else\n", "    {\n", "        for (int i = start; i < _particleCount; ++i)\n", "        {\n", "            _particleData.deltaSize[i] = 0.0f;\n", "        }\n", "    }\n", "    \n", "    // rotation\n", "    for (int i = start; i < _particleCount; ++i)\n", "    {\n", "        _particleData.rotation[i] = _startSpin + _startSpinVar * RANDOM_M11(&RANDSEED);\n", "    }\n", "    for (int i = start; i < _particleCount; ++i)\n", "    {\n", "        float endA = _endSpin + _endSpinVar * RANDOM_M11(&RANDSEED);\n", "        _particleData.deltaRotation[i] = (endA - _particleData.rotation[i]) / _particleData.timeToLive[i];\n", "    }\n", "    \n", "    // position\n", "    Vec2 pos;\n", "    if (_positionType == PositionType::FREE)\n", "    {\n", "        pos = this->convertToWorldSpace(Vec2::ZERO);\n", "    }\n", "    else if (_positionType == PositionType::RELATIVE)\n", "    {\n", "        pos = _position;\n", "    }\n", "    for (int i = start; i < _particleCount; ++i)\n", "    {\n", "        _particleData.startPosX[i] = pos.x;\n", "    }\n", "    for (int i = start; i < _particleCount; ++i)\n", "    {\n", "        _particleData.startPosY[i] = pos.y;\n", "    }\n", "    \n", "    // Mode Gravity: A\n", "    if (_emitterMode == Mode::GRAVITY)\n", "    {\n", "        \n", "        // radial accel\n", "        for (int i = start; i < _particleCount; ++i)\n", "        {\n", "            _particleData.modeA.radialAccel[i] = modeA.radialAccel + modeA.radialAccelVar * RANDOM_M11(&RANDSEED);\n", "        }\n", "        \n", "        // tangential accel\n", "        for (int i = start; i < _particleCount; ++i)\n", "        {\n", "            _particleData.modeA.tangentialAccel[i] = modeA.tangentialAccel + modeA.tangentialAccelVar * RANDOM_M11(&RANDSEED);\n", "        }\n", "        \n", "        // rotation is dir\n", "        if( modeA.rotationIsDir )\n", "        {\n", "            for (int i = start; i < _particleCount; ++i)\n", "            {\n", "                float a = CC_DEGREES_TO_RADIANS( _angle + _angleVar * RANDOM_M11(&RANDSEED) );\n", "                Vec2 v(cosf( a ), sinf( a ));\n", "                float s = modeA.speed + modeA.speedVar * RANDOM_M11(&RANDSEED);\n", "                Vec2 dir = v * s;\n", "                _particleData.modeA.dirX[i] = dir.x;//v * s ;\n", "                _particleData.modeA.dirY[i] = dir.y;\n", "                _particleData.rotation[i] = -CC_RADIANS_TO_DEGREES(dir.getAngle());\n", "            }\n", "        }\n", "        else\n", "        {\n", "            for (int i = start; i < _particleCount; ++i)\n", "            {\n", "                float a = CC_DEGREES_TO_RADIANS( _angle + _angleVar * RANDOM_M11(&RANDSEED) );\n", "                Vec2 v(cosf( a ), sinf( a ));\n", "                float s = modeA.speed + modeA.speedVar * RANDOM_M11(&RANDSEED);\n", "                Vec2 dir = v * s;\n", "                _particleData.modeA.dirX[i] = dir.x;//v * s ;\n", "                _particleData.modeA.dirY[i] = dir.y;\n", "            }\n", "        }\n", "        \n", "    }\n", "    \n", "    // Mode Radius: B\n", "    else\n", "    {\n", "        //Need to check by Jacky\n", "        // Set the default diameter of the particle from the source position\n", "        for (int i = start; i < _particleCount; ++i)\n", "        {\n", "            _particleData.modeB.radius[i] = modeB.startRadius + modeB.startRadiusVar * RANDOM_M11(&RANDSEED);\n", "        }\n", "\n", "        for (int i = start; i < _particleCount; ++i)\n", "        {\n", "            _particleData.modeB.angle[i] = CC_DEGREES_TO_RADIANS( _angle + _angleVar * RANDOM_M11(&RANDSEED));\n", "        }\n", "        \n", "        for (int i = start; i < _particleCount; ++i)\n", "        {\n", "            _particleData.modeB.degreesPerSecond[i] = CC_DEGREES_TO_RADIANS(modeB.rotatePerSecond + modeB.rotatePerSecondVar * RANDOM_M11(&RANDSEED));\n", "        }\n", "        \n", "        if(modeB.endRadius == START_RADIUS_EQUAL_TO_END_RADIUS)\n", "        {\n", "            for (int i = start; i < _particleCount; ++i)\n", "            {\n", "                _particleData.modeB.deltaRadius[i] = 0.0f;\n", "            }\n", "        }\n", "        else\n", "        {\n", "            for (int i = start; i < _particleCount; ++i)\n", "            {\n", "                float endRadius = modeB.endRadius + modeB.endRadiusVar * RANDOM_M11(&RANDSEED);\n", "                _particleData.modeB.deltaRadius[i] = (endRadius - _particleData.modeB.radius[i]) / _particleData.timeToLive[i];\n", "            }\n", "        }\n", "    }\n", "}\n"], "ParticleSystem::onEnter": ["void ParticleSystem::onEnter()\n", "{\n", "#if CC_ENABLE_SCRIPT_BINDING\n", "    if (_scriptType == kScriptTypeJavascript)\n", "    {\n", "        if (ScriptEngineManager::sendNodeEventToJSExtended(this, kNodeOnEnter))\n", "            return;\n", "    }\n", "#endif\n", "    \n", "    Node::onEnter();\n", "    \n", "    // update after action in run!\n", "    this->scheduleUpdateWithPriority(1);\n", "    __allInstances.pushBack(this);\n", "}\n"], "ParticleSystem::onExit": ["void ParticleSystem::onExit()\n", "{\n", "#if CC_ENABLE_SCRIPT_BINDING\n", "    if (_scriptType == kScriptTypeJavascript)\n", "    {\n", "        if (ScriptEngineManager::sendNodeEventToJSExtended(this, kNodeOnExit))\n", "            return;\n", "    }\n", "#endif\n", "    \n", "    this->unscheduleUpdate();\n", "    Node::onExit();\n", "    \n", "    auto iter = std::find(std::begin(__allInstances), std::end(__allInstances), this);\n", "    if (iter != std::end(__allInstances))\n", "    {\n", "        __allInstances.erase(iter);\n", "    }\n", "    \n", "}\n"], "ParticleSystem::stopSystem": ["void ParticleSystem::stopSystem()\n", "{\n", "    _isActive = false;\n", "    _elapsed = _duration;\n", "    _emitCounter = 0;\n", "}\n"], "ParticleSystem::resetSystem": ["void ParticleSystem::resetSystem()\n", "{\n", "    _isActive = true;\n", "    _elapsed = 0;\n", "    for (int i = 0; i < _particleCount; ++i)\n", "    {\n", "        _particleData.timeToLive[i] = 0.0f;\n", "    }\n", "}\n"], "ParticleSystem::isFull": ["bool ParticleSystem::isFull()\n", "{\n", "    return (_particleCount == _totalParticles);\n", "}\n"], "ParticleSystem::update-float": ["void ParticleSystem::update(float dt)\n", "{\n", "    \n", "    if(ParticleSystem::IsCloseParticleForTest)\n", "         return;\n", "    \n", "    // \u5982\u679c\u5c4f\u5e55\u6ca1\u6709\u79fb\u5230\u7684\u8bdd\u5c31\u4e0d\u518d\u8d70\u88c1\u51b3\u5224\u65ad\n", "    if(ms_updateversion == _updateVersion ) // \u6682\u65f6\u5c4f\u853d_transformUpdated==false &&\n", "    {\n", "        if( m_visibleDirty == false )\n", "            return;\n", "    }\n", "    else\n", "    {\n", "        _updateVersion = ms_updateversion;\n", "        \n", "        if( getNodeVisible( ) == false)\n", "        {\n", "            m_visibleDirty = false;\n", "            return;\n", "        }\n", "        m_visibleDirty = true;\n", "    }\n", "    \n", "    if (!_bUpdate)\n", "    {\n", "        return;\n", "    }\n", "   \n", "    doUpdate(dt);\n", "\n", "}\n"], "ParticleSystem::updateWithNoTime": ["void ParticleSystem::updateWithNoTime(void)\n", "{\n", "    this->update(0.0f);\n", "}\n"], "ParticleSystem::updateParticleQuads": ["void ParticleSystem::updateParticleQuads()\n", "{\n", "    //should be overridden\n", "}\n"], "ParticleSystem::postStep": ["void ParticleSystem::postStep()\n", "{\n", "    // should be overridden\n", "}\n"], "ParticleSystem::setTexture-Texture2D*": ["void ParticleSystem::setTexture(Texture2D* var)\n", "{\n", "    if (_texture != var)\n", "    {\n", "        CC_SAFE_RETAIN(var);\n", "        CC_SAFE_RELEASE(_texture);\n", "        _texture = var;\n", "        updateBlendFunc();\n", "    }\n", "}\n"], "ParticleSystem::updateBlendFunc": ["void ParticleSystem::updateBlendFunc()\n", "{\n", "    CCASSERT(! _batchNode, \"Can't change blending functions when the particle is being batched\");\n", "    \n", "    if(_texture)\n", "    {\n", "        bool premultiplied = _texture->hasPremultipliedAlpha();\n", "        \n", "        _opacityModifyRGB = false;\n", "        \n", "        if( _texture && ( _blendFunc.src == CC_BLEND_SRC && _blendFunc.dst == CC_BLEND_DST ) )\n", "        {\n", "            if( premultiplied )\n", "            {\n", "                _opacityModifyRGB = true;\n", "            }\n", "            else\n", "            {\n", "                _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;\n", "            }\n", "        }\n", "    }\n", "}\n"], "ParticleSystem::getTexture": ["Texture2D * ParticleSystem::getTexture() const\n", "{\n", "    return _texture;\n", "}\n"], "ParticleSystem::setBlendAdditive-bool": ["void ParticleSystem::setBlendAdditive(bool additive)\n", "{\n", "    if( additive )\n", "    {\n", "        _blendFunc = BlendFunc::ADDITIVE;\n", "    }\n", "    else\n", "    {\n", "        if( _texture && ! _texture->hasPremultipliedAlpha() )\n", "            _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;\n", "        else\n", "            _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;\n", "    }\n", "}\n"], "ParticleSystem::isBlendAdditive": ["bool ParticleSystem::isBlendAdditive() const\n", "{\n", "    return( _blendFunc.src == backend::BlendFactor::SRC_ALPHA && _blendFunc.dst == backend::BlendFactor::ONE);\n", "}\n"], "ParticleSystem::setTangentialAccel-float": ["void ParticleSystem::setTangentialAccel(float t)\n", "{\n", "    CCASSERT( _emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    modeA.tangentialAccel = t;\n", "}\n"], "ParticleSystem::getTangentialAccel": ["float ParticleSystem::getTangentialAccel() const\n", "{\n", "    CCASSERT( _emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    return modeA.tangentialAccel;\n", "}\n"], "ParticleSystem::setTangentialAccelVar-float": ["void ParticleSystem::setTangentialAccelVar(float t)\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    modeA.tangentialAccelVar = t;\n", "}\n"], "ParticleSystem::getTangentialAccelVar": ["float ParticleSystem::getTangentialAccelVar() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    return modeA.tangentialAccelVar;\n", "}\n"], "ParticleSystem::setRadialAccel-float": ["void ParticleSystem::setRadialAccel(float t)\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    modeA.radialAccel = t;\n", "}\n"], "ParticleSystem::getRadialAccel": ["float ParticleSystem::getRadialAccel() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    return modeA.radialAccel;\n", "}\n"], "ParticleSystem::setRadialAccelVar-float": ["void ParticleSystem::setRadialAccelVar(float t)\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    modeA.radialAccelVar = t;\n", "}\n"], "ParticleSystem::getRadialAccelVar": ["float ParticleSystem::getRadialAccelVar() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    return modeA.radialAccelVar;\n", "}\n"], "ParticleSystem::setRotationIsDir-bool": ["void ParticleSystem::setRotationIsDir(bool t)\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    modeA.rotationIsDir = t;\n", "}\n"], "ParticleSystem::getRotationIsDir": ["bool ParticleSystem::getRotationIsDir() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    return modeA.rotationIsDir;\n", "}\n"], "ParticleSystem::setGravity-Vec2&": ["void ParticleSystem::setGravity(const Vec2& g)\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    modeA.gravity = g;\n", "}\n"], "ParticleSystem::getGravity": ["const Vec2& ParticleSystem::getGravity()\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    return modeA.gravity;\n", "}\n"], "ParticleSystem::setSpeed-float": ["void ParticleSystem::setSpeed(float speed)\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    modeA.speed = speed;\n", "}\n"], "ParticleSystem::getSpeed": ["float ParticleSystem::getSpeed() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    return modeA.speed;\n", "}\n"], "ParticleSystem::setSpeedVar-float": ["void ParticleSystem::setSpeedVar(float speedVar)\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    modeA.speedVar = speedVar;\n", "}\n"], "ParticleSystem::getSpeedVar": ["float ParticleSystem::getSpeedVar() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::GRAVITY, \"Particle Mode should be Gravity\");\n", "    return modeA.speedVar;\n", "}\n"], "ParticleSystem::setStartRadius-float": ["void ParticleSystem::setStartRadius(float startRadius)\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    modeB.startRadius = startRadius;\n", "}\n"], "ParticleSystem::getStartRadius": ["float ParticleSystem::getStartRadius() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    return modeB.startRadius;\n", "}\n"], "ParticleSystem::setStartRadiusVar-float": ["void ParticleSystem::setStartRadiusVar(float startRadiusVar)\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    modeB.startRadiusVar = startRadiusVar;\n", "}\n"], "ParticleSystem::getStartRadiusVar": ["float ParticleSystem::getStartRadiusVar() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    return modeB.startRadiusVar;\n", "}\n"], "ParticleSystem::setEndRadius-float": ["void ParticleSystem::setEndRadius(float endRadius)\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    modeB.endRadius = endRadius;\n", "}\n"], "ParticleSystem::getEndRadius": ["float ParticleSystem::getEndRadius() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    return modeB.endRadius;\n", "}\n"], "ParticleSystem::setEndRadiusVar-float": ["void ParticleSystem::setEndRadiusVar(float endRadiusVar)\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    modeB.endRadiusVar = endRadiusVar;\n", "}\n"], "ParticleSystem::getEndRadiusVar": ["float ParticleSystem::getEndRadiusVar() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    return modeB.endRadiusVar;\n", "}\n"], "ParticleSystem::setRotatePerSecond-float": ["void ParticleSystem::setRotatePerSecond(float degrees)\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    modeB.rotatePerSecond = degrees;\n", "}\n"], "ParticleSystem::getRotatePerSecond": ["float ParticleSystem::getRotatePerSecond() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    return modeB.rotatePerSecond;\n", "}\n"], "ParticleSystem::setRotatePerSecondVar-float": ["void ParticleSystem::setRotatePerSecondVar(float degrees)\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    modeB.rotatePerSecondVar = degrees;\n", "}\n"], "ParticleSystem::getRotatePerSecondVar": ["float ParticleSystem::getRotatePerSecondVar() const\n", "{\n", "    CCASSERT(_emitterMode == Mode::RADIUS, \"Particle Mode should be Radius\");\n", "    return modeB.rotatePerSecondVar;\n", "}\n"], "ParticleSystem::isActive": ["bool ParticleSystem::isActive() const\n", "{\n", "    return _isActive;\n", "}\n"], "ParticleSystem::getTotalParticles": ["int ParticleSystem::getTotalParticles() const\n", "{\n", "    return _totalParticles;\n", "}\n"], "ParticleSystem::setTotalParticles-int": ["void ParticleSystem::setTotalParticles(int var)\n", "{\n", "    CCASSERT( var <= _allocatedParticles, \"Particle: resizing particle array only supported for quads\");\n", "    _totalParticles = var;\n", "}\n"], "ParticleSystem::getBlendFunc": ["const BlendFunc& ParticleSystem::getBlendFunc() const\n", "{\n", "    return _blendFunc;\n", "}\n"], "ParticleSystem::setBlendFunc-BlendFunc&": ["void ParticleSystem::setBlendFunc(const BlendFunc &blendFunc)\n", "{\n", "    if( _blendFunc.src != blendFunc.src || _blendFunc.dst != blendFunc.dst ) {\n", "        _blendFunc = blendFunc;\n", "        this->updateBlendFunc();\n", "    }\n", "}\n"], "ParticleSystem::isAutoRemoveOnFinish": ["bool ParticleSystem::isAutoRemoveOnFinish() const\n", "{\n", "    return _isAutoRemoveOnFinish;\n", "}\n"], "ParticleSystem::setAutoRemoveOnFinish-bool": ["void ParticleSystem::setAutoRemoveOnFinish(bool var)\n", "{\n", "    _isAutoRemoveOnFinish = var;\n", "}\n"], "ParticleSystem::getBatchNode": ["ParticleBatchNode* ParticleSystem::getBatchNode(void) const\n", "{\n", "    return _batchNode;\n", "}\n"], "ParticleSystem::setBatchNode-ParticleBatchNode*": ["void ParticleSystem::setBatchNode(ParticleBatchNode* batchNode)\n", "{\n", "    if( _batchNode != batchNode ) {\n", "        \n", "        _batchNode = batchNode; // weak reference\n", "        \n", "        if( batchNode ) {\n", "            //each particle needs a unique index\n", "            for (int i = 0; i < _totalParticles; i++)\n", "            {\n", "                _particleData.atlasIndex[i] = i;\n", "            }\n", "        }\n", "    }\n", "}\n"], "ParticleSystem::setScale-float": ["void ParticleSystem::setScale(float s)\n", "{\n", "    _transformSystemDirty = true;\n", "    Node::setScale(s);\n", "}\n"], "ParticleSystem::setRotation-float": ["void ParticleSystem::setRotation(float newRotation)\n", "{\n", "    _transformSystemDirty = true;\n", "    Node::setRotation(newRotation);\n", "}\n"], "ParticleSystem::setScaleX-float": ["void ParticleSystem::setScaleX(float newScaleX)\n", "{\n", "    _transformSystemDirty = true;\n", "    Node::setScaleX(newScaleX);\n", "}\n"], "ParticleSystem::setScaleY-float": ["void ParticleSystem::setScaleY(float newScaleY)\n", "{\n", "    _transformSystemDirty = true;\n", "    Node::setScaleY(newScaleY);\n", "}\n"]}
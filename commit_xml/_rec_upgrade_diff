{"Sprite::setTextureRect-Rect&-bool-Size&": ["void Sprite::setTextureRect(const Rect& rect, bool rotated, const Size& untrimmedSize)\n", "{\n", "    _rectRotated = rotated;\n", "\n", "    Node::setContentSize(untrimmedSize);\n", "    _originalContentSize = untrimmedSize;\n", "\n", "    setVertexRect(rect);\n", "    updateStretchFactor();\n", "    updatePoly();\n", "}\n"], "Sprite::setTextureCoords-Rect&": ["void Sprite::setTextureCoords(const Rect& rectInPoints)\n", "{\n", "    setTextureCoords(rectInPoints, &_quad);\n", "}\n"], "Sprite::setFlippedX-bool": ["void Sprite::setFlippedX(bool flippedX)\n", "{\n", "    if (_flippedX != flippedX)\n", "    {\n", "        _flippedX = flippedX;\n", "        flipX();\n", "    }\n", "}\n"], "Sprite::setFlippedY-bool": ["void Sprite::setFlippedY(bool flippedY)\n", "{\n", "#ifdef CC_USE_METAL\n", "    if(_texture->isRenderTarget())\n", "        flippedY = !flippedY;\n", "#endif\n", "    if (_flippedY != flippedY)\n", "    {\n", "        _flippedY = flippedY;\n", "        flipY();\n", "    }\n", "}\n"], "Sprite::setSpriteFrame-SpriteFrame*": ["void Sprite::setSpriteFrame(SpriteFrame *spriteFrame)\n", "{\n", "    // retain the sprite frame\n", "    // do not removed by SpriteFrameCache::removeUnusedSpriteFrames\n", "    if (_spriteFrame != spriteFrame)\n", "    {\n", "        CC_SAFE_RELEASE(_spriteFrame);\n", "        _spriteFrame = spriteFrame;\n", "        spriteFrame->retain();\n", "    }\n", "    _unflippedOffsetPositionFromCenter = spriteFrame->getOffset();\n", "\n", "    Texture2D *texture = spriteFrame->getTexture();\n", "    // update texture before updating texture rect\n", "    if (texture != _texture)\n", "        setTexture(texture);\n", "\n", "    // update rect\n", "    _rectRotated = spriteFrame->isRotated();\n", "    setTextureRect(spriteFrame->getRect(), _rectRotated, spriteFrame->getOriginalSize());\n", "\n", "    if (spriteFrame->hasPolygonInfo())\n", "    {\n", "        _polyInfo = spriteFrame->getPolygonInfo();\n", "        _renderMode = RenderMode::POLYGON;\n", "        if (_flippedX) flipX();\n", "        if (_flippedY) flipY();\n", "        updateColor();\n", "    }\n", "    if (spriteFrame->hasAnchorPoint())\n", "        setAnchorPoint(spriteFrame->getAnchorPoint());\n", "    if (spriteFrame->hasCenterRect())\n", "        setCenterRect(spriteFrame->getCenterRect());\n", "}\n"], "Renderer::processRenderCommand-RenderCommand*": ["void Renderer::processRenderCommand(RenderCommand* command)\n", "{\n", "    auto commandType = command->getType();\n", "    switch(commandType)\n", "    {\n", "        case RenderCommand::Type::TRIANGLES_COMMAND:\n", "        {\n", "            // flush other queues\n", "            flush3D();\n", "            \n", "            auto cmd = static_cast<TrianglesCommand*>(command);\n", "            \n", "            // flush own queue when buffer is full\n", "            if(_queuedTotalVertexCount + cmd->getVertexCount() > VBO_SIZE || _queuedTotalIndexCount + cmd->getIndexCount() > INDEX_VBO_SIZE)\n", "            {\n", "                CCASSERT(cmd->getVertexCount()>= 0 && cmd->getVertexCount() < VBO_SIZE, \"VBO for vertex is not big enough, please break the data down or use customized render command\");\n", "                CCASSERT(cmd->getIndexCount()>= 0 && cmd->getIndexCount() < INDEX_VBO_SIZE, \"VBO for index is not big enough, please break the data down or use customized render command\");\n", "                drawBatchedTriangles();\n", "\n", "                _queuedTotalIndexCount = _queuedTotalVertexCount = 0;\n", "#ifdef CC_USE_METAL\n", "                _queuedIndexCount = _queuedVertexCount = 0;\n", "                _triangleCommandBufferManager.prepareNextBuffer();\n", "                _vertexBuffer = _triangleCommandBufferManager.getVertexBuffer();\n", "                _indexBuffer = _triangleCommandBufferManager.getIndexBuffer();\n", "#endif\n", "            }\n", "            \n", "            // queue it\n", "            _queuedTriangleCommands.push_back(cmd);\n", "#ifdef CC_USE_METAL\n", "            _queuedIndexCount += cmd->getIndexCount();\n", "            _queuedVertexCount += cmd->getVertexCount();\n", "#endif\n", "            _queuedTotalVertexCount += cmd->getVertexCount();\n", "            _queuedTotalIndexCount += cmd->getIndexCount();\n", "\n", "        }\n", "            break;\n", "        case RenderCommand::Type::MESH_COMMAND:\n", "            flush2D();\n", "            drawMeshCommand(command);\n", "            break;\n", "        case RenderCommand::Type::GROUP_COMMAND:\n", "            processGroupCommand(static_cast<GroupCommand*>(command));\n", "            break;\n", "        case RenderCommand::Type::CUSTOM_COMMAND:\n", "            flush();\n", "            drawCustomCommand(command);\n", "            break;\n", "        case RenderCommand::Type::CALLBACK_COMMAND:\n", "            flush();\n", "           static_cast<CallbackCommand*>(command)->execute();\n", "            break;\n", "        case RenderCommand::Type::CAPTURE_SCREEN_COMMAND:\n", "            flush();\n", "            captureScreen(command);\n", "            break;\n", "        default:\n", "            assert(false);\n", "            break;\n", "    }\n", "}\n"], "Renderer::visitRenderQueue-RenderQueue&": ["void Renderer::visitRenderQueue(RenderQueue& queue)\n", "{\n", "    //\n", "    //Process Global-Z < 0 Objects\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_NEG));\n", "\n", "    //\n", "    //Process Opaque Object\n", "    //\n", "    pushStateBlock();\n", "    setDepthTest(true); //enable depth test in 3D queue by default\n", "    setDepthWrite(true);\n", "    setCullMode(backend::CullMode::BACK);\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::OPAQUE_3D));\n", "    \n", "    //\n", "    //Process 3D Transparent object\n", "    //\n", "    setDepthWrite(false);\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::TRANSPARENT_3D));\n", "    popStateBlock();\n", "\n", "    //\n", "    //Process Global-Z = 0 Queue\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_ZERO));\n", "        \n", "    //\n", "    //Process Global-Z > 0 Queue\n", "    //\n", "    doVisitRenderQueue(queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_POS));\n", "\n", "}\n"], "Renderer::setDepthTest-bool": ["void Renderer::setDepthTest(bool value)\n", "{\n", "    _depthStencilDescriptor.depthTestEnabled = value;\n", "    _renderPassDescriptor.depthTestEnabled = value;\n", "}\n"], "Renderer::drawBatchedTriangles": ["void Renderer::drawBatchedTriangles()\n", "{\n", "    if(_queuedTriangleCommands.empty())\n", "        return;\n", "    \n", "    /************** 1: Setup up vertices/indices *************/\n", "#ifdef CC_USE_METAL\n", "    unsigned int vertexBufferFillOffset = _queuedTotalVertexCount - _queuedVertexCount;\n", "    unsigned int indexBufferFillOffset = _queuedTotalIndexCount - _queuedIndexCount;\n", "#else\n", "    unsigned int vertexBufferFillOffset = 0;\n", "    unsigned int indexBufferFillOffset = 0;\n", "#endif\n", "\n", "    _triBatchesToDraw[0].offset = indexBufferFillOffset;\n", "    _triBatchesToDraw[0].indicesToDraw = 0;\n", "    _triBatchesToDraw[0].cmd = nullptr;\n", "    \n", "    int batchesTotal = 0;\n", "    int prevMaterialID = -1;\n", "    bool firstCommand = true;\n", "\n", "    _filledVertex = 0;\n", "    _filledIndex = 0;\n", "\n", "    for(const auto& cmd : _queuedTriangleCommands)\n", "    {\n", "        auto currentMaterialID = cmd->getMaterialID();\n", "        const bool batchable = !cmd->isSkipBatching();\n", "        \n", "        fillVerticesAndIndices(cmd, vertexBufferFillOffset);\n", "        \n", "        // in the same batch ?\n", "        if (batchable && (prevMaterialID == currentMaterialID || firstCommand))\n", "        {\n", "            CC_ASSERT((firstCommand || _triBatchesToDraw[batchesTotal].cmd->getMaterialID() == cmd->getMaterialID()) && \"argh... error in logic\");\n", "            _triBatchesToDraw[batchesTotal].indicesToDraw += cmd->getIndexCount();\n", "            _triBatchesToDraw[batchesTotal].cmd = cmd;\n", "        }\n", "        else\n", "        {\n", "            // is this the first one?\n", "            if (!firstCommand)\n", "            {\n", "                batchesTotal++;\n", "                _triBatchesToDraw[batchesTotal].offset =\n", "                    _triBatchesToDraw[batchesTotal-1].offset + _triBatchesToDraw[batchesTotal-1].indicesToDraw;\n", "            }\n", "            \n", "            _triBatchesToDraw[batchesTotal].cmd = cmd;\n", "            _triBatchesToDraw[batchesTotal].indicesToDraw = (int) cmd->getIndexCount();\n", "            \n", "            // is this a single batch ? Prevent creating a batch group then\n", "            if (!batchable)\n", "                currentMaterialID = -1;\n", "        }\n", "        \n", "        // capacity full ?\n", "        if (batchesTotal + 1 >= _triBatchesToDrawCapacity)\n", "        {\n", "            _triBatchesToDrawCapacity *= 1.4;\n", "            _triBatchesToDraw = (TriBatchToDraw*) realloc(_triBatchesToDraw, sizeof(_triBatchesToDraw[0]) * _triBatchesToDrawCapacity);\n", "        }\n", "        \n", "        prevMaterialID = currentMaterialID;\n", "        firstCommand = false;\n", "    }\n", "    batchesTotal++;\n", "#ifdef CC_USE_METAL\n", "    _vertexBuffer->updateSubData(_verts, vertexBufferFillOffset * sizeof(_verts[0]), _filledVertex * sizeof(_verts[0]));\n", "    _indexBuffer->updateSubData(_indices, indexBufferFillOffset * sizeof(_indices[0]), _filledIndex * sizeof(_indices[0]));\n", "#else\n", "    _vertexBuffer->updateData(_verts, _filledVertex * sizeof(_verts[0]));\n", "    _indexBuffer->updateData(_indices,  _filledIndex * sizeof(_indices[0]));\n", "#endif\n", "\n", "    /************** 2: Draw *************/\n", "    for (int i = 0; i < batchesTotal; ++i)\n", "    {\n", "        beginRenderPass(_triBatchesToDraw[i].cmd);\n", "        _commandBuffer->setVertexBuffer(_vertexBuffer);\n", "        _commandBuffer->setIndexBuffer(_indexBuffer);\n", "        auto& pipelineDescriptor = _triBatchesToDraw[i].cmd->getPipelineDescriptor();\n", "        _commandBuffer->setProgramState(pipelineDescriptor.programState);\n", "_commandBuffer->drawElements(backend::PrimitiveType::TRIANGLE,backend::IndexFormat::U_SHORT,_triBatchesToDraw[i].indicesToDraw,_triBatchesToDraw[i].offset * sizeof(_indices[0]));        _commandBuffer->endRenderPass();\n", "\n", "        _drawnBatches++;\n", "        _drawnVertices += _triBatchesToDraw[i].indicesToDraw;\n", "    }\n", "\n", "    /************** 3: Cleanup *************/\n", "    _queuedTriangleCommands.clear();\n", "\n", "#ifdef CC_USE_METAL\n", "    _queuedIndexCount = 0;\n", "    _queuedVertexCount = 0;\n", "#endif\n", "}\n"], "Texture2D::setAliasTexParameters": ["void Texture2D::setAliasTexParameters()\n", "{\n", "\n", "    if (! _antialiasEnabled)\n", "    {\n", "        return;\n", "    }\n", "\n", "    _antialiasEnabled = false;\n", "\n", "    backend::SamplerDescriptor descriptor(\n", "        backend::SamplerFilter::NEAREST, //magFilter\n", "        (_texture->hasMipmaps()) ? backend::SamplerFilter::NEAREST_MIPMAP_NEAREST : backend::SamplerFilter::NEAREST, //minFilter\n", "        backend::SamplerAddressMode::DONT_CARE, //sAddressMode\n", "        backend::SamplerAddressMode::DONT_CARE//tAddressMode\n", "    );\n", "    _texture->updateSamplerDescriptor(descriptor);\n", "}\n"], "Texture2D::setAntiAliasTexParameters": ["void Texture2D::setAntiAliasTexParameters()\n", "{\n", "\n", "    if ( _antialiasEnabled )\n", "    {\n", "        return;\n", "    }\n", "    _antialiasEnabled = true;\n", "\n", "    backend::SamplerDescriptor descriptor(\n", "        backend::SamplerFilter::LINEAR, //magFilter\n", "        (_texture->hasMipmaps()) ? backend::SamplerFilter::LINEAR_MIPMAP_NEAREST : backend::SamplerFilter::LINEAR, //minFilter\n", "        backend::SamplerAddressMode::DONT_CARE, //sAddressMode\n", "        backend::SamplerAddressMode::DONT_CARE //tAddressMode\n", "    );\n", "    _texture->updateSamplerDescriptor(descriptor);\n", "}\n"], "Texture2D::getStringForFormat-cons": ["const char* Texture2D::getStringForFormat() const\n", "{\n", "    switch (_pixelFormat) \n", "    {\n", "        case backend::PixelFormat::RGBA8888:\n", "            return  \"RGBA8888\";\n", "\n", "        case backend::PixelFormat::RGB888:\n", "            return  \"RGB888\";\n", "\n", "        case backend::PixelFormat::RGB565:\n", "            return  \"RGB565\";\n", "\n", "        case backend::PixelFormat::RGBA4444:\n", "            return  \"RGBA4444\";\n", "\n", "        case backend::PixelFormat::RGB5A1:\n", "            return  \"RGB5A1\";\n", "\n", "        case backend::PixelFormat::AI88:\n", "            return  \"AI88\";\n", "\n", "        case backend::PixelFormat::A8:\n", "            return  \"A8\";\n", "\n", "        case backend::PixelFormat::I8:\n", "            return  \"I8\";\n", "\n", "        case backend::PixelFormat::PVRTC4:\n", "            return  \"PVRTC4\";\n", "\n", "        case backend::PixelFormat::PVRTC2:\n", "            return  \"PVRTC2\";\n", "\n", "        case backend::PixelFormat::PVRTC2A:\n", "            return \"PVRTC2A\";\n", "        \n", "        case backend::PixelFormat::PVRTC4A:\n", "            return \"PVRTC4A\";\n", "            \n", "        case backend::PixelFormat::ETC:\n", "            return \"ETC\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT1:\n", "            return \"S3TC_DXT1\";\n", "            \n", "        case backend::PixelFormat::S3TC_DXT3:\n", "            return \"S3TC_DXT3\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT5:\n", "            return \"S3TC_DXT5\";\n", "            \n", "        case backend::PixelFormat::ATC_RGB:\n", "            return \"ATC_RGB\";\n", "\n", "        case backend::PixelFormat::ATC_EXPLICIT_ALPHA:\n", "            return \"ATC_EXPLICIT_ALPHA\";\n", "\n", "        case backend::PixelFormat::ATC_INTERPOLATED_ALPHA:\n", "            return \"ATC_INTERPOLATED_ALPHA\";\n", "        \n", "        case backend::PixelFormat::MTL_ABGR4:\n", "            return \"MTL_ABGR4\";\n", "        \n", "        case backend::PixelFormat::MTL_B5G6R5:\n", "            return \"MTL_RGB565\";\n", "        \n", "        case backend::PixelFormat::MTL_BGR5A1:\n", "            return \"MTL_BGR5A1\";\n", "            \n", "        default:\n", "            CCASSERT(false , \"unrecognized pixel format\");\n", "            CCLOG(\"stringForFormat: %ld, cannot give useful result\", (long)_pixelFormat);\n", "            break;\n", "    }\n", "\n", "\treturn  nullptr;\n", "}\n"], "TextureAtlas::initWithTexture-Texture2D*-ssize_t": ["bool TextureAtlas::initWithTexture(Texture2D *texture, ssize_t capacity)\n", "{\n", "    CCASSERT(capacity>=0, \"Capacity must be >= 0\");\n", "    \n", "//    CCASSERT(texture != nullptr, \"texture should not be null\");\n", "    _capacity = capacity;\n", "    _totalQuads = 0;\n", "\n", "    // retained in property\n", "    this->_texture = texture;\n", "    CC_SAFE_RETAIN(_texture);\n", "\n", "    // Re-initialization is not allowed\n", "    CCASSERT(_quads == nullptr && _indices == nullptr, \"_quads and _indices should be nullptr.\");\n", "\n", "    _quads = (V3F_C4B_T2F_Quad*)malloc( _capacity * sizeof(V3F_C4B_T2F_Quad) );\n", "    _indices = (uint16_t *)malloc( _capacity * 6 * sizeof(uint16_t) );\n", "    \n", "    if( ! ( _quads && _indices) && _capacity > 0) \n", "    {\n", "        //CCLOG(\"cocos2d: TextureAtlas: not enough memory\");\n", "        CC_SAFE_FREE(_quads);\n", "        CC_SAFE_FREE(_indices);\n", "\n", "        // release texture, should set it to null, because the destruction will\n", "        // release it too. see cocos2d-x issue #484\n", "        CC_SAFE_RELEASE_NULL(_texture);\n", "        return false;\n", "    }\n", "\n", "    memset( _quads, 0, _capacity * sizeof(V3F_C4B_T2F_Quad) );\n", "    memset( _indices, 0, _capacity * 6 * sizeof(uint16_t) );\n", "    \n", "    this->setupIndices();\n", "\n", "    _dirty = true;\n", "\n", "    return true;\n", "}\n"], "TextureCache::loadImage": ["void TextureCache::loadImage()\n", "{\n", "    AsyncStruct *asyncStruct = nullptr;\n", "    while (!_needQuit)\n", "    {\n", "        std::unique_lock<std::mutex> ul(_requestMutex);\n", "        // pop an AsyncStruct from request queue\n", "        if (_requestQueue.empty())\n", "        {\n", "            asyncStruct = nullptr;\n", "        }\n", "        else\n", "        {\n", "            asyncStruct = _requestQueue.front();\n", "            _requestQueue.pop_front();\n", "        }\n", "\n", "        if (nullptr == asyncStruct) {\n", "            if (_needQuit) {\n", "                break;\n", "            }\n", "            _sleepCondition.wait(ul);\n", "            continue;\n", "        }\n", "        ul.unlock();\n", "\n", "        // load image\n", "        asyncStruct->loadSuccess = asyncStruct->image.initWithImageFileThreadSafe(asyncStruct->filename);\n", "\n", "        // ETC1 ALPHA supports.\n", "        if (asyncStruct->loadSuccess && asyncStruct->image.getFileType() == Image::Format::ETC && !s_etc1AlphaFileSuffix.empty())\n", "        { // check whether alpha texture exists & load it\n", "            auto alphaFile = asyncStruct->filename + s_etc1AlphaFileSuffix;\n", "            if (FileUtils::getInstance()->isFileExist(alphaFile))\n", "                asyncStruct->imageAlpha.initWithImageFileThreadSafe(alphaFile);\n", "        }\n", "        // push the asyncStruct to response queue\n", "        _responseMutex.lock();\n", "        _responseQueue.push_back(asyncStruct);\n", "        _responseMutex.unlock();\n", "    }\n", "}\n"], "Texture2D::initWithString-char*-FontDefinition&": ["bool Texture2D::initWithString(const char *_text, const FontDefinition& textDefinition)\n", "{\n", "    \n", "    if(!_text || 0 == strlen(_text))\n", "    {\n", "        return false;\n", "    }\n", "    \n", "    std::string text = _text;\n", "    \n", "    \n", " #if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n", "    // std::vector <unsigned short> utf16result;\n", "    // utf8::unchecked::utf8to16((char*)text, (char*)text + strlen(text), back_inserter(utf16result));\n", "    // unsigned short utf16string[] = utf16result.;\n", "    // std::vector<unsigned char> utf8result;\n", "    // utf8::unchecked::utf16to8(utf16result.begin(), utf16result.end(), back_inserter(utf8result));\n", "    /* char* pMem = new char [strlen(text) +6];\n", "     memcpy(pMem, text, strlen(text));\n", "     pMem[strlen(text)] = 0;\n", "     //CCLOG(\"beginrender:%s\",text);*/\n", "    int errIndex = 0;\n", "    \n", "    if(s_ANDROID_VER==21||s_ANDROID_VER==22)\n", "    {\n", "        if( !correctUtfBytes( text.c_str(), errIndex ) )// \u5148\u6682\u65f6\u622a\u65ad\u4e0d\u8fd4\u56de\uff0c\u627e\u5230\u597d\u65b9\u5f0f\u518d\u5904\u7406\n", "        {\n", "            int nIdx=errIndex-1;\n", "            if(nIdx>0 && nIdx <text.length())\n", "            {\n", "                text.erase(text.begin()+nIdx,text.end());\n", "            \n", "            }\n", "            else\n", "                return false;\n", "        \n", "        CCLOG(\"initWithString:%s,%d\",text.c_str(), errIndex);\n", "        \n", "            }\n", "    }\n", " #endif\n", "    \n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "    // cache the texture data\n", "    VolatileTextureMgr::addStringTexture(this, text.c_str(), textDefinition);\n", "#endif\n", "    \n", "    TextHAlignment alignment = textDefinition._alignment;\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n", "    //////////////////////////////////////////////////\n", "    // \u963f\u62c9\u4f2f\u8bed\u8a00\u81ea\u52a8\u5de6\u53f3\u5bf9\u9f50\n", "    if (textDefinition._dimensions.width > 0 && isTextFlip())\n", "    {\n", "        //CCLOG(\"initWithString(%0.2f x %0.2f) - %s\", textDefinition._dimensions.width,\n", "        //      textDefinition._dimensions.height, text);\n", "        \n", "//        if (alignment == TextHAlignment::LEFT) {\n", "//            alignment = TextHAlignment::RIGHT;\n", "//        }\n", "//        else if (alignment == TextHAlignment::RIGHT) {\n", "//            alignment = TextHAlignment::LEFT;\n", "//        }\n", "    }\n", "#endif\n", "    \n", "    bool ret = false;\n", "    Device::TextAlign align;\n", "    \n", "    if (TextVAlignment::TOP == textDefinition._vertAlignment)\n", "    {\n", "        align = (TextHAlignment::CENTER == textDefinition._alignment) ? Device::TextAlign::TOP\n", "        : (TextHAlignment::LEFT == textDefinition._alignment) ? Device::TextAlign::TOP_LEFT : Device::TextAlign::TOP_RIGHT;\n", "    }\n", "    else if (TextVAlignment::CENTER == textDefinition._vertAlignment)\n", "    {\n", "        align = (TextHAlignment::CENTER == textDefinition._alignment) ? Device::TextAlign::CENTER\n", "        : (TextHAlignment::LEFT == textDefinition._alignment) ? Device::TextAlign::LEFT : Device::TextAlign::RIGHT;\n", "    }\n", "    else if (TextVAlignment::BOTTOM == textDefinition._vertAlignment)\n", "    {\n", "        align = (TextHAlignment::CENTER == textDefinition._alignment) ? Device::TextAlign::BOTTOM\n", "        : (TextHAlignment::LEFT == textDefinition._alignment) ? Device::TextAlign::BOTTOM_LEFT : Device::TextAlign::BOTTOM_RIGHT;\n", "    }\n", "    else\n", "    {\n", "        CCASSERT(false, \"Not supported alignment format!\");\n", "        return false;\n", "    }\n", "    \n", "    \n", "#if (CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID) && (CC_TARGET_PLATFORM != CC_PLATFORM_IOS)\n", "    CCASSERT(textDefinition._stroke._strokeEnabled == false, \"Currently stroke only supported on iOS and Android!\");\n", "#endif\n", "\n", "    PixelFormat      pixelFormat = PixelFormat::RGBA8888;\n", "    unsigned char* outTempData = nullptr;\n", "    ssize_t outTempDataLen = 0;\n", "\n", "    int imageWidth;\n", "    int imageHeight;\n", "    auto textDef = textDefinition;\n", "    auto contentScaleFactor = CC_CONTENT_SCALE_FACTOR();\n", "    textDef._fontSize *= contentScaleFactor;\n", "    textDef._dimensions.width *= contentScaleFactor;\n", "    textDef._dimensions.height *= contentScaleFactor;\n", "    textDef._stroke._strokeSize *= contentScaleFactor;\n", "    textDef._shadow._shadowEnabled = false;\n", "    // textDef._fontFillColor = Color3B::RED;\n", "    \n", "    bool hasPremultipliedAlpha;\n", "    Data outData = Device::getTextureDataForText(text.c_str(), textDef, align, imageWidth, imageHeight, hasPremultipliedAlpha);\n", "    if(outData.isNull())\n", "    {\n", "        CCLOG(\"create ttf error:%s\" ,text.c_str());\n", "        return false;\n", "    }\n", "\n", "    Size  imageSize = Size((float)imageWidth, (float)imageHeight);\n", "      pixelFormat = convertDataToFormat(outData.getBytes(), imageWidth*imageHeight*4, PixelFormat::RGBA8888, pixelFormat, &outTempData, &outTempDataLen);\n", "    \n", "    \n", "    if( ms_isOnPause )\n", "    {\n", "        CCLOGCRITICAL(\"zym onpause cache initWithString:%s, [%p]\", text.c_str(), this );\n", "        m_cacheData = new CacheBuffer;\n", "        m_cacheData->nType = kString;\n", "        m_cacheData->strContent = text;\n", "        m_cacheData->textDefinitiont = textDefinition;\n", "        \n", "        _contentSize = Size((float)imageWidth, (float)imageHeight);\n", "        _pixelsWide = imageWidth;\n", "        _pixelsHigh = imageHeight;\n", "        _pixelFormat = pixelFormat;\n", "        \n", "        _hasPremultipliedAlpha = hasPremultipliedAlpha;\n", "        \n", "        if (outTempData != nullptr && outTempData != outData.getBytes())\n", "        {\n", "            free(outTempData);\n", "        }\n", "        TextureCache::getInstance()->AddCachGLData(this, EGLDataType::EGLData_Texture2D, EGLOper::EGLOper_Create );\n", "        return true;\n", "    }\n", "\n", "    \n", "    ret = initWithData(outTempData, outTempDataLen, pixelFormat, imageWidth, imageHeight, imageSize);\n", "\n", "    if (outTempData != nullptr && outTempData != outData.getBytes())\n", "    {\n", "        free(outTempData);\n", "    }\n", "    _hasPremultipliedAlpha = hasPremultipliedAlpha;\n", "\n", "    return ret;\n", "}\n"], "Texture2D::getStringForFormat": ["const char* Texture2D::getStringForFormat() const\n", "{\n", "    switch (_pixelFormat) \n", "    {\n", "        case backend::PixelFormat::RGBA8888:\n", "            return  \"RGBA8888\";\n", "\n", "        case backend::PixelFormat::RGB888:\n", "            return  \"RGB888\";\n", "\n", "        case backend::PixelFormat::RGB565:\n", "            return  \"RGB565\";\n", "\n", "        case backend::PixelFormat::RGBA4444:\n", "            return  \"RGBA4444\";\n", "\n", "        case backend::PixelFormat::RGB5A1:\n", "            return  \"RGB5A1\";\n", "\n", "        case backend::PixelFormat::AI88:\n", "            return  \"AI88\";\n", "\n", "        case backend::PixelFormat::A8:\n", "            return  \"A8\";\n", "\n", "        case backend::PixelFormat::I8:\n", "            return  \"I8\";\n", "\n", "        case backend::PixelFormat::PVRTC4:\n", "            return  \"PVRTC4\";\n", "\n", "        case backend::PixelFormat::PVRTC2:\n", "            return  \"PVRTC2\";\n", "\n", "        case backend::PixelFormat::PVRTC2A:\n", "            return \"PVRTC2A\";\n", "        \n", "        case backend::PixelFormat::PVRTC4A:\n", "            return \"PVRTC4A\";\n", "            \n", "        case backend::PixelFormat::ETC:\n", "            return \"ETC\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT1:\n", "            return \"S3TC_DXT1\";\n", "            \n", "        case backend::PixelFormat::S3TC_DXT3:\n", "            return \"S3TC_DXT3\";\n", "\n", "        case backend::PixelFormat::S3TC_DXT5:\n", "            return \"S3TC_DXT5\";\n", "            \n", "        case backend::PixelFormat::ATC_RGB:\n", "            return \"ATC_RGB\";\n", "\n", "        case backend::PixelFormat::ATC_EXPLICIT_ALPHA:\n", "            return \"ATC_EXPLICIT_ALPHA\";\n", "\n", "        case backend::PixelFormat::ATC_INTERPOLATED_ALPHA:\n", "            return \"ATC_INTERPOLATED_ALPHA\";\n", "        \n", "        case backend::PixelFormat::MTL_ABGR4:\n", "            return \"MTL_ABGR4\";\n", "        \n", "        case backend::PixelFormat::MTL_B5G6R5:\n", "            return \"MTL_RGB565\";\n", "        \n", "        case backend::PixelFormat::MTL_BGR5A1:\n", "            return \"MTL_BGR5A1\";\n", "            \n", "        default:\n", "            CCASSERT(false , \"unrecognized pixel format\");\n", "            CCLOG(\"stringForFormat: %ld, cannot give useful result\", (long)_pixelFormat);\n", "            break;\n", "    }\n", "\n", "    return  nullptr;\n", "}\n"], "CCTexture2D.h_header": ["\n", "#include <string>\n", "#include <map>\n", "#include <unordered_map>\n", "\n", "#include \"base/CCRef.h\"\n", "#include \"math/CCGeometry.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "#define CC_SAMLL_TEXTURE_CNT 38\n", "#define CC_SMALL_GENERAL_TEXTURE_CNT 3\n", "\n", "class Image;\n", "class NinePatchInfo;\n", "class SpriteFrame;\n", "typedef struct _MipmapInfo MipmapInfo;\n", "\n", "namespace ui\n", "{\n", "    class Scale9Sprite;\n", "}\n", "\n", "namespace backend {\n", "    class Texture2DBackend;\n", "    class TextureBackend;\n", "    class ProgramState;\n", "}\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "//CONSTANTS:\n", "\n", "class GLProgram;\n", "// Added by ChenFei 2014-12-16 V3.2 support\n", "class TextureCache;\n", "//CLASS INTERFACES:\n", "\n", "/** \n", "* @brief Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data.\n", "* The created Texture2D object will always have power-of-two dimensions.\n", "* Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. \"contentSize\" != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0).\n", "* Be aware that the content of the generated textures will be upside-down!\n", "\n", " */\n", "/*xy\n", " \u4e4b\u524d\u7684\u8d44\u6e90\u91ca\u653e\u89c4\u5219\uff1a\u4e00\u5f20\u8d34\u56fe\u6ca1\u88ab\u4f7f\u7528\u65f6\uff0c\u4f1a\u653e\u5728\u7f13\u5b58\uff0c\u76f4\u81f3removeUnusedTextures \u8c03\u7528\u624d\u5220\u9664\n", " \u65b0\u8d44\u6e90\u91ca\u653e\u89c4\u5219\uff1a\u6539\u4e3a\u4e00\u5f20\u8d34\u56fe\u6ca1\u88ab\u5f15\u7528\u65f6\uff0c\u8fc7N\u79d2\u540e\u81ea\u52a8\u5220\u9664\n", " \u65b9\u6cd5\uff1aTexture2D->release()\u88ab\u8c03\u7528\u65f6\u6253\u4e0a\u65f6\u95f4\u6233\uff0c\u6ca1\u9694\u56fa\u5b9a\u79d2\u68c0\u6d4b\u4e00\u6b21\uff0c\u540c\u65f6\u6ee1\u8db3\u6ca1\u88ab\u5f15\u7528\u5e76\u4e14\u65f6\u95f4\u6233\u65f6\u5dee\u5927\u4e8eN\u65f6\u5220\u9664\n", " */\n"], "CCTexture2D.cpp_cpp": ["\n", "\n", "/*\n", "* Support for RGBA_4_4_4_4 and RGBA_5_5_5_1 was copied from:\n", "* https://devforums.apple.com/message/37855#37855 by a1studmuffin\n", "*/\n", "\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"platform/CCImage.h\"\n", "#include \"platform/CCGL.h\"\n", "#include \"platform/CCImage.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"platform/CCDevice.h\"\n", "#include \"base/ccConfig.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgramCache.h\"\n", "#include \"base/CCNinePatchImageParser.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/ccShaders.h\"\n", "#include \"renderer/CCTextureUtils.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"deprecated/CCString.h\"\n", "#include \"CCFileUtils.h\"\n", "\n", "//#include \"base/unchecked.h\"\n", "//#include \"vector\"\n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "    #include \"renderer/CCTextureCache.h\"\n", "#endif\n", "\n", "extern bool isTextFlip();\n", "\n", "NS_CC_BEGIN\n"], "CCCustomCommand.cpp_cpp": ["#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"renderer/backend/Buffer.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"base/ccUtils.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCCustomCommand.h_header": ["\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"base/IFFunctional.h\"\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "namespace backend\n", "{\n", "    class Buffer;\n", "}\n", "\n", "/**\n", "Custom command is used to draw all things except triangle commands. You can use\n", "this command to draw things, just provide vertex/index data and set corret flags.\n", "*/\n"], "CCGroupCommand.cpp_cpp": ["\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"base/CCDirector.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCGroupCommand.h_header": ["\n", "#include <vector>\n", "#include <unordered_map>\n", "\n", "#include \"base/CCRef.h\"\n", "#include \"renderer/CCRenderCommand.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "//Used for internal\n", "class GroupCommandManager : public Ref\n", "{\n", "public:\n", "    int getGroupID();\n", "    void releaseGroupID(int groupID);\n", "\n", "protected:\n", "    friend class Renderer;\n", "    GroupCommandManager();\n", "    ~GroupCommandManager();\n", "    bool init();\n", "    std::unordered_map<int, bool> _groupMapping;\n", "    std::vector<int> _unusedIDs;\n", "};\n", "\n", "/**\n", " GroupCommand is used to group several command together, and more, it can be nested.\n", " So it is used to generate the hierarchy for the rendcommands. Every group command will be assigned by a group ID.\n", " */\n"], "CCMeshCommand.cpp_cpp": ["#include \"renderer/CCMeshCommand.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventCustom.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"2d/CCLight.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"xxhash.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCMeshCommand.h_header": ["\n", "#include <unordered_map>\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"renderer/backend/Types.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"math/CCMath.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class GLProgramState;\n", "class EventListenerCustom;\n", "class EventCustom;\n", "class Material;\n", "\n", "//it is a common mesh\n"], "CCTrianglesCommand.cpp_cpp": ["#include \"renderer/CCTrianglesCommand.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"xxhash.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"base//ccUtils.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCTrianglesCommand.h_header": ["\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"renderer/CCPipelineDescriptor.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "/** \n", " Command used to render one or more Triangles, which is similar to QuadCommand.\n", " Every TrianglesCommand will have generate material ID by give textureID, glProgramState, Blend function\n", " if the material id is the same, these TrianglesCommands could be batched to save draw call.\n", "*/\n", "namespace backend {\n", "    class TextureBackend;\n", "    class Program;\n", "}\n", "\n", "class Texture2D;\n", "\n"], "CCQuadCommand.cpp_cpp": ["\n", "#include \"renderer/CCQuadCommand.h\"\n", "\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"xxhash.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCQuadCommand.h_header": ["\n", "#include <vector>\n", "\n", "#include \"renderer/CCTrianglesCommand.h\"\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "/** \n", " Command used to render one or more Quads, similar to TrianglesCommand.\n", " Every QuadCommand will have generate material ID by give textureID, glProgramState, Blend function\n", " if the material id is the same, these QuadCommands could be batched to save draw call.\n", " */\n", "\n", "\n"], "CCRenderCommand.cpp_cpp": ["\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"2d/CCNode.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"xxhash.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCRenderCommand.h_header": ["\n", "#include <stdint.h>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"renderer/CCPipelineDescriptor.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "/** Base class of the `RenderCommand` hierarchy.\n", "*\n", " The `Renderer` knows how to render `RenderCommands` objects.\n", " */\n", "class CC_DLL RenderCommand\n", "{\n", "public:\n", "    /**Enum the type of render command. */\n", "    enum class Type\n", "    {\n", "        /** Reserved type.*/\n", "        UNKNOWN_COMMAND,\n", "        /** Quad command, used for draw quad.*/\n", "        QUAD_COMMAND,\n", "        /**Custom command, used for calling callback for rendering.*/\n", "        CUSTOM_COMMAND,\n", "        /**Batch command, used for draw batches in texture atlas.*/\n", "        BATCH_COMMAND,\n", "        /**Group command, which can group command in a tree hierarchy.*/\n", "        GROUP_COMMAND,\n", "        /**Mesh command, used to draw 3D meshes.*/\n", "        MESH_COMMAND,\n", "        /**Primitive command, used to draw primitives such as lines, points and triangles.*/\n", "        PRIMITIVE_COMMAND,\n", "        /**Triangles command, used to draw triangles.*/\n", "        TRIANGLES_COMMAND\n", "    };\n", "\n", "    /**\n", "     Init function, will be called by all the render commands.\n", "     @param globalZOrder The global order of command, used for rendercommand sorting.\n", "     @param modelViewTransform Modelview matrix when submitting the render command.\n", "     @param flags Flag used to indicate whether the command should be draw at 3D mode or not.\n", "     */\n", "    void init(float globalZOrder, const Mat4& modelViewTransform, uint32_t flags);\n", "    \n", "    /** Get global Z order. */\n", "    inline float getGlobalOrder() const { return _globalOrder; }\n", "\n", "    /** Returns the Command type. */\n", "    inline Type getType() const { return _type; }\n", "    \n", "    /** Retruns whether is transparent. */\n", "    inline bool isTransparent() const { return _isTransparent; }\n", "    \n", "    /** Set transparent flag. */\n", "    inline void setTransparent(bool isTransparent) { _isTransparent = isTransparent; }\n", "    /**\n", "     Get skip batching status, if a rendering is skip batching, it will be forced to be rendering separately.\n", "     */\n", "    inline bool isSkipBatching() const { return _skipBatching; }\n", "    /**Set skip batching.*/\n", "    inline void setSkipBatching(bool value) { _skipBatching = value; }\n", "    /**Whether the command should be rendered at 3D mode.*/\n", "    inline bool is3D() const { return _is3D; }\n", "    /**Set the command rendered in 3D mode or not.*/\n", "    inline void set3D(bool value) { _is3D = value; }\n", "    /**Get the depth by current model view matrix.*/\n", "    inline float getDepth() const { return _depth; }\n", "    \n", "protected:\n", "    /**Constructor.*/\n", "    RenderCommand();\n", "    /**Desctructor.*/\n", "    virtual ~RenderCommand();\n", "    //used for debug but it is not implemented.\n", "    void printID();\n", "\n", "    /**Type used in order to avoid dynamic cast, faster. */\n", "    Type _type;\n", "\n", "    /** Commands are sort by global Z order. */\n", "    float _globalOrder;\n", "    \n", "    /** Transparent flag. */\n", "    bool  _isTransparent;\n", "    \n", "    /**\n", "     QuadCommand and TrianglesCommand could be auto batched if there material ID is the same, however, if\n", "     a command is skip batching, it would be forced to draw in a separate function call, and break the batch.\n", "     */\n", "    bool _skipBatching;\n", "    \n", "    /** Is the command been rendered on 3D pass. */\n", "    bool _is3D;\n", "    \n", "    /** Depth from the model view matrix.*/\n", "    float _depth;\n", "};\n", "\n"], "CCRenderCommandPool.h_header": ["/// @cond DO_NOT_SHOW\n", "\n", "#include <list>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "template <class T>\n"], "CCRenderer.cpp_cpp": ["#include \"renderer/CCRenderer.h\"\n", "\n", "#include <algorithm>\n", "\n", "#include \"renderer/CCTrianglesCommand.h\"\n", "#include \"renderer/CCQuadCommand.h\"\n", "#include \"renderer/CCBatchCommand.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"renderer/CCCallbackCommand.h\"\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCPrimitiveCommand.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "#include \"renderer/CCGLProgramCache.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"2d/CCCamera.h\"\n", "#include \"2d/CCScene.h\"\n", "#include \"xxhash.h\"\n", "\n", "#include \"renderer/backend/Backend.h\"\n", "\n", "// \u5b9a\u4e49\u4e34\u65f6\u7684\u5185\u5b58\u5206\u914d\u5668\n", "#include <stdlib.h>\n", "#include <cassert>\n", "\n", "#include <memory>\n", "#include <thread>\n", "\n", "#include <vector>\n", "#include <string>\n", "#include <chrono>\n", "#include <iostream>\n", "\n", "#define TEMP_MALLOC malloc\n", "#define TEMP_FREE free\n", "#define TEMP_NEW_INPLACE(MEMORY) new(MEMORY)\n", "\n", "class LinearAllocator\n", "{\n", "public:\n", "    LinearAllocator(size_t size)\n", "    : m_Ptr{ static_cast<char*>(TEMP_MALLOC(size)) }\n", "    , m_TotalSize{ size }\n", "    , m_FreeSpace{ size }\n", "    {}\n", "    \n", "    ~LinearAllocator()\n", "    {\n", "        TEMP_FREE(m_Ptr);\n", "    }\n", "    \n", "    void* Allocate(size_t size, unsigned alignment /* power of 2 */)\n", "    {\n", "        assert((alignment & (alignment - 1)) == 0);\n", "        \n", "        auto currentPtr = static_cast<void*>(m_Ptr + (m_TotalSize - m_FreeSpace));\n", "        size_t a = (alignment - 1);\n", "        auto retPtr = (void*)(((size_t)currentPtr + a) & ~a);\n", "        \n", "        m_FreeSpace -= ((char*)retPtr - (char*)currentPtr);\n", " //       auto retPtr = std::align(alignment, size, currentPtr, m_FreeSpace);\n", "        \n", "/*        if (!retPtr)\n", "        {\n", "            assert(false && \"Linear allocator full!\");\n", "            // no space\n", "            return nullptr;\n", "        }\n", " */\n", "        \n", "        m_FreeSpace -= size;\n", "        \n", "        return retPtr;\n", "    }\n", "    \n", "    void Free()\n", "    {\n", "        // do nothing\n", "    }\n", "    \n", "    void Reset(size_t freeSpace)\n", "    {\n", "        m_FreeSpace = freeSpace;\n", "    }\n", "    \n", "    size_t CurrentFreeSpace() const { return m_FreeSpace; }\n", "    \n", "private:\n", "    char* m_Ptr;\n", "    size_t m_TotalSize;\n", "    size_t m_FreeSpace;\n", "};\n", "\n", "static LinearAllocator s_linearMemory(1024 * 1024);\n", "static LinearAllocator* tlsLinearAllocator = &s_linearMemory;\n", "\n", "template<typename T>\n", "class TempStdAllocator {\n", "public:\n", "    typedef T value_type;\n", "    typedef value_type* pointer;\n", "    typedef const value_type* const_pointer;\n", "    typedef value_type& reference;\n", "    typedef const value_type& const_reference;\n", "    typedef std::size_t size_type;\n", "    typedef std::ptrdiff_t difference_type;\n", "    \n", "public:\n", "    template<typename U>\n", "    struct rebind {\n", "        typedef TempStdAllocator<U> other;\n", "    };\n", "    \n", "public:\n", "    inline TempStdAllocator() {}\n", "    inline ~TempStdAllocator() {}\n", "    inline TempStdAllocator(const TempStdAllocator& rhs) {}\n", "    \n", "    template<typename U>\n", "    inline TempStdAllocator(const TempStdAllocator<U>& rhs) {}\n", "    \n", "    inline pointer address(reference r) { return &r; }\n", "    inline const_pointer address(const_reference r) { return &r; }\n", "    \n", "    inline pointer allocate(size_type cnt, typename std::allocator<void>::const_pointer = 0)\n", "    {\n", "        return reinterpret_cast<pointer>(tlsLinearAllocator->Allocate(unsigned(cnt * sizeof(T)), sizeof(size_t) == 4 ? 8 : 16));\n", "    }\n", "    inline void deallocate(pointer p, size_type)\n", "    {\n", "        // do nothing\n", "    }\n", "    \n", "    inline size_type max_size() const\n", "    {\n", "        return std::numeric_limits<size_type>::max() / sizeof(T);\n", "    }\n", "    \n", "    template <class U, class... Args>\n", "    inline void construct(U* p, Args&&... args)\n", "    {\n", "        TEMP_NEW_INPLACE(p) U(std::forward<Args>(args)...);\n", "    }\n", "    \n", "    inline void destroy(pointer p) { p->~T(); }\n", "    \n", "    inline bool operator==(TempStdAllocator const&) const { return true; }\n", "    inline bool operator!=(TempStdAllocator const& a) const { return !operator==(a); }\n", "    \n", "private:\n", "    template<typename U> friend class TempStdAllocator;\n", "};\n", "\n", "struct TempAllocatorScope\n", "{\n", "public:\n", "    TempAllocatorScope(int unused)\n", "    : m_Space(tlsLinearAllocator->CurrentFreeSpace())\n", "    {}\n", "    \n", "    ~TempAllocatorScope()\n", "    {\n", "        tlsLinearAllocator->Reset(m_Space);\n", "    }\n", "    \n", "    void Reset()\n", "    {\n", "        tlsLinearAllocator->Reset(m_Space);\n", "    }\n", "private:\n", "    size_t m_Space;\n", "};\n", "\n", "template<typename T>\n", "class dynamicArray\n", "{\n", "public:\n", "    \n", "    dynamicArray():m_data(nullptr),m_size(0),m_capacity(0)\n", "    {\n", "        \n", "    }\n", "    \n", "    dynamicArray(size_t inCapacity):m_size(0),m_capacity(inCapacity)\n", "    {\n", "        m_data = static_cast<T*>(tlsLinearAllocator->Allocate(unsigned(inCapacity * sizeof(T)), sizeof(size_t) == 4 ? 8 : 16));\n", "    }\n", "    \n", "    inline void reserve(size_t inCapacity)\n", "    {\n", "        if (m_capacity >= inCapacity)\n", "        {\n", "            return;\n", "        }\n", "        \n", "        T* newData = static_cast<T*>(tlsLinearAllocator->Allocate(unsigned(inCapacity * sizeof(T)), sizeof(size_t) == 4 ? 8 : 16));\n", "        memcpy((void*)newData, (void*)m_data, m_size * sizeof(T));\n", "        m_capacity = inCapacity;\n", "        m_data = newData;\n", "    }\n", "    \n", "    inline T& emplace_back()\n", "    {\n", "        size_t oldSize = m_size;\n", "        size_t newSize = oldSize + 1;\n", "        \n", "        if (newSize > m_capacity)\n", "        {\n", "            reserve(m_capacity + 10);\n", "        }\n", "        \n", "        m_size = newSize;\n", "        T& val = m_data[oldSize];\n", "        return val;\n", "    }\n", "    \n", "    inline void push_back(const T& t)\n", "    {\n", "        size_t oldSize = m_size;\n", "        size_t newSize = oldSize + 1;\n", "        \n", "        if (newSize > m_capacity)\n", "        {\n", "            reserve(m_capacity + 10);\n", "        }\n", "        \n", "        m_size = newSize;\n", "        m_data[oldSize] = t;\n", "    }\n", "    \n", "    inline size_t size()\n", "    {\n", "        return m_size;\n", "    }\n", "    \n", "    inline void clear()\n", "    {\n", "        m_size = 0;\n", "    }\n", "    \n", "    inline void reset()\n", "    {\n", "        m_data = nullptr;\n", "        m_size = 0;\n", "        m_capacity = 0;\n", "    }\n", "    \n", "    inline T& operator[] (size_t index)\n", "    {\n", "        return m_data[index];\n", "    }\n", "    \n", "private:\n", "    T* m_data;\n", "    size_t m_size;\n", "    size_t m_capacity;\n", "};\n", "\n", "template<typename T>\n", "class FixArray\n", "{\n", "public:\n", "    \n", "    FixArray(size_t size):m_size(size)\n", "    {\n", "        m_data = static_cast<T*>(tlsLinearAllocator->Allocate(unsigned(m_size * sizeof(T)), sizeof(size_t) == 4 ? 8 : 16));\n", "    }\n", "    \n", "    inline size_t size()\n", "    {\n", "        return m_size;\n", "    }\n", "    \n", "    inline T& operator[] (size_t index)\n", "    {\n", "        return m_data[index];\n", "    }\n", "    \n", "private:\n", "    T* m_data;\n", "    size_t m_size;\n", "};\n", "\n", "NS_CC_BEGIN\n"], "CCRenderer.h_header": ["\n", "#include <vector>\n", "#include <stack>\n", "#include <array>\n", "#include <deque>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"renderer/CCRenderCommand.h\"\n", "#include \"renderer/backend/Types.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"platform/CCGL.h\"\n", "\n", "/**\n", " * @addtogroup renderer\n", " * @{\n", " */\n", "\n", "NS_CC_BEGIN\n", "\n", "using CullMode = backend::CullMode;\n", "using Winding = backend::Winding;\n", "\n", "namespace backend\n", "{\n", "    class Buffer;\n", "    class CommandBuffer;\n", "    class RenderPipeline;\n", "    class RenderPass;\n", "    struct RenderPipelineDescriptor;\n", "}\n", "\n", "class EventListenerCustom;\n", "class QuadCommand;\n", "class TrianglesCommand;\n", "class MeshCommand;\n", "class GroupCommand;\n", "class CallbackCommand;\n", "struct PipelineDescriptor;\n", "class Texture2D;\n", "\n", "/** Class that knows how to sort `RenderCommand` objects.\n", " Since the commands that have `z == 0` are \"pushed back\" in\n", " the correct order, the only `RenderCommand` objects that need to be sorted,\n", " are the ones that have `z < 0` and `z > 0`.\n", "*/\n", "\n", "\n", "\n", "class RenderQueue {\n", "public:\n", "    /**\n", "    RenderCommand will be divided into Queue Groups.\n", "    */\n", "    enum QUEUE_GROUP\n", "    {\n", "        /**Objects with globalZ smaller than 0.*/\n", "        GLOBALZ_NEG = 0,\n", "        /**Opaque 3D objects with 0 globalZ.*/\n", "        OPAQUE_3D = 1,\n", "        /**Transparent 3D objects with 0 globalZ.*/\n", "        TRANSPARENT_3D = 2,\n", "        /**2D objects with 0 globalZ.*/\n", "        GLOBALZ_ZERO = 3,\n", "        /**Objects with globalZ bigger than 0.*/\n", "        GLOBALZ_POS = 4,\n", "        QUEUE_COUNT = 5,\n", "    };\n", "\n", "public:\n", "    /**Constructor.*/\n", "    RenderQueue();\n", "    /**Push a renderCommand into current renderqueue.*/\n", "    void push_back(RenderCommand* command);\n", "    /**Return the number of render commands.*/\n", "    ssize_t size() const;\n", "    /**Sort the render commands.*/\n", "    void sort();\n", "    /**Treat sorted commands as an array, access them one by one.*/\n", "    RenderCommand* operator[](ssize_t index) const;\n", "    /**Clear all rendered commands.*/\n", "    void clear();\n", "    /**Realloc command queues and reserve with given size. Note: this clears any existing commands.*/\n", "    void realloc(size_t reserveSize);\n", "    /**Get a sub group of the render queue.*/\n", "    inline std::vector<RenderCommand*>& getSubQueue(QUEUE_GROUP group) { return _commands[group]; }\n", "    /**Get the number of render commands contained in a subqueue.*/\n", "    inline ssize_t getSubQueueSize(QUEUE_GROUP group) const { return _commands[group].size();}\n", "\n", "    /**Save the current DepthState, CullState, DepthWriteState render state.*/\n", "    void saveRenderState();\n", "    /**Restore the saved DepthState, CullState, DepthWriteState render state.*/\n", "    void restoreRenderState();\n", "    \n", "protected:\n", "    /**The commands in the render queue.*/\n", "    std::vector<RenderCommand*> _commands[QUEUE_COUNT];\n", "    \n", "    /**Cull state.*/\n", "    bool _isCullEnabled;\n", "    /**Depth test enable state.*/\n", "    bool _isDepthEnabled;\n", "    /**Depth buffer write state.*/\n", "    GLboolean _isDepthWrite;\n", "};\n", "\n", "//the struct is not used outside.\n", "struct RenderStackElement\n", "{\n", "    int renderQueueID;\n", "    ssize_t currentIndex;\n", "};\n", "\n", "class GroupCommandManager;\n", "\n", "/* Class responsible for the rendering in.\n", "\n", "Whenever possible prefer to use `QuadCommand` objects since the renderer will automatically batch them.\n", " */\n"], "ccShaders.cpp_cpp": ["#include \"renderer/ccShaders.h\"\n", "\n", "#define STRINGIFY(A)  #A\n", "\n", "NS_CC_BEGIN\n"], "CCTextureAtlas.cpp_cpp": ["#include \"renderer/CCTextureAtlas.h\"\n", "\n", "#include <stdlib.h>\n", "\n", "#include \"base/ccMacros.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/CCEventType.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCConfiguration.h\"\n", "#include \"base/CCEventDispatcher.h\"\n", "#include \"base/CCEventListenerCustom.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"platform/CCGL.h\"\n", "\n", "\n", "#include \"deprecated/CCString.h\"\n", "\n", "//According to some tests GL_TRIANGLE_STRIP is slower, MUCH slower. Probably I'm doing something very wrong\n", "\n", "// implementation TextureAtlas\n", "\n", "NS_CC_BEGIN\n"], "CCTextureAtlas.h_header": ["\n", "#include <string>\n", "\n", "#include \"base/ccTypes.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"base/ccConfig.h\"\n", "#include \"renderer/CCTrianglesCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Texture2D;\n", "class EventCustom;\n", "class EventListenerCustom;\n", "\n", "\n", "\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "\n", "/** @brief A class that implements a Texture Atlas.\n", "Supported features:\n", "* The atlas file can be a PVRTC, PNG or any other format supported by Texture2D\n", "* Quads can be updated in runtime\n", "* Quads can be added in runtime\n", "* Quads can be removed in runtime\n", "* Quads can be re-ordered in runtime\n", "* The TextureAtlas capacity can be increased or decreased in runtime\n", "* OpenGL component: V3F, C4B, T2F.\n", "The quads are rendered using an OpenGL ES VBO.\n", "To render the quads using an interleaved vertex array list, you should modify the ccConfig.h file \n", "\n", "@warning If you want to use TextureAtlas, you'd better setup GL status before it's rendered.\n", "         Otherwise, the effect of TextureAtlas will be affected by the GL status of other nodes.\n", "*/\n"], "CCTextureCache.cpp_cpp": ["#include \"renderer/CCTextureCache.h\"\n", "\n", "#include <errno.h>\n", "#include <stack>\n", "#include <cctype>\n", "#include <list>\n", "\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"base/ccMacros.h\"\n", "#include \"base/ccUTF8.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"base/CCScheduler.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"base/ccUtils.h\"\n", "\n", "#include \"deprecated/CCString.h\"\n", "#include \"base/CCNinePatchImageParser.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"renderer/CCTextureAtlas.h\"\n", "#include \"2d/CCSpriteFrameCache.h\"\n", "#ifdef EMSCRIPTEN\n", "#include <emscripten/emscripten.h>\n", "#include \"platform/emscripten/CCTextureCacheEmscripten.h\"\n", "#endif // EMSCRIPTEN\n", "#include \"2d/CCParticleSystemQuad.h\"\n", "using namespace std;\n", "\n", "bool IsExistCompressFile(const char* fileName);\n", "void ResetCompressFullFileName(const std::string& path, std::string& fullpath);\n", " \n", "NS_CC_BEGIN\n"], "VolatileTextureMgr::reloadAllTextures": ["void VolatileTextureMgr::reloadAllTextures()\n", "{\n", "    _isReloading = true;\n", "    CCLOG(\"reload all texture\");\n", "\n", "    for (auto& texture : _textures)\n", "    {\n", "        VolatileTexture *vt = texture;\n", "\n", "        switch (vt->_cashedImageType)\n", "        {\n", "        case VolatileTexture::kImageFile:\n", "        {\n", "            reloadTexture(vt->_texture, vt->_fileName, vt->_pixelFormat);\n", "\n", "            // etc1 support check whether alpha texture exists & load it\n", "            auto alphaFile = vt->_fileName + TextureCache::getETC1AlphaFileSuffix();\n", "            reloadTexture(vt->_texture->getAlphaTexture(), alphaFile, vt->_pixelFormat);\n", "        }\n", "        break;\n", "        case VolatileTexture::kImageData:\n", "        {\n", "            vt->_texture->initWithData(vt->_textureData,\n", "                vt->_dataLen,\n", "                vt->_pixelFormat,\n", "                vt->_textureSize.width,\n", "                vt->_textureSize.height,\n", "                vt->_textureSize);\n", "        }\n", "        break;\n", "        case VolatileTexture::kString:\n", "        {\n", "            vt->_texture->initWithString(vt->_text.c_str(), vt->_fontDefinition);\n", "        }\n", "        break;\n", "        case VolatileTexture::kImage:\n", "        {\n", "            vt->_texture->initWithImage(vt->_uiImage, vt->_pixelFormat);\n", "        }\n", "        break;\n", "        default:\n", "            break;\n", "        }\n", "    }\n", "\n", "    _isReloading = false;\n", "}\n"], "CCTextureCache.h_header": ["\n", "#include <string>\n", "#include <mutex>\n", "#include <thread>\n", "#include <condition_variable>\n", "#include <queue>\n", "#include <string>\n", "#include <unordered_map>\n", "#include <functional>\n", "#include \"2d/CCActionInstant.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"platform/CCImage.h\"\n", "#include \"base/CCRefPtr.h\"\n", "\n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "    #include \"platform/CCImage.h\"\n", "    #include <list>\n", "#endif\n", "\n", "// Added by ChenFei 2014-12-16 V3.2 support\n", "#include \"deprecated/CCDictionary.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "/**\n", " * @addtogroup _2d\n", " * @{\n", " */\n", "/*\n", "* From version 3.0, TextureCache will never be treated as a singleton, it will be owned by director.\n", "* All call by TextureCache::getInstance() should be replaced by Director::getInstance()->getTextureCache().\n", "*/\n", "\n", "/** @brief Singleton that handles the loading of textures.\n", "* Once the texture is loaded, the next time it will return.\n", "* A reference of the previously loaded texture reducing GPU & CPU memory.\n", "*/\n", "\n", "// \u8d44\u6e90\u7c7b\u578b\n", "enum EGLDataType\n", "{\n", "    EGLData_None = -1,\n", "    EGLData_Texture2D = 0, // \u8d34\u56fe\n", "    EGLData_TextureAtlas,\n", "    EGLData_TextureAtlasmap,\n", "    EGLData_RenderTexture,    //\u6e32\u67d3\u56fe\u521b\u5efa\n", "    EGLData_Texture2DParams,  // \u6e32\u67d3\u53c2\u6570\u8bbe\u7f6e\n", "    EGLData_Texture2DAliasTex,\n", "    EGLData_Texture2DAntiAliasTex,\n", "    EGLData_Particle,        // \u7c92\u5b50\n", "    EGLData_ParticleSetup,\n", "    EGLData_ParticleDelBuffer\n", "    \n", "};\n", "\n", "enum EGLOper\n", "{\n", "    EGLOper_Create = 0,   // \u521b\u5efa\uff0c\u8bbe\u7f6e\n", "    EGLOper_Delete  // \u5220\u9664\n", "};\n", "\n", "// \u7f13\u51b2\u64cd\u4f5c\u7c7b\n", "class GLDelayBuffer\n", "{\n", "public:\n", "    GLDelayBuffer(Ref* pData, EGLDataType type, EGLOper oper )\n", "    :nType(type)\n", "    ,nOper(oper)\n", "    ,glNode(pData)\n", "    {\n", "        if( glNode )\n", "            glNode->retain();\n", "    }\n", "    ~GLDelayBuffer()\n", "    {\n", "        if( glNode )\n", "            glNode->release();\n", "    }\n", "    void doIt();\n", "    \n", "    EGLDataType   nType;  // \u8d44\u6e90\u7c7b\u578b\n", "    EGLOper       nOper;  // \u64cd\u4f5c\u7c7b\u578b\n", "    Ref*          glNode; // \u5bf9\u8c61\n", "    Texture2D::TexParams  texParams;   // \u53c2\u6570\n", "};\n", "\n", "class CC_DLL TextureCache : public Ref\n", "{\n", "public:\n", "    // ETC1 ALPHA supports.\n", "    static void setETC1AlphaFileSuffix(const std::string& suffix);\n", "    static std::string getETC1AlphaFileSuffix();\n", "    /** Returns the shared instance of the cache. */\n", "    CC_DEPRECATED_ATTRIBUTE static TextureCache * getInstance();\n", "\n", "    /** @deprecated Use getInstance() instead. */\n", "    CC_DEPRECATED_ATTRIBUTE static TextureCache * sharedTextureCache();\n", "\n", "    /** Purges the cache. It releases the retained instance.\n", "     @since v0.99.0\n", "     */\n", "    CC_DEPRECATED_ATTRIBUTE static void destroyInstance();\n", "\n", "    /** @deprecated Use destroyInstance() instead. */\n", "    CC_DEPRECATED_ATTRIBUTE static void purgeSharedTextureCache();\n", "\n", "    /** Reload all textures.\n", "    Should not call it, called by frame work.\n", "    Now the function do nothing, use VolatileTextureMgr::reloadAllTextures.\n", "     */\n", "    CC_DEPRECATED_ATTRIBUTE static void reloadAllTextures();\n", "\n", "    // Added by ChenFei 2014-12-16 V3.2 support\n", "    __Dictionary* snapshotTextures();\n", "public:\n", "    /**\n", "     * @js ctor\n", "     */\n", "    TextureCache();\n", "    /**\n", "     * @js NA\n", "     * @lua NA\n", "     */\n", "    virtual ~TextureCache();\n", "    /**\n", "     * @js NA\n", "     * @lua NA\n", "     */\n", "    virtual std::string getDescription() const;\n", "\n", "//    Dictionary* snapshotTextures();\n", "\n", "    void AddCachGLData( Ref* , EGLDataType nType, EGLOper nOper );\n", "    void AddCachGLTexParams( Ref*, const Texture2D::TexParams& params);\n", "    void UpdateDelayBuffer();\n", "    \n", "    // \u5728\u521b\u5efa\u8d34\u56fe\u5931\u8d25\u65f6\uff0c\u8c03\u7528\u4e00\u5f20\u73b0\u6709\u7684\uff0c\u5e94\u8be5\u4f1a\u51fa\u73b0\u663e\u793a\u8d34\u56fe\u9519\u8bef\u95ee\u9898\uff0c\u4f46\u4f1a\u907f\u514d\u5d29\u6e83\n", "    // \u4ee5\u540e\u53ef\u4ee5\u4e13\u95e8\u521b\u5efa\u4e00\u5f20\u9ed8\u8ba4\u8d34\u56fe\uff0c\u7528\u4e8e\u8865\u6f0f\n", "    Texture2D* getFirstImage();\n", "    \n", "    /** Returns a Texture2D object given an filename.\n", "    * If the filename was not previously loaded, it will create a new Texture2D.\n", "    * Object and it will return it. It will use the filename as a key.\n", "    * Otherwise it will return a reference of a previously loaded image.\n", "    * Supported image extensions: .png, .bmp, .jpeg, .pvr.\n", "     @param filepath The file path.\n", "    */\n", "    Texture2D* addImage(const std::string &filepath,bool isForceLoadTexture=false);\n", "    Texture2D* addImageWithPath(Image *image, const std::string &filepath);\n", "    Texture2D* addTexture(Texture2D* pTex,const std::string &filepath);\n", "    /** Returns a Texture2D object given a file image.\n", "    * If the file image was not previously loaded, it will create a new Texture2D object and it will return it.\n", "    * Otherwise it will load a texture in a new thread, and when the image is loaded, the callback will be called with the Texture2D as a parameter.\n", "    * The callback will be called from the main thread, so it is safe to create any cocos2d object from the callback.\n", "    * Supported image extensions: .png, .jpg\n", "     @param filepath A null terminated string.\n", "     @param callback A callback function would be inovked after the image is loaded.\n", "     @since v0.8\n", "    */\n", "    //\u4fee\u6539\u4e0b\u5047\u5f02\u6b65\u51fd\u6570\u63a5\u53e3\uff0c\u8ba9\u5b83\u66ff\u6362\u73b0\u6709\u7684\u7ebf\u7a0b\u52a0\u8f7d\u8d44\u6e90 by sxy\n", "    virtual void addImageAsync(const std::string &filepath, cocos2d::__CCCallFuncO* callback);\n", "    \n", "    /** Unbind a specified bound image asynchronous callback.\n", "     * In the case an object who was bound to an image asynchronous callback was destroyed before the callback is invoked,\n", "     * the object always need to unbind this callback manually.\n", "     * @param filename It's the related/absolute path of the file image.\n", "     * @since v3.1\n", "     */\n", "    virtual void unbindImageAsync(const std::string &filename);\n", "    \n", "    /** Unbind all bound image asynchronous load callbacks.\n", "     * @since v3.1\n", "     */\n", "    virtual void unbindAllImageAsync();\n", "\n", "    /** Returns a Texture2D object given an Image.\n", "    * If the image was not previously loaded, it will create a new Texture2D object and it will return it.\n", "    * Otherwise it will return a reference of a previously loaded image.\n", "    * @param key The \"key\" parameter will be used as the \"key\" for the cache.\n", "    * If \"key\" is nil, then a new texture will be created each time.\n", "    */\n", "    Texture2D* addImage(Image *image, const std::string &key);\n", "    CC_DEPRECATED_ATTRIBUTE Texture2D* addUIImage(Image *image, const std::string& key) { return addImage(image,key); }\n", "\n", "    /** Returns an already created texture. Returns nil if the texture doesn't exist.\n", "    @param key It's the related/absolute path of the file image.\n", "    @since v0.99.5\n", "    */\n", "    Texture2D* getTextureForKey(const std::string& key) const;\n", "    CC_DEPRECATED_ATTRIBUTE Texture2D* textureForKey(const std::string& key) const { return getTextureForKey(key); }\n", "\n", "    /** Reload texture from the image file.\n", "    * If the file image hasn't loaded before, load it.\n", "    * Otherwise the texture will be reloaded from the file image.\n", "    * @param fileName It's the related/absolute path of the file image.\n", "    * @return True if the reloading is succeed, otherwise return false.\n", "    */\n", "    bool reloadTexture(const std::string& fileName);\n", "    bool reloadTextureWithImage(const std::string& fileName, Image* image);\n", "    \n", "    /** Purges the dictionary of loaded textures.\n", "    * Call this method if you receive the \"Memory Warning\".\n", "    * In the short term: it will free some resources preventing your app from being killed.\n", "    * In the medium term: it will allocate more resources.\n", "    * In the long term: it will be the same.\n", "    */\n", "    void removeAllTextures();\n", "\n", "    /** Removes unused textures.\n", "    * Textures that have a retain count of 1 will be deleted.\n", "    * It is convenient to call this method after when starting a new Scene.\n", "    * @since v0.8\n", "    */\n", "    void removeUnusedTextures();\n", "\n", "    //by xy return\u6389\u8fd9\u51fd\u6570,\u6253\u5f00removeUnusedTextures\u51fd\u6570\uff0c\u5c31\u53ef\u4ee5\u6062\u590d\u4e4b\u524d\u7684\u8d44\u6e90\u91ca\u653e\u65b9\u5f0f\n", "    //Director::drawScene\u4e2d\u8c03\u7528\n", "    void UpdateForAutoRemoveUnusedTextures(float time);\n", "    /** Deletes a texture from the cache given a texture.\n", "    */\n", "    void removeTexture(Texture2D* texture);\n", "\n", "    /** Deletes a texture from the cache given a its key name.\n", "    @param key It's the related/absolute path of the file image.\n", "    @since v0.99.4\n", "    */\n", "    void removeTextureForKey(const std::string &key);\n", "\n", "    /** Output to CCLOG the current contents of this TextureCache.\n", "    * This will attempt to calculate the size of each texture, and the total texture memory in use.\n", "    *\n", "    * @since v1.0\n", "    */\n", "    std::string getCachedTextureInfo() const;\n", "\n", "    //Wait for texture cahe to quit befor destroy instance.\n", "    /**Called by director, please do not called outside.*/\n", "    void waitForQuit();\n", "    \n", "    void EnableDefaultTexture(bool bEnable) { bDefaultTexture = bEnable; }\n", "    /**\n", "     * Get the file path of the texture\n", "     *\n", "     * @param texture A Texture2D object pointer.\n", "     *\n", "     * @return The full path of the file.\n", "     */\n", "    const std::string getTextureFilePath(Texture2D* texture)const;\n", "    \n", "    // Added by ChenFei 2014-12-15 V3.2 support\n", "public:\n", "    /** Output to CCLOG the current contents of this CCTextureCache\n", "     * This will attempt to calculate the size of each texture, and the total texture memory in use\n", "     *\n", "     * @since v1.0\n", "     */\n", "    void dumpCachedTextureInfo();\n", "\n", "private:\n", "    void addImageAsyncCallBack(float dt);\n", "    void loadImage();\n", "    void parseNinePatchImage(Image* image, Texture2D* texture, const std::string& path);\n", "public:\n", "    struct AsyncStruct\n", "    {\n", "    public:\n", "        AsyncStruct(const std::string& fn, std::function<void(Texture2D*)> f) : filename(fn), callback(f) {}\n", "\n", "        std::string filename;\n", "        std::function<void(Texture2D*)> callback;\n", "    };\n", "    std::unordered_map<std::string, Texture2D*> _textures;\n", "protected:\n", "    typedef struct _ImageInfo\n", "    {\n", "        AsyncStruct *asyncStruct;\n", "        Image        *image;\n", "    } ImageInfo;\n", "    \n", "    std::thread* _loadingThread;\n", "\n", "    std::deque<AsyncStruct*>* _asyncStructQueue;\n", "    std::deque<ImageInfo*>* _imageInfoQueue;\n", "\n", "    std::mutex _asyncMutex;\n", "\n", "    std::mutex _sleepMutex;\n", "    std::condition_variable _sleepCondition;\n", "\n", "    bool _needQuit;\n", "\n", "    int _asyncRefCount;\n", "    float _loadTime=0.0f;\n", "    std::vector<GLDelayBuffer*>     _vecGlData;\n", "    \n", "    bool bDefaultTexture; // \u4f7f\u7528\u9ed8\u8ba4\u8d34\u56fe\n", "    \n", "    float m_fTimeCount;\n", "    struct sCallback\n", "    {\n", "        std::string textureName;\n", "        RefPtr<__CCCallFuncO> callback;\n", "    };\n", "    std::vector<sCallback> m_callbackList;\n", "};\n", "\n", "#if CC_ENABLE_CACHE_TEXTURE_DATA\n", "\n", "class VolatileTexture\n", "{\n", "    typedef enum {\n", "        kInvalid = 0,\n", "        kImageFile,\n", "        kImageData,\n", "        kString,\n", "        kImage,\n", "    }ccCachedImageType;\n", "\n", "private:\n", "    VolatileTexture(Texture2D *t);\n", "    /**\n", "     * @js NA\n", "     * @lua NA\n", "     */\n", "    ~VolatileTexture();\n", "\n", "protected:\n", "    friend class  VolatileTextureMgr;\n", "    Texture2D *_texture;\n", "    \n", "    Image *_uiImage;\n", "\n", "    ccCachedImageType _cashedImageType;\n", "\n", "    void *_textureData;\n", "    int  _dataLen;\n", "    Size _textureSize;\n", "    backend::PixelFormat _pixelFormat;\n", "\n", "    std::string _fileName;\n", "\n", "    bool                      _hasMipmaps;\n", "    Texture2D::TexParams      _texParams;\n", "    std::string               _text;\n", "    FontDefinition            _fontDefinition;\n", "};\n", "\n"], "CCRenderState.cpp_cpp": ["#include \"renderer/CCRenderState.h\"\n", "\n", "#include <string>\n", "#include <cassert>\n", "\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "\n", "\n", "NS_CC_BEGIN\n"], "RenderState::StateBlock::setState-std::string&-std::string&": ["void RenderState::StateBlock::setState(const std::string& name, const std::string& value)\n", "{\n", "    if (name.compare(\"blend\") == 0)\n", "    {\n", "        setBlend(parseBoolean(value));\n", "    }\n", "    else if (name.compare(\"blendSrc\") == 0)\n", "    {\n", "        setBlendSrc(parseBlend(value));\n", "    }\n", "    else if (name.compare(\"blendDst\") == 0)\n", "    {\n", "        setBlendDst(parseBlend(value));\n", "    }\n", "    else if (name.compare(\"cullFace\") == 0)\n", "    {\n", "        setCullFace(parseBoolean(value));\n", "    }\n", "    else if (name.compare(\"cullFaceSide\") == 0)\n", "    {\n", "        setCullFaceSide(parseCullFaceSide(value));\n", "    }\n", "    else if (name.compare(\"frontFace\") == 0)\n", "    {\n", "        setFrontFace(parseFrontFace(value));\n", "    }\n", "    else if (name.compare(\"depthTest\") == 0)\n", "    {\n", "        setDepthTest(parseBoolean(value));\n", "    }\n", "    else if (name.compare(\"depthWrite\") == 0)\n", "    {\n", "        setDepthWrite(parseBoolean(value));\n", "    }\n", "    else if (name.compare(\"depthFunc\") == 0)\n", "    {\n", "        setDepthFunction(parseDepthFunc(value));\n", "    }\n", "    else\n", "    {\n", "        CCLOG(\"Unsupported render state string '%s'.\", name.c_str());\n", "    }\n", "}\n"], "CCRenderState.h_header": ["\n", "#include <string>\n", "#include <functional>\n", "#include <cstdint>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"base/ccTypes.h\"\n", "#include \"base/CCVector.h\"\n", "\n", "#include \"renderer/CCPipelineDescriptor.h\"\n", "#include \"renderer/backend/Types.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Texture2D;\n", "class Pass;\n", "class MeshCommand;\n", "\n", "using CullFaceSide = backend::CullMode;\n", "using FrontFace = backend::Winding;\n", "using DepthFunction = backend::CompareFunction;\n", "\n", "/**\n", " * Defines the rendering state of the graphics device.\n", " */\n"], "CCPass.cpp_cpp": ["#include \"CCPass.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/ccGLStateCache.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/backend/ProgramState.h\"\n", "#include \"3d/CCMeshVertexIndexData.h\"\n", "#include \"3d/CCVertexAttribBinding.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"renderer/CCRenderer.h\"\n", "#include \"renderer/CCVertexAttribBinding.h\"\n", "\n", "#include \"base/ccTypes.h\"\n", "#include \"base/ccUtils.h\"\n", "#include \"2d/CCNode.h\"\n", "\n", "#include <xxhash.h>\n", "\n", "NS_CC_BEGIN\n"], "CCPass.h_header": ["\n", "#include <stdio.h>\n", "\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/CCMeshCommand.h\"\n", "#include \"renderer/CCGroupCommand.h\"\n", "#include \"renderer/CCCallbackCommand.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class GLProgramState;\n", "class ProgramState;\n", "class Technique;\n", "class Node;\n", "class VertexAttribBinding;\n", "class MeshIndexData;\n", "class RenderState;\n", "\n", "namespace backend\n", "{\n", "    class ProgramState;\n", "    class Buffer;\n", "}\n", "\n"], "CCTechnique.cpp_cpp": ["#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCPass.h\"\n", "\n", "NS_CC_BEGIN\n"], "CCTechnique.h_header": ["\n", "#include <string>\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"platform/CCPlatformMacros.h\"\n", "#include \"base/CCVector.h\"\n", "\n", "NS_CC_BEGIN\n", "\n", "class Pass;\n", "class GLProgramState;\n", "namespace  backend\n", "{\n", "    class ProgramState;\n", "}\n", "class Material;\n", "\n", "/// Technique\n"], "CCMaterial.cpp_cpp": ["#include \"renderer/CCMaterial.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCPass.h\"\n", "#include \"renderer/CCTextureCache.h\"\n", "#include \"renderer/CCTexture2D.h\"\n", "#include \"renderer/backend/Device.h\"\n", "#include \"renderer/CCGLProgram.h\"\n", "#include \"renderer/CCGLProgramState.h\"\n", "#include \"base/CCProperties.h\"\n", "#include \"base/CCDirector.h\"\n", "#include \"platform/CCFileUtils.h\"\n", "#include \"base/CCConsole.h\"\n", "\n", "#include <sstream>\n", "\n", "\n", "#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)\n", "#define strcasecmp _stricmp\n", "#endif\n", "\n", "NS_CC_BEGIN\n"], "Material::parseSampler-backend::ProgramState*-Properties*": ["bool Material::parseSampler(backend::ProgramState* programState, Properties* samplerProperties)\n", "{\n", "    CCASSERT(samplerProperties->getId(), \"Sampler must have an id. The id is the uniform name\");\n", "    \n", "    // required\n", "    auto filename = samplerProperties->getString(\"path\");\n", "\n", "    auto texture = Director::getInstance()->getTextureCache()->addImage(filename);\n", "    if (!texture) {\n", "        CCLOG(\"Invalid filepath\");\n", "        return false;\n", "    }\n", "\n", "    // optionals\n", "    {\n", "        Texture2D::TexParams texParams;\n", "\n", "        // mipmap\n", "        bool usemipmap = false;\n", "        const char* mipmap = getOptionalString(samplerProperties, \"mipmap\", \"false\");\n", "        if (mipmap && strcasecmp(mipmap, \"true\")==0) {\n", "            texture->generateMipmap();\n", "            usemipmap = true;\n", "        }\n", "\n", "        // valid options: REPEAT, CLAMP\n", "        const char* wrapS = getOptionalString(samplerProperties, \"wrapS\", \"CLAMP_TO_EDGE\");\n", "        if (strcasecmp(wrapS, \"REPEAT\")==0)\n", "            texParams.sAddressMode = backend::SamplerAddressMode::REPEAT;\n", "        else if(strcasecmp(wrapS, \"CLAMP_TO_EDGE\")==0)\n", "            texParams.sAddressMode = backend::SamplerAddressMode::CLAMP_TO_EDGE;\n", "        else\n", "            CCLOG(\"Invalid wrapS: %s\", wrapS);\n", "\n", "\n", "        // valid options: REPEAT, CLAMP\n", "        const char* wrapT = getOptionalString(samplerProperties, \"wrapT\", \"CLAMP_TO_EDGE\");\n", "        if (strcasecmp(wrapT, \"REPEAT\")==0)\n", "            texParams.tAddressMode = backend::SamplerAddressMode::REPEAT;\n", "        else if(strcasecmp(wrapT, \"CLAMP_TO_EDGE\")==0)\n", "            texParams.tAddressMode = backend::SamplerAddressMode::CLAMP_TO_EDGE;\n", "        else\n", "            CCLOG(\"Invalid wrapT: %s\", wrapT);\n", "\n", "\n", "        // valid options: NEAREST, LINEAR, NEAREST_MIPMAP_NEAREST, LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR\n", "        const char* minFilter = getOptionalString(samplerProperties, \"minFilter\", usemipmap ? \"LINEAR_MIPMAP_NEAREST\" : \"LINEAR\");\n", "        if (strcasecmp(minFilter, \"NEAREST\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::NEAREST;\n", "        else if(strcasecmp(minFilter, \"LINEAR\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "        else if(strcasecmp(minFilter, \"NEAREST_MIPMAP_NEAREST\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::NEAREST;\n", "        else if(strcasecmp(minFilter, \"LINEAR_MIPMAP_NEAREST\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "        else if(strcasecmp(minFilter, \"NEAREST_MIPMAP_LINEAR\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "        else if(strcasecmp(minFilter, \"LINEAR_MIPMAP_LINEAR\")==0)\n", "            texParams.minFilter = backend::SamplerFilter::LINEAR;\n", "        else\n", "            CCLOG(\"Invalid minFilter: %s\", minFilter);\n", "\n", "        // valid options: NEAREST, LINEAR\n", "        const char* magFilter = getOptionalString(samplerProperties, \"magFilter\", \"LINEAR\");\n", "        if (strcasecmp(magFilter, \"NEAREST\")==0)\n", "            texParams.magFilter = backend::SamplerFilter::NEAREST;\n", "        else if(strcasecmp(magFilter, \"LINEAR\")==0)\n", "            texParams.magFilter = backend::SamplerFilter::LINEAR;\n", "        else\n", "            CCLOG(\"Invalid magFilter: %s\", magFilter);\n", "\n", "        texture->setTexParameters(texParams);\n", "    }\n", "\n", "    auto textureName = samplerProperties->getId();\n", "    auto location = programState->getUniformLocation(textureName);\n", "    \n", "    if (!location)\n", "    {\n", "        CCLOG(\"warning: failed to find texture uniform location %s when parsing material\", textureName);\n", "        return false;\n", "    }\n", "\n", "    if (_textureSlots.find(textureName) == _textureSlots.end())\n", "    {\n", "        _textureSlots[textureName] = _textureSlotIndex;\n", "        programState->setTexture(location, _textureSlotIndex++, texture->getBackendTexture());\n", "    }\n", "    else\n", "    {\n", "        programState->setTexture(location, _textureSlots[textureName], texture->getBackendTexture());\n", "    }\n", "\n", "    return true;\n", "}\n"], "CCMaterial.h_header": ["\n", "#include <string>\n", "#include <unordered_map>\n", "\n", "#include \"renderer/CCRenderState.h\"\n", "#include \"renderer/CCTechnique.h\"\n", "#include \"renderer/CCCustomCommand.h\"\n", "#include \"base/CCRef.h\"\n", "#include \"base/CCVector.h\"\n", "#include \"math/Vec2.h\"\n", "#include \"math/Vec3.h\"\n", "#include \"math/Vec4.h\"\n", "#include \"math/Mat4.h\"\n", "#include \"platform/CCPlatformMacros.h\"\n", "\n", "\n", "NS_CC_BEGIN\n", "\n", "class Technique;\n", "class Pass;\n", "class GLProgramState;\n", "class Node;\n", "class Properties;\n", "class RenderState;\n", "\n", "namespace backend\n", "{\n", "    class ProgramState;\n", "}\n", "\n", "/// Material\n"]}